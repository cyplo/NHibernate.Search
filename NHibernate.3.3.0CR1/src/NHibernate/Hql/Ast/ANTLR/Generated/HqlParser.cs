//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Hql.g 2012-03-26 18:15:29

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using NHibernate.Hql.Ast.ANTLR.Tree;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  NHibernate.Hql.Ast.ANTLR 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class HqlParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AGGREGATE", "ALIAS", "ALL", "AND", "ANY", "AS", "ASCENDING", "AVG", "BAND", "BETWEEN", "BNOT", "BOR", "BOTH", "BXOR", "CASE", "CASE2", "CLASS", "CLOSE", "CLOSE_BRACKET", "COLON", "COMMA", "CONCAT", "CONSTANT", "CONSTRUCTOR", "COUNT", "DELETE", "DESCENDING", "DISTINCT", "DIV", "DOT", "ELEMENTS", "ELSE", "EMPTY", "END", "EQ", "ESCAPE", "ESCqs", "EXISTS", "EXPONENT", "EXPR_LIST", "FALSE", "FETCH", "FILTER_ENTITY", "FLOAT_SUFFIX", "FROM", "FULL", "GE", "GROUP", "GT", "HAVING", "HEX_DIGIT", "IDENT", "ID_LETTER", "ID_START_LETTER", "IN", "INDEX_OP", "INDICES", "INNER", "INSERT", "INTO", "IN_LIST", "IS", "IS_NOT_NULL", "IS_NULL", "JAVA_CONSTANT", "JOIN", "LE", "LEADING", "LEFT", "LIKE", "LITERAL_by", "LT", "MAX", "MEMBER", "METHOD_CALL", "MIN", "MINUS", "NE", "NEW", "NOT", "NOT_BETWEEN", "NOT_IN", "NOT_LIKE", "NULL", "NUM_DECIMAL", "NUM_DOUBLE", "NUM_FLOAT", "NUM_INT", "NUM_LONG", "OBJECT", "OF", "ON", "OPEN", "OPEN_BRACKET", "OR", "ORDER", "ORDER_ELEMENT", "OUTER", "PARAM", "PLUS", "PROPERTIES", "QUERY", "QUOTED_String", "RANGE", "RIGHT", "ROW_STAR", "SELECT", "SELECT_FROM", "SET", "SKIP", "SOME", "SQL_NE", "STAR", "SUM", "TAKE", "THEN", "TRAILING", "TRUE", "UNARY_MINUS", "UNARY_PLUS", "UNION", "UPDATE", "VECTOR_EXPR", "VERSIONED", "WEIRD_IDENT", "WHEN", "WHERE", "WITH", "WS", "'ascending'", "'descending'"
	};
	public const int EOF=-1;
	public const int AGGREGATE=4;
	public const int ALIAS=5;
	public const int ALL=6;
	public const int AND=7;
	public const int ANY=8;
	public const int AS=9;
	public const int ASCENDING=10;
	public const int AVG=11;
	public const int BAND=12;
	public const int BETWEEN=13;
	public const int BNOT=14;
	public const int BOR=15;
	public const int BOTH=16;
	public const int BXOR=17;
	public const int CASE=18;
	public const int CASE2=19;
	public const int CLASS=20;
	public const int CLOSE=21;
	public const int CLOSE_BRACKET=22;
	public const int COLON=23;
	public const int COMMA=24;
	public const int CONCAT=25;
	public const int CONSTANT=26;
	public const int CONSTRUCTOR=27;
	public const int COUNT=28;
	public const int DELETE=29;
	public const int DESCENDING=30;
	public const int DISTINCT=31;
	public const int DIV=32;
	public const int DOT=33;
	public const int ELEMENTS=34;
	public const int ELSE=35;
	public const int EMPTY=36;
	public const int END=37;
	public const int EQ=38;
	public const int ESCAPE=39;
	public const int ESCqs=40;
	public const int EXISTS=41;
	public const int EXPONENT=42;
	public const int EXPR_LIST=43;
	public const int FALSE=44;
	public const int FETCH=45;
	public const int FILTER_ENTITY=46;
	public const int FLOAT_SUFFIX=47;
	public const int FROM=48;
	public const int FULL=49;
	public const int GE=50;
	public const int GROUP=51;
	public const int GT=52;
	public const int HAVING=53;
	public const int HEX_DIGIT=54;
	public const int IDENT=55;
	public const int ID_LETTER=56;
	public const int ID_START_LETTER=57;
	public const int IN=58;
	public const int INDEX_OP=59;
	public const int INDICES=60;
	public const int INNER=61;
	public const int INSERT=62;
	public const int INTO=63;
	public const int IN_LIST=64;
	public const int IS=65;
	public const int IS_NOT_NULL=66;
	public const int IS_NULL=67;
	public const int JAVA_CONSTANT=68;
	public const int JOIN=69;
	public const int LE=70;
	public const int LEADING=71;
	public const int LEFT=72;
	public const int LIKE=73;
	public const int LITERAL_by=74;
	public const int LT=75;
	public const int MAX=76;
	public const int MEMBER=77;
	public const int METHOD_CALL=78;
	public const int MIN=79;
	public const int MINUS=80;
	public const int NE=81;
	public const int NEW=82;
	public const int NOT=83;
	public const int NOT_BETWEEN=84;
	public const int NOT_IN=85;
	public const int NOT_LIKE=86;
	public const int NULL=87;
	public const int NUM_DECIMAL=88;
	public const int NUM_DOUBLE=89;
	public const int NUM_FLOAT=90;
	public const int NUM_INT=91;
	public const int NUM_LONG=92;
	public const int OBJECT=93;
	public const int OF=94;
	public const int ON=95;
	public const int OPEN=96;
	public const int OPEN_BRACKET=97;
	public const int OR=98;
	public const int ORDER=99;
	public const int ORDER_ELEMENT=100;
	public const int OUTER=101;
	public const int PARAM=102;
	public const int PLUS=103;
	public const int PROPERTIES=104;
	public const int QUERY=105;
	public const int QUOTED_String=106;
	public const int RANGE=107;
	public const int RIGHT=108;
	public const int ROW_STAR=109;
	public const int SELECT=110;
	public const int SELECT_FROM=111;
	public const int SET=112;
	public const int SKIP=113;
	public const int SOME=114;
	public const int SQL_NE=115;
	public const int STAR=116;
	public const int SUM=117;
	public const int TAKE=118;
	public const int THEN=119;
	public const int TRAILING=120;
	public const int TRUE=121;
	public const int UNARY_MINUS=122;
	public const int UNARY_PLUS=123;
	public const int UNION=124;
	public const int UPDATE=125;
	public const int VECTOR_EXPR=126;
	public const int VERSIONED=127;
	public const int WEIRD_IDENT=128;
	public const int WHEN=129;
	public const int WHERE=130;
	public const int WITH=131;
	public const int WS=132;
	public const int T__133=133;
	public const int T__134=134;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public HqlParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public HqlParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return HqlParser.tokenNames; } }
	public override string GrammarFileName { get { return "Hql.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_statement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_statement() {}
	// $ANTLR start "statement"
	// Hql.g:129:1: statement : ( updateStatement | deleteStatement | selectStatement | insertStatement ) EOF !;
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<IASTNode, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 1);
		TraceIn("statement", 1);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken EOF5 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> updateStatement1 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> deleteStatement2 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> selectStatement3 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> insertStatement4 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode EOF5_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(129, 1);
		try
		{
			// Hql.g:130:2: ( ( updateStatement | deleteStatement | selectStatement | insertStatement ) EOF !)
			DebugEnterAlt(1);
			// Hql.g:130:4: ( updateStatement | deleteStatement | selectStatement | insertStatement ) EOF !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(130, 4);
			// Hql.g:130:4: ( updateStatement | deleteStatement | selectStatement | insertStatement )
			int alt1=4;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
			switch (input.LA(1))
			{
			case UPDATE:
				{
				alt1 = 1;
				}
				break;
			case DELETE:
				{
				alt1 = 2;
				}
				break;
			case EOF:
			case CLOSE:
			case FROM:
			case GROUP:
			case HAVING:
			case ORDER:
			case SELECT:
			case SKIP:
			case TAKE:
			case UNION:
			case WHERE:
				{
				alt1 = 3;
				}
				break;
			case INSERT:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:130:6: updateStatement
				{
				DebugLocation(130, 6);
				PushFollow(Follow._updateStatement_in_statement611);
				updateStatement1=updateStatement();
				PopFollow();

				adaptor.AddChild(root_0, updateStatement1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:130:24: deleteStatement
				{
				DebugLocation(130, 24);
				PushFollow(Follow._deleteStatement_in_statement615);
				deleteStatement2=deleteStatement();
				PopFollow();

				adaptor.AddChild(root_0, deleteStatement2.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:130:42: selectStatement
				{
				DebugLocation(130, 42);
				PushFollow(Follow._selectStatement_in_statement619);
				selectStatement3=selectStatement();
				PopFollow();

				adaptor.AddChild(root_0, selectStatement3.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:130:60: insertStatement
				{
				DebugLocation(130, 60);
				PushFollow(Follow._insertStatement_in_statement623);
				insertStatement4=insertStatement();
				PopFollow();

				adaptor.AddChild(root_0, insertStatement4.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(130, 81);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_statement627); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 1);
			LeaveRule("statement", 1);
			LeaveRule_statement();
	    }
	 	DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_updateStatement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_updateStatement() {}
	// $ANTLR start "updateStatement"
	// Hql.g:133:1: updateStatement : UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )? ;
	[GrammarRule("updateStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> updateStatement()
	{
		EnterRule_updateStatement();
		EnterRule("updateStatement", 2);
		TraceIn("updateStatement", 2);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken UPDATE6 = default(IToken);
	    IToken VERSIONED7 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause8 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> setClause9 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> whereClause10 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode UPDATE6_tree = default(IASTNode);
	    IASTNode VERSIONED7_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "updateStatement");
		DebugLocation(133, 1);
		try
		{
			// Hql.g:134:2: ( UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )? )
			DebugEnterAlt(1);
			// Hql.g:134:4: UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(134, 10);
			UPDATE6=(IToken)Match(input,UPDATE,Follow._UPDATE_in_updateStatement639); 
			UPDATE6_tree = (IASTNode)adaptor.Create(UPDATE6);
			root_0 = (IASTNode)adaptor.BecomeRoot(UPDATE6_tree, root_0);

			DebugLocation(134, 12);
			// Hql.g:134:12: ( VERSIONED )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
			int LA2_1 = input.LA(1);

			if ((LA2_1==VERSIONED))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:134:13: VERSIONED
				{
				DebugLocation(134, 13);
				VERSIONED7=(IToken)Match(input,VERSIONED,Follow._VERSIONED_in_updateStatement643); 
				VERSIONED7_tree = (IASTNode)adaptor.Create(VERSIONED7);
				adaptor.AddChild(root_0, VERSIONED7_tree);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(135, 3);
			PushFollow(Follow._optionalFromTokenFromClause_in_updateStatement649);
			optionalFromTokenFromClause8=optionalFromTokenFromClause();
			PopFollow();

			adaptor.AddChild(root_0, optionalFromTokenFromClause8.Tree);
			DebugLocation(136, 3);
			PushFollow(Follow._setClause_in_updateStatement653);
			setClause9=setClause();
			PopFollow();

			adaptor.AddChild(root_0, setClause9.Tree);
			DebugLocation(137, 3);
			// Hql.g:137:3: ( whereClause )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_1 = input.LA(1);

			if ((LA3_1==WHERE))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:137:4: whereClause
				{
				DebugLocation(137, 4);
				PushFollow(Follow._whereClause_in_updateStatement658);
				whereClause10=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause10.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("updateStatement", 2);
			LeaveRule("updateStatement", 2);
			LeaveRule_updateStatement();
	    }
	 	DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "updateStatement"); }
		return retval;

	}
	// $ANTLR end "updateStatement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_setClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_setClause() {}
	// $ANTLR start "setClause"
	// Hql.g:140:1: setClause : ( SET ^ assignment ( COMMA ! assignment )* ) ;
	[GrammarRule("setClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> setClause()
	{
		EnterRule_setClause();
		EnterRule("setClause", 3);
		TraceIn("setClause", 3);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken SET11 = default(IToken);
	    IToken COMMA13 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> assignment12 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> assignment14 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode SET11_tree = default(IASTNode);
	    IASTNode COMMA13_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "setClause");
		DebugLocation(140, 1);
		try
		{
			// Hql.g:141:2: ( ( SET ^ assignment ( COMMA ! assignment )* ) )
			DebugEnterAlt(1);
			// Hql.g:141:4: ( SET ^ assignment ( COMMA ! assignment )* )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(141, 4);
			// Hql.g:141:4: ( SET ^ assignment ( COMMA ! assignment )* )
			DebugEnterAlt(1);
			// Hql.g:141:5: SET ^ assignment ( COMMA ! assignment )*
			{
			DebugLocation(141, 8);
			SET11=(IToken)Match(input,SET,Follow._SET_in_setClause672); 
			SET11_tree = (IASTNode)adaptor.Create(SET11);
			root_0 = (IASTNode)adaptor.BecomeRoot(SET11_tree, root_0);

			DebugLocation(141, 10);
			PushFollow(Follow._assignment_in_setClause675);
			assignment12=assignment();
			PopFollow();

			adaptor.AddChild(root_0, assignment12.Tree);
			DebugLocation(141, 21);
			// Hql.g:141:21: ( COMMA ! assignment )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, decisionCanBacktrack[4]);
				int LA4_1 = input.LA(1);

				if ((LA4_1==COMMA))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:141:22: COMMA ! assignment
					{
					DebugLocation(141, 27);
					COMMA13=(IToken)Match(input,COMMA,Follow._COMMA_in_setClause678); 
					DebugLocation(141, 29);
					PushFollow(Follow._assignment_in_setClause681);
					assignment14=assignment();
					PopFollow();

					adaptor.AddChild(root_0, assignment14.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("setClause", 3);
			LeaveRule("setClause", 3);
			LeaveRule_setClause();
	    }
	 	DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "setClause"); }
		return retval;

	}
	// $ANTLR end "setClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_assignment() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_assignment() {}
	// $ANTLR start "assignment"
	// Hql.g:144:1: assignment : stateField EQ ^ newValue ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<IASTNode, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken EQ16 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> stateField15 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> newValue17 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode EQ16_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(144, 1);
		try
		{
			// Hql.g:145:2: ( stateField EQ ^ newValue )
			DebugEnterAlt(1);
			// Hql.g:145:4: stateField EQ ^ newValue
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(145, 4);
			PushFollow(Follow._stateField_in_assignment695);
			stateField15=stateField();
			PopFollow();

			adaptor.AddChild(root_0, stateField15.Tree);
			DebugLocation(145, 17);
			EQ16=(IToken)Match(input,EQ,Follow._EQ_in_assignment697); 
			EQ16_tree = (IASTNode)adaptor.Create(EQ16);
			root_0 = (IASTNode)adaptor.BecomeRoot(EQ16_tree, root_0);

			DebugLocation(145, 19);
			PushFollow(Follow._newValue_in_assignment700);
			newValue17=newValue();
			PopFollow();

			adaptor.AddChild(root_0, newValue17.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
	    }
	 	DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_stateField() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_stateField() {}
	// $ANTLR start "stateField"
	// Hql.g:150:1: stateField : path ;
	[GrammarRule("stateField")]
	private AstParserRuleReturnScope<IASTNode, IToken> stateField()
	{
		EnterRule_stateField();
		EnterRule("stateField", 5);
		TraceIn("stateField", 5);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> path18 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "stateField");
		DebugLocation(150, 1);
		try
		{
			// Hql.g:151:2: ( path )
			DebugEnterAlt(1);
			// Hql.g:151:4: path
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(151, 4);
			PushFollow(Follow._path_in_stateField713);
			path18=path();
			PopFollow();

			adaptor.AddChild(root_0, path18.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stateField", 5);
			LeaveRule("stateField", 5);
			LeaveRule_stateField();
	    }
	 	DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "stateField"); }
		return retval;

	}
	// $ANTLR end "stateField"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_newValue() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_newValue() {}
	// $ANTLR start "newValue"
	// Hql.g:156:1: newValue : concatenation ;
	[GrammarRule("newValue")]
	private AstParserRuleReturnScope<IASTNode, IToken> newValue()
	{
		EnterRule_newValue();
		EnterRule("newValue", 6);
		TraceIn("newValue", 6);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> concatenation19 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "newValue");
		DebugLocation(156, 1);
		try
		{
			// Hql.g:157:2: ( concatenation )
			DebugEnterAlt(1);
			// Hql.g:157:4: concatenation
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(157, 4);
			PushFollow(Follow._concatenation_in_newValue726);
			concatenation19=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation19.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newValue", 6);
			LeaveRule("newValue", 6);
			LeaveRule_newValue();
	    }
	 	DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "newValue"); }
		return retval;

	}
	// $ANTLR end "newValue"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_deleteStatement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_deleteStatement() {}
	// $ANTLR start "deleteStatement"
	// Hql.g:160:1: deleteStatement : DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )? ;
	[GrammarRule("deleteStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> deleteStatement()
	{
		EnterRule_deleteStatement();
		EnterRule("deleteStatement", 7);
		TraceIn("deleteStatement", 7);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken DELETE20 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause21 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> whereClause22 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode DELETE20_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "deleteStatement");
		DebugLocation(160, 1);
		try
		{
			// Hql.g:161:2: ( DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )? )
			DebugEnterAlt(1);
			// Hql.g:161:4: DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(161, 10);
			DELETE20=(IToken)Match(input,DELETE,Follow._DELETE_in_deleteStatement737); 
			DELETE20_tree = (IASTNode)adaptor.Create(DELETE20);
			root_0 = (IASTNode)adaptor.BecomeRoot(DELETE20_tree, root_0);

			DebugLocation(162, 3);
			// Hql.g:162:3: ( optionalFromTokenFromClause )
			DebugEnterAlt(1);
			// Hql.g:162:4: optionalFromTokenFromClause
			{
			DebugLocation(162, 4);
			PushFollow(Follow._optionalFromTokenFromClause_in_deleteStatement743);
			optionalFromTokenFromClause21=optionalFromTokenFromClause();
			PopFollow();

			adaptor.AddChild(root_0, optionalFromTokenFromClause21.Tree);

			}

			DebugLocation(163, 3);
			// Hql.g:163:3: ( whereClause )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, decisionCanBacktrack[5]);
			int LA5_1 = input.LA(1);

			if ((LA5_1==WHERE))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:163:4: whereClause
				{
				DebugLocation(163, 4);
				PushFollow(Follow._whereClause_in_deleteStatement749);
				whereClause22=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause22.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("deleteStatement", 7);
			LeaveRule("deleteStatement", 7);
			LeaveRule_deleteStatement();
	    }
	 	DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "deleteStatement"); }
		return retval;

	}
	// $ANTLR end "deleteStatement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_optionalFromTokenFromClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_optionalFromTokenFromClause() {}
	// $ANTLR start "optionalFromTokenFromClause"
	// Hql.g:168:1: optionalFromTokenFromClause : optionalFromTokenFromClause2 path ( asAlias )? -> ^( FROM ^( RANGE path ( asAlias )? ) ) ;
	[GrammarRule("optionalFromTokenFromClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause()
	{
		EnterRule_optionalFromTokenFromClause();
		EnterRule("optionalFromTokenFromClause", 8);
		TraceIn("optionalFromTokenFromClause", 8);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause223 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> path24 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> asAlias25 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_optionalFromTokenFromClause2=new RewriteRuleSubtreeStream(adaptor,"rule optionalFromTokenFromClause2");
	    RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
	    RewriteRuleSubtreeStream stream_asAlias=new RewriteRuleSubtreeStream(adaptor,"rule asAlias");
		try { DebugEnterRule(GrammarFileName, "optionalFromTokenFromClause");
		DebugLocation(168, 1);
		try
		{
			// Hql.g:169:2: ( optionalFromTokenFromClause2 path ( asAlias )? -> ^( FROM ^( RANGE path ( asAlias )? ) ) )
			DebugEnterAlt(1);
			// Hql.g:169:4: optionalFromTokenFromClause2 path ( asAlias )?
			{
			DebugLocation(169, 4);
			PushFollow(Follow._optionalFromTokenFromClause2_in_optionalFromTokenFromClause764);
			optionalFromTokenFromClause223=optionalFromTokenFromClause2();
			PopFollow();

			stream_optionalFromTokenFromClause2.Add(optionalFromTokenFromClause223.Tree);
			DebugLocation(169, 33);
			PushFollow(Follow._path_in_optionalFromTokenFromClause766);
			path24=path();
			PopFollow();

			stream_path.Add(path24.Tree);
			DebugLocation(169, 38);
			// Hql.g:169:38: ( asAlias )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, decisionCanBacktrack[6]);
			int LA6_1 = input.LA(1);

			if ((LA6_1==AS||LA6_1==IDENT))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:169:39: asAlias
				{
				DebugLocation(169, 39);
				PushFollow(Follow._asAlias_in_optionalFromTokenFromClause769);
				asAlias25=asAlias();
				PopFollow();

				stream_asAlias.Add(asAlias25.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: path, asAlias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 170:3: -> ^( FROM ^( RANGE path ( asAlias )? ) )
			{
				DebugLocation(170, 6);
				// Hql.g:170:6: ^( FROM ^( RANGE path ( asAlias )? ) )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(170, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(FROM, "FROM"), root_1);

				DebugLocation(170, 13);
				// Hql.g:170:13: ^( RANGE path ( asAlias )? )
				{
				IASTNode root_2 = (IASTNode)adaptor.Nil();
				DebugLocation(170, 15);
				root_2 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_2);

				DebugLocation(170, 21);
				adaptor.AddChild(root_2, stream_path.NextTree());
				DebugLocation(170, 26);
				// Hql.g:170:26: ( asAlias )?
				if (stream_asAlias.HasNext)
				{
					DebugLocation(170, 26);
					adaptor.AddChild(root_2, stream_asAlias.NextTree());

				}
				stream_asAlias.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionalFromTokenFromClause", 8);
			LeaveRule("optionalFromTokenFromClause", 8);
			LeaveRule_optionalFromTokenFromClause();
	    }
	 	DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalFromTokenFromClause"); }
		return retval;

	}
	// $ANTLR end "optionalFromTokenFromClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_optionalFromTokenFromClause2() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_optionalFromTokenFromClause2() {}
	// $ANTLR start "optionalFromTokenFromClause2"
	// Hql.g:173:1: optionalFromTokenFromClause2 : ( FROM )? ;
	[GrammarRule("optionalFromTokenFromClause2")]
	private AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause2()
	{
		EnterRule_optionalFromTokenFromClause2();
		EnterRule("optionalFromTokenFromClause2", 9);
		TraceIn("optionalFromTokenFromClause2", 9);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken FROM26 = default(IToken);

	    IASTNode FROM26_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "optionalFromTokenFromClause2");
		DebugLocation(173, 1);
		try
		{
			// Hql.g:174:2: ( ( FROM )? )
			DebugEnterAlt(1);
			// Hql.g:174:4: ( FROM )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(174, 4);
			// Hql.g:174:4: ( FROM )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, decisionCanBacktrack[7]);
			int LA7_1 = input.LA(1);

			if ((LA7_1==FROM))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:174:4: FROM
				{
				DebugLocation(174, 4);
				FROM26=(IToken)Match(input,FROM,Follow._FROM_in_optionalFromTokenFromClause2800); 
				FROM26_tree = (IASTNode)adaptor.Create(FROM26);
				adaptor.AddChild(root_0, FROM26_tree);


				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionalFromTokenFromClause2", 9);
			LeaveRule("optionalFromTokenFromClause2", 9);
			LeaveRule_optionalFromTokenFromClause2();
	    }
	 	DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalFromTokenFromClause2"); }
		return retval;

	}
	// $ANTLR end "optionalFromTokenFromClause2"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_selectStatement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_selectStatement() {}
	// $ANTLR start "selectStatement"
	// Hql.g:177:1: selectStatement : q= queryRule -> ^( QUERY[\"query\"] $q) ;
	[GrammarRule("selectStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectStatement()
	{
		EnterRule_selectStatement();
		EnterRule("selectStatement", 10);
		TraceIn("selectStatement", 10);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> q = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_queryRule=new RewriteRuleSubtreeStream(adaptor,"rule queryRule");
		try { DebugEnterRule(GrammarFileName, "selectStatement");
		DebugLocation(177, 1);
		try
		{
			// Hql.g:178:2: (q= queryRule -> ^( QUERY[\"query\"] $q) )
			DebugEnterAlt(1);
			// Hql.g:178:4: q= queryRule
			{
			DebugLocation(178, 5);
			PushFollow(Follow._queryRule_in_selectStatement814);
			q=queryRule();
			PopFollow();

			stream_queryRule.Add(q.Tree);


			{
			// AST REWRITE
			// elements: q
			// token labels: 
			// rule labels: q, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 179:2: -> ^( QUERY[\"query\"] $q)
			{
				DebugLocation(179, 5);
				// Hql.g:179:5: ^( QUERY[\"query\"] $q)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(179, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(QUERY, "query"), root_1);

				DebugLocation(179, 23);
				adaptor.AddChild(root_1, stream_q.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectStatement", 10);
			LeaveRule("selectStatement", 10);
			LeaveRule_selectStatement();
	    }
	 	DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "selectStatement"); }
		return retval;

	}
	// $ANTLR end "selectStatement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_insertStatement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_insertStatement() {}
	// $ANTLR start "insertStatement"
	// Hql.g:182:1: insertStatement : INSERT ^ intoClause selectStatement ;
	[GrammarRule("insertStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> insertStatement()
	{
		EnterRule_insertStatement();
		EnterRule("insertStatement", 11);
		TraceIn("insertStatement", 11);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken INSERT27 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> intoClause28 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> selectStatement29 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode INSERT27_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "insertStatement");
		DebugLocation(182, 1);
		try
		{
			// Hql.g:186:2: ( INSERT ^ intoClause selectStatement )
			DebugEnterAlt(1);
			// Hql.g:186:4: INSERT ^ intoClause selectStatement
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(186, 10);
			INSERT27=(IToken)Match(input,INSERT,Follow._INSERT_in_insertStatement843); 
			INSERT27_tree = (IASTNode)adaptor.Create(INSERT27);
			root_0 = (IASTNode)adaptor.BecomeRoot(INSERT27_tree, root_0);

			DebugLocation(186, 12);
			PushFollow(Follow._intoClause_in_insertStatement846);
			intoClause28=intoClause();
			PopFollow();

			adaptor.AddChild(root_0, intoClause28.Tree);
			DebugLocation(186, 23);
			PushFollow(Follow._selectStatement_in_insertStatement848);
			selectStatement29=selectStatement();
			PopFollow();

			adaptor.AddChild(root_0, selectStatement29.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("insertStatement", 11);
			LeaveRule("insertStatement", 11);
			LeaveRule_insertStatement();
	    }
	 	DebugLocation(187, 1);
		} finally { DebugExitRule(GrammarFileName, "insertStatement"); }
		return retval;

	}
	// $ANTLR end "insertStatement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_intoClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_intoClause() {}
	// $ANTLR start "intoClause"
	// Hql.g:189:1: intoClause : INTO ^ path insertablePropertySpec ;
	[GrammarRule("intoClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> intoClause()
	{
		EnterRule_intoClause();
		EnterRule("intoClause", 12);
		TraceIn("intoClause", 12);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken INTO30 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> path31 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> insertablePropertySpec32 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode INTO30_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "intoClause");
		DebugLocation(189, 1);
		try
		{
			// Hql.g:190:2: ( INTO ^ path insertablePropertySpec )
			DebugEnterAlt(1);
			// Hql.g:190:4: INTO ^ path insertablePropertySpec
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(190, 8);
			INTO30=(IToken)Match(input,INTO,Follow._INTO_in_intoClause859); 
			INTO30_tree = (IASTNode)adaptor.Create(INTO30);
			root_0 = (IASTNode)adaptor.BecomeRoot(INTO30_tree, root_0);

			DebugLocation(190, 10);
			PushFollow(Follow._path_in_intoClause862);
			path31=path();
			PopFollow();

			adaptor.AddChild(root_0, path31.Tree);
			DebugLocation(190, 15);
			 WeakKeywords(); 
			DebugLocation(190, 35);
			PushFollow(Follow._insertablePropertySpec_in_intoClause866);
			insertablePropertySpec32=insertablePropertySpec();
			PopFollow();

			adaptor.AddChild(root_0, insertablePropertySpec32.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("intoClause", 12);
			LeaveRule("intoClause", 12);
			LeaveRule_intoClause();
	    }
	 	DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "intoClause"); }
		return retval;

	}
	// $ANTLR end "intoClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_insertablePropertySpec() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_insertablePropertySpec() {}
	// $ANTLR start "insertablePropertySpec"
	// Hql.g:193:1: insertablePropertySpec : OPEN primaryExpression ( COMMA primaryExpression )* CLOSE -> ^( RANGE[\"column-spec\"] ( primaryExpression )* ) ;
	[GrammarRule("insertablePropertySpec")]
	private AstParserRuleReturnScope<IASTNode, IToken> insertablePropertySpec()
	{
		EnterRule_insertablePropertySpec();
		EnterRule("insertablePropertySpec", 13);
		TraceIn("insertablePropertySpec", 13);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken OPEN33 = default(IToken);
	    IToken COMMA35 = default(IToken);
	    IToken CLOSE37 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> primaryExpression34 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> primaryExpression36 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode OPEN33_tree = default(IASTNode);
	    IASTNode COMMA35_tree = default(IASTNode);
	    IASTNode CLOSE37_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
	    RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
	    RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
	    RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		try { DebugEnterRule(GrammarFileName, "insertablePropertySpec");
		DebugLocation(193, 1);
		try
		{
			// Hql.g:194:2: ( OPEN primaryExpression ( COMMA primaryExpression )* CLOSE -> ^( RANGE[\"column-spec\"] ( primaryExpression )* ) )
			DebugEnterAlt(1);
			// Hql.g:194:4: OPEN primaryExpression ( COMMA primaryExpression )* CLOSE
			{
			DebugLocation(194, 4);
			OPEN33=(IToken)Match(input,OPEN,Follow._OPEN_in_insertablePropertySpec877);  
			stream_OPEN.Add(OPEN33);

			DebugLocation(194, 9);
			PushFollow(Follow._primaryExpression_in_insertablePropertySpec879);
			primaryExpression34=primaryExpression();
			PopFollow();

			stream_primaryExpression.Add(primaryExpression34.Tree);
			DebugLocation(194, 27);
			// Hql.g:194:27: ( COMMA primaryExpression )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, decisionCanBacktrack[8]);
				int LA8_1 = input.LA(1);

				if ((LA8_1==COMMA))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:194:29: COMMA primaryExpression
					{
					DebugLocation(194, 29);
					COMMA35=(IToken)Match(input,COMMA,Follow._COMMA_in_insertablePropertySpec883);  
					stream_COMMA.Add(COMMA35);

					DebugLocation(194, 35);
					PushFollow(Follow._primaryExpression_in_insertablePropertySpec885);
					primaryExpression36=primaryExpression();
					PopFollow();

					stream_primaryExpression.Add(primaryExpression36.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(194, 56);
			CLOSE37=(IToken)Match(input,CLOSE,Follow._CLOSE_in_insertablePropertySpec890);  
			stream_CLOSE.Add(CLOSE37);



			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 195:3: -> ^( RANGE[\"column-spec\"] ( primaryExpression )* )
			{
				DebugLocation(195, 6);
				// Hql.g:195:6: ^( RANGE[\"column-spec\"] ( primaryExpression )* )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(195, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "column-spec"), root_1);

				DebugLocation(195, 29);
				// Hql.g:195:29: ( primaryExpression )*
				while ( stream_primaryExpression.HasNext )
				{
					DebugLocation(195, 29);
					adaptor.AddChild(root_1, stream_primaryExpression.NextTree());

				}
				stream_primaryExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("insertablePropertySpec", 13);
			LeaveRule("insertablePropertySpec", 13);
			LeaveRule_insertablePropertySpec();
	    }
	 	DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "insertablePropertySpec"); }
		return retval;

	}
	// $ANTLR end "insertablePropertySpec"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_queryRule() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_queryRule() {}
	// $ANTLR start "queryRule"
	// Hql.g:201:1: queryRule : selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? ;
	[GrammarRule("queryRule")]
	private AstParserRuleReturnScope<IASTNode, IToken> queryRule()
	{
		EnterRule_queryRule();
		EnterRule("queryRule", 14);
		TraceIn("queryRule", 14);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> selectFrom38 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> whereClause39 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> groupByClause40 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> havingClause41 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> orderByClause42 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> skipClause43 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> takeClause44 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "queryRule");
		DebugLocation(201, 2);
		try
		{
			// Hql.g:202:2: ( selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? )
			DebugEnterAlt(1);
			// Hql.g:202:4: selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(202, 4);
			PushFollow(Follow._selectFrom_in_queryRule916);
			selectFrom38=selectFrom();
			PopFollow();

			adaptor.AddChild(root_0, selectFrom38.Tree);
			DebugLocation(203, 3);
			// Hql.g:203:3: ( whereClause )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, decisionCanBacktrack[9]);
			int LA9_1 = input.LA(1);

			if ((LA9_1==WHERE))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:203:4: whereClause
				{
				DebugLocation(203, 4);
				PushFollow(Follow._whereClause_in_queryRule921);
				whereClause39=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause39.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(204, 3);
			// Hql.g:204:3: ( groupByClause )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, decisionCanBacktrack[10]);
			int LA10_1 = input.LA(1);

			if ((LA10_1==GROUP))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:204:4: groupByClause
				{
				DebugLocation(204, 4);
				PushFollow(Follow._groupByClause_in_queryRule928);
				groupByClause40=groupByClause();
				PopFollow();

				adaptor.AddChild(root_0, groupByClause40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(205, 3);
			// Hql.g:205:3: ( havingClause )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, decisionCanBacktrack[11]);
			int LA11_1 = input.LA(1);

			if ((LA11_1==HAVING))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:205:4: havingClause
				{
				DebugLocation(205, 4);
				PushFollow(Follow._havingClause_in_queryRule935);
				havingClause41=havingClause();
				PopFollow();

				adaptor.AddChild(root_0, havingClause41.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(206, 3);
			// Hql.g:206:3: ( orderByClause )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, decisionCanBacktrack[12]);
			int LA12_1 = input.LA(1);

			if ((LA12_1==ORDER))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:206:4: orderByClause
				{
				DebugLocation(206, 4);
				PushFollow(Follow._orderByClause_in_queryRule942);
				orderByClause42=orderByClause();
				PopFollow();

				adaptor.AddChild(root_0, orderByClause42.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(207, 3);
			// Hql.g:207:3: ( skipClause )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, decisionCanBacktrack[13]);
			int LA13_1 = input.LA(1);

			if ((LA13_1==SKIP))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:207:4: skipClause
				{
				DebugLocation(207, 4);
				PushFollow(Follow._skipClause_in_queryRule949);
				skipClause43=skipClause();
				PopFollow();

				adaptor.AddChild(root_0, skipClause43.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(208, 3);
			// Hql.g:208:3: ( takeClause )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, decisionCanBacktrack[14]);
			int LA14_1 = input.LA(1);

			if ((LA14_1==TAKE))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:208:4: takeClause
				{
				DebugLocation(208, 4);
				PushFollow(Follow._takeClause_in_queryRule956);
				takeClause44=takeClause();
				PopFollow();

				adaptor.AddChild(root_0, takeClause44.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("queryRule", 14);
			LeaveRule("queryRule", 14);
			LeaveRule_queryRule();
	    }
	 	DebugLocation(209, 2);
		} finally { DebugExitRule(GrammarFileName, "queryRule"); }
		return retval;

	}
	// $ANTLR end "queryRule"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_selectFrom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_selectFrom() {}
	// $ANTLR start "selectFrom"
	// Hql.g:211:1: selectFrom : (s= selectClause )? (f= fromClause )? -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? ) -> ^( SELECT_FROM ( fromClause )? ( selectClause )? ) ;
	[GrammarRule("selectFrom")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectFrom()
	{
		EnterRule_selectFrom();
		EnterRule("selectFrom", 15);
		TraceIn("selectFrom", 15);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> s = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> f = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_selectClause=new RewriteRuleSubtreeStream(adaptor,"rule selectClause");
	    RewriteRuleSubtreeStream stream_fromClause=new RewriteRuleSubtreeStream(adaptor,"rule fromClause");
		try { DebugEnterRule(GrammarFileName, "selectFrom");
		DebugLocation(211, 1);
		try
		{
			// Hql.g:212:2: ( (s= selectClause )? (f= fromClause )? -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? ) -> ^( SELECT_FROM ( fromClause )? ( selectClause )? ) )
			DebugEnterAlt(1);
			// Hql.g:212:5: (s= selectClause )? (f= fromClause )?
			{
			DebugLocation(212, 5);
			// Hql.g:212:5: (s= selectClause )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, decisionCanBacktrack[15]);
			int LA15_1 = input.LA(1);

			if ((LA15_1==SELECT))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:212:6: s= selectClause
				{
				DebugLocation(212, 7);
				PushFollow(Follow._selectClause_in_selectFrom974);
				s=selectClause();
				PopFollow();

				stream_selectClause.Add(s.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(212, 23);
			// Hql.g:212:23: (f= fromClause )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, decisionCanBacktrack[16]);
			int LA16_1 = input.LA(1);

			if ((LA16_1==FROM))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:212:24: f= fromClause
				{
				DebugLocation(212, 25);
				PushFollow(Follow._fromClause_in_selectFrom981);
				f=fromClause();
				PopFollow();

				stream_fromClause.Add(f.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(213, 3);

						if ((f!=null?((IASTNode)f.Tree):default(IASTNode)) == null && !filter) 
							throw new RecognitionException("FROM expected (non-filter queries must contain a FROM clause)");
					


			{
			// AST REWRITE
			// elements: selectClause, fromClause, selectClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 217:3: -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? )
			if ((f!=null?((IASTNode)f.Tree):default(IASTNode)) == null && filter)
			{
				DebugLocation(217, 35);
				// Hql.g:217:35: ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(217, 37);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT_FROM, "SELECT_FROM"), root_1);

				DebugLocation(217, 49);
				adaptor.AddChild(root_1, (IASTNode)adaptor.Create(FROM, "{filter-implied FROM}"));
				DebugLocation(217, 79);
				// Hql.g:217:79: ( selectClause )?
				if (stream_selectClause.HasNext)
				{
					DebugLocation(217, 79);
					adaptor.AddChild(root_1, stream_selectClause.NextTree());

				}
				stream_selectClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 218:3: -> ^( SELECT_FROM ( fromClause )? ( selectClause )? )
			{
				DebugLocation(218, 6);
				// Hql.g:218:6: ^( SELECT_FROM ( fromClause )? ( selectClause )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(218, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT_FROM, "SELECT_FROM"), root_1);

				DebugLocation(218, 20);
				// Hql.g:218:20: ( fromClause )?
				if (stream_fromClause.HasNext)
				{
					DebugLocation(218, 20);
					adaptor.AddChild(root_1, stream_fromClause.NextTree());

				}
				stream_fromClause.Reset();
				DebugLocation(218, 32);
				// Hql.g:218:32: ( selectClause )?
				if (stream_selectClause.HasNext)
				{
					DebugLocation(218, 32);
					adaptor.AddChild(root_1, stream_selectClause.NextTree());

				}
				stream_selectClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectFrom", 15);
			LeaveRule("selectFrom", 15);
			LeaveRule_selectFrom();
	    }
	 	DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "selectFrom"); }
		return retval;

	}
	// $ANTLR end "selectFrom"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_selectClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_selectClause() {}
	// $ANTLR start "selectClause"
	// Hql.g:222:1: selectClause : SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject ) ;
	[GrammarRule("selectClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectClause()
	{
		EnterRule_selectClause();
		EnterRule("selectClause", 16);
		TraceIn("selectClause", 16);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken SELECT45 = default(IToken);
	    IToken DISTINCT46 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList47 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> newExpression48 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> selectObject49 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode SELECT45_tree = default(IASTNode);
	    IASTNode DISTINCT46_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "selectClause");
		DebugLocation(222, 1);
		try
		{
			// Hql.g:223:2: ( SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject ) )
			DebugEnterAlt(1);
			// Hql.g:223:4: SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(223, 10);
			SELECT45=(IToken)Match(input,SELECT,Follow._SELECT_in_selectClause1030); 
			SELECT45_tree = (IASTNode)adaptor.Create(SELECT45);
			root_0 = (IASTNode)adaptor.BecomeRoot(SELECT45_tree, root_0);

			DebugLocation(224, 3);
			 WeakKeywords(); 
			DebugLocation(225, 3);
			// Hql.g:225:3: ( DISTINCT )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, decisionCanBacktrack[17]);
			int LA17_1 = input.LA(1);

			if ((LA17_1==DISTINCT))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:225:4: DISTINCT
				{
				DebugLocation(225, 4);
				DISTINCT46=(IToken)Match(input,DISTINCT,Follow._DISTINCT_in_selectClause1042); 
				DISTINCT46_tree = (IASTNode)adaptor.Create(DISTINCT46);
				adaptor.AddChild(root_0, DISTINCT46_tree);


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(225, 15);
			// Hql.g:225:15: ( selectedPropertiesList | newExpression | selectObject )
			int alt18=3;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, decisionCanBacktrack[18]);
			switch (input.LA(1))
			{
			case ALL:
			case ANY:
			case AVG:
			case BNOT:
			case CASE:
			case COLON:
			case COUNT:
			case ELEMENTS:
			case EMPTY:
			case EXISTS:
			case FALSE:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case MINUS:
			case NOT:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case OPEN:
			case PARAM:
			case PLUS:
			case QUOTED_String:
			case SOME:
			case SUM:
			case TRUE:
				{
				alt18 = 1;
				}
				break;
			case NEW:
				{
				alt18 = 2;
				}
				break;
			case OBJECT:
				{
				alt18 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:225:17: selectedPropertiesList
				{
				DebugLocation(225, 17);
				PushFollow(Follow._selectedPropertiesList_in_selectClause1048);
				selectedPropertiesList47=selectedPropertiesList();
				PopFollow();

				adaptor.AddChild(root_0, selectedPropertiesList47.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:225:42: newExpression
				{
				DebugLocation(225, 42);
				PushFollow(Follow._newExpression_in_selectClause1052);
				newExpression48=newExpression();
				PopFollow();

				adaptor.AddChild(root_0, newExpression48.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:225:58: selectObject
				{
				DebugLocation(225, 58);
				PushFollow(Follow._selectObject_in_selectClause1056);
				selectObject49=selectObject();
				PopFollow();

				adaptor.AddChild(root_0, selectObject49.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectClause", 16);
			LeaveRule("selectClause", 16);
			LeaveRule_selectClause();
	    }
	 	DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "selectClause"); }
		return retval;

	}
	// $ANTLR end "selectClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_newExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_newExpression() {}
	// $ANTLR start "newExpression"
	// Hql.g:228:1: newExpression : ( NEW path ) op= OPEN selectedPropertiesList CLOSE -> ^( CONSTRUCTOR[$op] path selectedPropertiesList ) ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 17);
		TraceIn("newExpression", 17);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken op = default(IToken);
	    IToken NEW50 = default(IToken);
	    IToken CLOSE53 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> path51 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList52 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode op_tree = default(IASTNode);
	    IASTNode NEW50_tree = default(IASTNode);
	    IASTNode CLOSE53_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
	    RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
	    RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
	    RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
	    RewriteRuleSubtreeStream stream_selectedPropertiesList=new RewriteRuleSubtreeStream(adaptor,"rule selectedPropertiesList");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(228, 1);
		try
		{
			// Hql.g:229:2: ( ( NEW path ) op= OPEN selectedPropertiesList CLOSE -> ^( CONSTRUCTOR[$op] path selectedPropertiesList ) )
			DebugEnterAlt(1);
			// Hql.g:229:4: ( NEW path ) op= OPEN selectedPropertiesList CLOSE
			{
			DebugLocation(229, 4);
			// Hql.g:229:4: ( NEW path )
			DebugEnterAlt(1);
			// Hql.g:229:5: NEW path
			{
			DebugLocation(229, 5);
			NEW50=(IToken)Match(input,NEW,Follow._NEW_in_newExpression1070);  
			stream_NEW.Add(NEW50);

			DebugLocation(229, 9);
			PushFollow(Follow._path_in_newExpression1072);
			path51=path();
			PopFollow();

			stream_path.Add(path51.Tree);

			}

			DebugLocation(229, 17);
			op=(IToken)Match(input,OPEN,Follow._OPEN_in_newExpression1077);  
			stream_OPEN.Add(op);

			DebugLocation(229, 23);
			PushFollow(Follow._selectedPropertiesList_in_newExpression1079);
			selectedPropertiesList52=selectedPropertiesList();
			PopFollow();

			stream_selectedPropertiesList.Add(selectedPropertiesList52.Tree);
			DebugLocation(229, 46);
			CLOSE53=(IToken)Match(input,CLOSE,Follow._CLOSE_in_newExpression1081);  
			stream_CLOSE.Add(CLOSE53);



			{
			// AST REWRITE
			// elements: path, selectedPropertiesList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 230:3: -> ^( CONSTRUCTOR[$op] path selectedPropertiesList )
			{
				DebugLocation(230, 6);
				// Hql.g:230:6: ^( CONSTRUCTOR[$op] path selectedPropertiesList )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(230, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CONSTRUCTOR, op), root_1);

				DebugLocation(230, 25);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(230, 30);
				adaptor.AddChild(root_1, stream_selectedPropertiesList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 17);
			LeaveRule("newExpression", 17);
			LeaveRule_newExpression();
	    }
	 	DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_selectObject() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_selectObject() {}
	// $ANTLR start "selectObject"
	// Hql.g:233:1: selectObject : OBJECT ^ OPEN ! identifier CLOSE !;
	[GrammarRule("selectObject")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectObject()
	{
		EnterRule_selectObject();
		EnterRule("selectObject", 18);
		TraceIn("selectObject", 18);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken OBJECT54 = default(IToken);
	    IToken OPEN55 = default(IToken);
	    IToken CLOSE57 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier56 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode OBJECT54_tree = default(IASTNode);
	    IASTNode OPEN55_tree = default(IASTNode);
	    IASTNode CLOSE57_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "selectObject");
		DebugLocation(233, 3);
		try
		{
			// Hql.g:234:4: ( OBJECT ^ OPEN ! identifier CLOSE !)
			DebugEnterAlt(1);
			// Hql.g:234:6: OBJECT ^ OPEN ! identifier CLOSE !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(234, 12);
			OBJECT54=(IToken)Match(input,OBJECT,Follow._OBJECT_in_selectObject1107); 
			OBJECT54_tree = (IASTNode)adaptor.Create(OBJECT54);
			root_0 = (IASTNode)adaptor.BecomeRoot(OBJECT54_tree, root_0);

			DebugLocation(234, 18);
			OPEN55=(IToken)Match(input,OPEN,Follow._OPEN_in_selectObject1110); 
			DebugLocation(234, 20);
			PushFollow(Follow._identifier_in_selectObject1113);
			identifier56=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier56.Tree);
			DebugLocation(234, 36);
			CLOSE57=(IToken)Match(input,CLOSE,Follow._CLOSE_in_selectObject1115); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectObject", 18);
			LeaveRule("selectObject", 18);
			LeaveRule_selectObject();
	    }
	 	DebugLocation(235, 3);
		} finally { DebugExitRule(GrammarFileName, "selectObject"); }
		return retval;

	}
	// $ANTLR end "selectObject"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_fromClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_fromClause() {}
	// $ANTLR start "fromClause"
	// Hql.g:241:1: fromClause : FROM ^ fromRange ( fromJoin | COMMA ! fromRange )* ;
	[GrammarRule("fromClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromClause()
	{
		EnterRule_fromClause();
		EnterRule("fromClause", 19);
		TraceIn("fromClause", 19);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken FROM58 = default(IToken);
	    IToken COMMA61 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> fromRange59 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> fromJoin60 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> fromRange62 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode FROM58_tree = default(IASTNode);
	    IASTNode COMMA61_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "fromClause");
		DebugLocation(241, 1);
		try
		{
			// Hql.g:242:2: ( FROM ^ fromRange ( fromJoin | COMMA ! fromRange )* )
			DebugEnterAlt(1);
			// Hql.g:242:4: FROM ^ fromRange ( fromJoin | COMMA ! fromRange )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(242, 8);
			FROM58=(IToken)Match(input,FROM,Follow._FROM_in_fromClause1133); 
			FROM58_tree = (IASTNode)adaptor.Create(FROM58);
			root_0 = (IASTNode)adaptor.BecomeRoot(FROM58_tree, root_0);

			DebugLocation(242, 10);
			 WeakKeywords(); 
			DebugLocation(242, 30);
			PushFollow(Follow._fromRange_in_fromClause1138);
			fromRange59=fromRange();
			PopFollow();

			adaptor.AddChild(root_0, fromRange59.Tree);
			DebugLocation(242, 40);
			// Hql.g:242:40: ( fromJoin | COMMA ! fromRange )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=3;
				try { DebugEnterDecision(19, decisionCanBacktrack[19]);
				int LA19_1 = input.LA(1);

				if ((LA19_1==FULL||LA19_1==INNER||LA19_1==JOIN||LA19_1==LEFT||LA19_1==RIGHT))
				{
					alt19 = 1;
				}
				else if ((LA19_1==COMMA))
				{
					alt19 = 2;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:242:42: fromJoin
					{
					DebugLocation(242, 42);
					PushFollow(Follow._fromJoin_in_fromClause1142);
					fromJoin60=fromJoin();
					PopFollow();

					adaptor.AddChild(root_0, fromJoin60.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:242:53: COMMA ! fromRange
					{
					DebugLocation(242, 58);
					COMMA61=(IToken)Match(input,COMMA,Follow._COMMA_in_fromClause1146); 
					DebugLocation(242, 60);
					 WeakKeywords(); 
					DebugLocation(242, 80);
					PushFollow(Follow._fromRange_in_fromClause1151);
					fromRange62=fromRange();
					PopFollow();

					adaptor.AddChild(root_0, fromRange62.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromClause", 19);
			LeaveRule("fromClause", 19);
			LeaveRule_fromClause();
	    }
	 	DebugLocation(243, 1);
		} finally { DebugExitRule(GrammarFileName, "fromClause"); }
		return retval;

	}
	// $ANTLR end "fromClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_fromJoin() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_fromJoin() {}
	// $ANTLR start "fromJoin"
	// Hql.g:245:1: fromJoin : ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )? );
	[GrammarRule("fromJoin")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromJoin()
	{
		EnterRule_fromJoin();
		EnterRule("fromJoin", 20);
		TraceIn("fromJoin", 20);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken set63 = default(IToken);
	    IToken OUTER64 = default(IToken);
	    IToken FULL65 = default(IToken);
	    IToken INNER66 = default(IToken);
	    IToken JOIN67 = default(IToken);
	    IToken FETCH68 = default(IToken);
	    IToken set73 = default(IToken);
	    IToken OUTER74 = default(IToken);
	    IToken FULL75 = default(IToken);
	    IToken INNER76 = default(IToken);
	    IToken JOIN77 = default(IToken);
	    IToken FETCH78 = default(IToken);
	    IToken ELEMENTS79 = default(IToken);
	    IToken OPEN80 = default(IToken);
	    IToken CLOSE82 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> path69 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> asAlias70 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> propertyFetch71 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> withClause72 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> path81 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> asAlias83 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> propertyFetch84 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> withClause85 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode set63_tree = default(IASTNode);
	    IASTNode OUTER64_tree = default(IASTNode);
	    IASTNode FULL65_tree = default(IASTNode);
	    IASTNode INNER66_tree = default(IASTNode);
	    IASTNode JOIN67_tree = default(IASTNode);
	    IASTNode FETCH68_tree = default(IASTNode);
	    IASTNode set73_tree = default(IASTNode);
	    IASTNode OUTER74_tree = default(IASTNode);
	    IASTNode FULL75_tree = default(IASTNode);
	    IASTNode INNER76_tree = default(IASTNode);
	    IASTNode JOIN77_tree = default(IASTNode);
	    IASTNode FETCH78_tree = default(IASTNode);
	    IASTNode ELEMENTS79_tree = default(IASTNode);
	    IASTNode OPEN80_tree = default(IASTNode);
	    IASTNode CLOSE82_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "fromJoin");
		DebugLocation(245, 1);
		try
		{
			// Hql.g:246:2: ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )? )
			int alt32=2;
			try { DebugEnterDecision(32, decisionCanBacktrack[32]);
			switch (input.LA(1))
			{
			case LEFT:
			case RIGHT:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==OUTER))
				{
					int LA32_3 = input.LA(3);

					if ((LA32_3==JOIN))
					{
						switch (input.LA(4))
						{
						case FETCH:
							{
							int LA32_5 = input.LA(5);

							if ((LA32_5==IDENT))
							{
								alt32 = 1;
							}
							else if ((LA32_5==ELEMENTS))
							{
								alt32 = 2;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case IDENT:
							{
							alt32 = 1;
							}
							break;
						case ELEMENTS:
							{
							alt32 = 2;
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA32_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA32_4 = input.LA(4);

						if ((LA32_4==IDENT))
						{
							alt32 = 1;
						}
						else if ((LA32_4==ELEMENTS))
						{
							alt32 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt32 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt32 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FULL:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA32_4 = input.LA(4);

						if ((LA32_4==IDENT))
						{
							alt32 = 1;
						}
						else if ((LA32_4==ELEMENTS))
						{
							alt32 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt32 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt32 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INNER:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA32_4 = input.LA(4);

						if ((LA32_4==IDENT))
						{
							alt32 = 1;
						}
						else if ((LA32_4==ELEMENTS))
						{
							alt32 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt32 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt32 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case JOIN:
				{
				switch (input.LA(2))
				{
				case FETCH:
					{
					int LA32_3 = input.LA(3);

					if ((LA32_3==IDENT))
					{
						alt32 = 1;
					}
					else if ((LA32_3==ELEMENTS))
					{
						alt32 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case IDENT:
					{
					alt32 = 1;
					}
					break;
				case ELEMENTS:
					{
					alt32 = 2;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:246:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(246, 4);
				// Hql.g:246:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?
				int alt21=4;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, decisionCanBacktrack[21]);
				switch (input.LA(1))
				{
				case LEFT:
				case RIGHT:
					{
					alt21 = 1;
					}
					break;
				case FULL:
					{
					alt21 = 2;
					}
					break;
				case INNER:
					{
					alt21 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					{
					DebugLocation(246, 6);
					// Hql.g:246:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					DebugEnterAlt(1);
					// Hql.g:246:8: ( LEFT | RIGHT ) ( OUTER )?
					{
					DebugLocation(246, 8);

					set63=(IToken)input.LT(1);
					if (input.LA(1)==LEFT||input.LA(1)==RIGHT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set63));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(246, 25);
					// Hql.g:246:25: ( OUTER )?
					int alt20=2;
					try { DebugEnterSubRule(20);
					try { DebugEnterDecision(20, decisionCanBacktrack[20]);
					int LA20_1 = input.LA(1);

					if ((LA20_1==OUTER))
					{
						alt20 = 1;
					}
					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:246:26: OUTER
						{
						DebugLocation(246, 26);
						OUTER64=(IToken)Match(input,OUTER,Follow._OUTER_in_fromJoin1180); 
						OUTER64_tree = (IASTNode)adaptor.Create(OUTER64);
						adaptor.AddChild(root_0, OUTER64_tree);


						}
						break;

					}
					} finally { DebugExitSubRule(20); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:246:38: FULL
					{
					DebugLocation(246, 38);
					FULL65=(IToken)Match(input,FULL,Follow._FULL_in_fromJoin1188); 
					FULL65_tree = (IASTNode)adaptor.Create(FULL65);
					adaptor.AddChild(root_0, FULL65_tree);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:246:45: INNER
					{
					DebugLocation(246, 45);
					INNER66=(IToken)Match(input,INNER,Follow._INNER_in_fromJoin1192); 
					INNER66_tree = (IASTNode)adaptor.Create(INNER66);
					adaptor.AddChild(root_0, INNER66_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(21); }

				DebugLocation(246, 58);
				JOIN67=(IToken)Match(input,JOIN,Follow._JOIN_in_fromJoin1197); 
				JOIN67_tree = (IASTNode)adaptor.Create(JOIN67);
				root_0 = (IASTNode)adaptor.BecomeRoot(JOIN67_tree, root_0);

				DebugLocation(246, 60);
				// Hql.g:246:60: ( FETCH )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, decisionCanBacktrack[22]);
				int LA22_1 = input.LA(1);

				if ((LA22_1==FETCH))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:61: FETCH
					{
					DebugLocation(246, 61);
					FETCH68=(IToken)Match(input,FETCH,Follow._FETCH_in_fromJoin1201); 
					FETCH68_tree = (IASTNode)adaptor.Create(FETCH68);
					adaptor.AddChild(root_0, FETCH68_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(246, 69);
				PushFollow(Follow._path_in_fromJoin1205);
				path69=path();
				PopFollow();

				adaptor.AddChild(root_0, path69.Tree);
				DebugLocation(246, 74);
				// Hql.g:246:74: ( asAlias )?
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, decisionCanBacktrack[23]);
				int LA23_1 = input.LA(1);

				if ((LA23_1==AS||LA23_1==IDENT))
				{
					alt23 = 1;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:75: asAlias
					{
					DebugLocation(246, 75);
					PushFollow(Follow._asAlias_in_fromJoin1208);
					asAlias70=asAlias();
					PopFollow();

					adaptor.AddChild(root_0, asAlias70.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(246, 85);
				// Hql.g:246:85: ( propertyFetch )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, decisionCanBacktrack[24]);
				int LA24_1 = input.LA(1);

				if ((LA24_1==FETCH))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:86: propertyFetch
					{
					DebugLocation(246, 86);
					PushFollow(Follow._propertyFetch_in_fromJoin1213);
					propertyFetch71=propertyFetch();
					PopFollow();

					adaptor.AddChild(root_0, propertyFetch71.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(246, 102);
				// Hql.g:246:102: ( withClause )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, decisionCanBacktrack[25]);
				int LA25_1 = input.LA(1);

				if ((LA25_1==WITH))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:103: withClause
					{
					DebugLocation(246, 103);
					PushFollow(Follow._withClause_in_fromJoin1218);
					withClause72=withClause();
					PopFollow();

					adaptor.AddChild(root_0, withClause72.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(25); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:247:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(247, 4);
				// Hql.g:247:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?
				int alt27=4;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, decisionCanBacktrack[27]);
				switch (input.LA(1))
				{
				case LEFT:
				case RIGHT:
					{
					alt27 = 1;
					}
					break;
				case FULL:
					{
					alt27 = 2;
					}
					break;
				case INNER:
					{
					alt27 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					{
					DebugLocation(247, 6);
					// Hql.g:247:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					DebugEnterAlt(1);
					// Hql.g:247:8: ( LEFT | RIGHT ) ( OUTER )?
					{
					DebugLocation(247, 8);

					set73=(IToken)input.LT(1);
					if (input.LA(1)==LEFT||input.LA(1)==RIGHT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set73));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(247, 25);
					// Hql.g:247:25: ( OUTER )?
					int alt26=2;
					try { DebugEnterSubRule(26);
					try { DebugEnterDecision(26, decisionCanBacktrack[26]);
					int LA26_1 = input.LA(1);

					if ((LA26_1==OUTER))
					{
						alt26 = 1;
					}
					} finally { DebugExitDecision(26); }
					switch (alt26)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:247:26: OUTER
						{
						DebugLocation(247, 26);
						OUTER74=(IToken)Match(input,OUTER,Follow._OUTER_in_fromJoin1240); 
						OUTER74_tree = (IASTNode)adaptor.Create(OUTER74);
						adaptor.AddChild(root_0, OUTER74_tree);


						}
						break;

					}
					} finally { DebugExitSubRule(26); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:247:38: FULL
					{
					DebugLocation(247, 38);
					FULL75=(IToken)Match(input,FULL,Follow._FULL_in_fromJoin1248); 
					FULL75_tree = (IASTNode)adaptor.Create(FULL75);
					adaptor.AddChild(root_0, FULL75_tree);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:247:45: INNER
					{
					DebugLocation(247, 45);
					INNER76=(IToken)Match(input,INNER,Follow._INNER_in_fromJoin1252); 
					INNER76_tree = (IASTNode)adaptor.Create(INNER76);
					adaptor.AddChild(root_0, INNER76_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(27); }

				DebugLocation(247, 58);
				JOIN77=(IToken)Match(input,JOIN,Follow._JOIN_in_fromJoin1257); 
				JOIN77_tree = (IASTNode)adaptor.Create(JOIN77);
				root_0 = (IASTNode)adaptor.BecomeRoot(JOIN77_tree, root_0);

				DebugLocation(247, 60);
				// Hql.g:247:60: ( FETCH )?
				int alt28=2;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, decisionCanBacktrack[28]);
				int LA28_1 = input.LA(1);

				if ((LA28_1==FETCH))
				{
					alt28 = 1;
				}
				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:61: FETCH
					{
					DebugLocation(247, 61);
					FETCH78=(IToken)Match(input,FETCH,Follow._FETCH_in_fromJoin1261); 
					FETCH78_tree = (IASTNode)adaptor.Create(FETCH78);
					adaptor.AddChild(root_0, FETCH78_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(28); }

				DebugLocation(247, 77);
				ELEMENTS79=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_fromJoin1265); 
				DebugLocation(247, 83);
				OPEN80=(IToken)Match(input,OPEN,Follow._OPEN_in_fromJoin1268); 
				DebugLocation(247, 85);
				PushFollow(Follow._path_in_fromJoin1271);
				path81=path();
				PopFollow();

				adaptor.AddChild(root_0, path81.Tree);
				DebugLocation(247, 95);
				CLOSE82=(IToken)Match(input,CLOSE,Follow._CLOSE_in_fromJoin1273); 
				DebugLocation(247, 97);
				// Hql.g:247:97: ( asAlias )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, decisionCanBacktrack[29]);
				int LA29_1 = input.LA(1);

				if ((LA29_1==AS||LA29_1==IDENT))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:98: asAlias
					{
					DebugLocation(247, 98);
					PushFollow(Follow._asAlias_in_fromJoin1277);
					asAlias83=asAlias();
					PopFollow();

					adaptor.AddChild(root_0, asAlias83.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(29); }

				DebugLocation(247, 108);
				// Hql.g:247:108: ( propertyFetch )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, decisionCanBacktrack[30]);
				int LA30_1 = input.LA(1);

				if ((LA30_1==FETCH))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:109: propertyFetch
					{
					DebugLocation(247, 109);
					PushFollow(Follow._propertyFetch_in_fromJoin1282);
					propertyFetch84=propertyFetch();
					PopFollow();

					adaptor.AddChild(root_0, propertyFetch84.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(30); }

				DebugLocation(247, 125);
				// Hql.g:247:125: ( withClause )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, decisionCanBacktrack[31]);
				int LA31_1 = input.LA(1);

				if ((LA31_1==WITH))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:126: withClause
					{
					DebugLocation(247, 126);
					PushFollow(Follow._withClause_in_fromJoin1287);
					withClause85=withClause();
					PopFollow();

					adaptor.AddChild(root_0, withClause85.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(31); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromJoin", 20);
			LeaveRule("fromJoin", 20);
			LeaveRule_fromJoin();
	    }
	 	DebugLocation(248, 1);
		} finally { DebugExitRule(GrammarFileName, "fromJoin"); }
		return retval;

	}
	// $ANTLR end "fromJoin"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_withClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_withClause() {}
	// $ANTLR start "withClause"
	// Hql.g:250:1: withClause : WITH ^ logicalExpression ;
	[GrammarRule("withClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> withClause()
	{
		EnterRule_withClause();
		EnterRule("withClause", 21);
		TraceIn("withClause", 21);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken WITH86 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> logicalExpression87 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode WITH86_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "withClause");
		DebugLocation(250, 1);
		try
		{
			// Hql.g:251:2: ( WITH ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:251:4: WITH ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(251, 8);
			WITH86=(IToken)Match(input,WITH,Follow._WITH_in_withClause1300); 
			WITH86_tree = (IASTNode)adaptor.Create(WITH86);
			root_0 = (IASTNode)adaptor.BecomeRoot(WITH86_tree, root_0);

			DebugLocation(251, 10);
			PushFollow(Follow._logicalExpression_in_withClause1303);
			logicalExpression87=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression87.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withClause", 21);
			LeaveRule("withClause", 21);
			LeaveRule_withClause();
	    }
	 	DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "withClause"); }
		return retval;

	}
	// $ANTLR end "withClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_fromRange() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_fromRange() {}
	// $ANTLR start "fromRange"
	// Hql.g:254:1: fromRange : ( fromClassOrOuterQueryPath | inClassDeclaration | inCollectionDeclaration | inCollectionElementsDeclaration );
	[GrammarRule("fromRange")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromRange()
	{
		EnterRule_fromRange();
		EnterRule("fromRange", 22);
		TraceIn("fromRange", 22);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> fromClassOrOuterQueryPath88 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> inClassDeclaration89 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> inCollectionDeclaration90 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> inCollectionElementsDeclaration91 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "fromRange");
		DebugLocation(254, 1);
		try
		{
			// Hql.g:255:2: ( fromClassOrOuterQueryPath | inClassDeclaration | inCollectionDeclaration | inCollectionElementsDeclaration )
			int alt33=4;
			try { DebugEnterDecision(33, decisionCanBacktrack[33]);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA33_2 = input.LA(2);

				if ((LA33_2==EOF||LA33_2==AS||LA33_2==CLOSE||LA33_2==COMMA||LA33_2==DOT||LA33_2==FETCH||LA33_2==FULL||LA33_2==GROUP||LA33_2==HAVING||LA33_2==IDENT||LA33_2==INNER||LA33_2==JOIN||LA33_2==LEFT||LA33_2==ORDER||LA33_2==RIGHT||LA33_2==SKIP||LA33_2==TAKE||LA33_2==UNION||LA33_2==WHERE))
				{
					alt33 = 1;
				}
				else if ((LA33_2==IN))
				{
					int LA33_3 = input.LA(3);

					if ((LA33_3==ELEMENTS))
					{
						alt33 = 4;
					}
					else if ((LA33_3==CLASS||LA33_3==IDENT))
					{
						alt33 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 33, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IN:
				{
				alt33 = 3;
				}
				break;
			case ELEMENTS:
				{
				alt33 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:255:4: fromClassOrOuterQueryPath
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(255, 4);
				PushFollow(Follow._fromClassOrOuterQueryPath_in_fromRange1314);
				fromClassOrOuterQueryPath88=fromClassOrOuterQueryPath();
				PopFollow();

				adaptor.AddChild(root_0, fromClassOrOuterQueryPath88.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:256:4: inClassDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(256, 4);
				PushFollow(Follow._inClassDeclaration_in_fromRange1319);
				inClassDeclaration89=inClassDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inClassDeclaration89.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:257:4: inCollectionDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(257, 4);
				PushFollow(Follow._inCollectionDeclaration_in_fromRange1324);
				inCollectionDeclaration90=inCollectionDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inCollectionDeclaration90.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:258:4: inCollectionElementsDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(258, 4);
				PushFollow(Follow._inCollectionElementsDeclaration_in_fromRange1329);
				inCollectionElementsDeclaration91=inCollectionElementsDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inCollectionElementsDeclaration91.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromRange", 22);
			LeaveRule("fromRange", 22);
			LeaveRule_fromRange();
	    }
	 	DebugLocation(259, 1);
		} finally { DebugExitRule(GrammarFileName, "fromRange"); }
		return retval;

	}
	// $ANTLR end "fromRange"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_fromClassOrOuterQueryPath() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_fromClassOrOuterQueryPath() {}
	// $ANTLR start "fromClassOrOuterQueryPath"
	// Hql.g:261:1: fromClassOrOuterQueryPath : path ( asAlias )? ( propertyFetch )? -> ^( RANGE path ( asAlias )? ( propertyFetch )? ) ;
	[GrammarRule("fromClassOrOuterQueryPath")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromClassOrOuterQueryPath()
	{
		EnterRule_fromClassOrOuterQueryPath();
		EnterRule("fromClassOrOuterQueryPath", 23);
		TraceIn("fromClassOrOuterQueryPath", 23);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> path92 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> asAlias93 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> propertyFetch94 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
	    RewriteRuleSubtreeStream stream_asAlias=new RewriteRuleSubtreeStream(adaptor,"rule asAlias");
	    RewriteRuleSubtreeStream stream_propertyFetch=new RewriteRuleSubtreeStream(adaptor,"rule propertyFetch");
		try { DebugEnterRule(GrammarFileName, "fromClassOrOuterQueryPath");
		DebugLocation(261, 1);
		try
		{
			// Hql.g:262:2: ( path ( asAlias )? ( propertyFetch )? -> ^( RANGE path ( asAlias )? ( propertyFetch )? ) )
			DebugEnterAlt(1);
			// Hql.g:262:4: path ( asAlias )? ( propertyFetch )?
			{
			DebugLocation(262, 4);
			PushFollow(Follow._path_in_fromClassOrOuterQueryPath1341);
			path92=path();
			PopFollow();

			stream_path.Add(path92.Tree);
			DebugLocation(262, 9);
			 WeakKeywords(); 
			DebugLocation(262, 29);
			// Hql.g:262:29: ( asAlias )?
			int alt34=2;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, decisionCanBacktrack[34]);
			int LA34_1 = input.LA(1);

			if ((LA34_1==AS||LA34_1==IDENT))
			{
				alt34 = 1;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:262:30: asAlias
				{
				DebugLocation(262, 30);
				PushFollow(Follow._asAlias_in_fromClassOrOuterQueryPath1346);
				asAlias93=asAlias();
				PopFollow();

				stream_asAlias.Add(asAlias93.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(34); }

			DebugLocation(262, 40);
			// Hql.g:262:40: ( propertyFetch )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, decisionCanBacktrack[35]);
			int LA35_1 = input.LA(1);

			if ((LA35_1==FETCH))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:262:41: propertyFetch
				{
				DebugLocation(262, 41);
				PushFollow(Follow._propertyFetch_in_fromClassOrOuterQueryPath1351);
				propertyFetch94=propertyFetch();
				PopFollow();

				stream_propertyFetch.Add(propertyFetch94.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: path, asAlias, propertyFetch
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 263:3: -> ^( RANGE path ( asAlias )? ( propertyFetch )? )
			{
				DebugLocation(263, 6);
				// Hql.g:263:6: ^( RANGE path ( asAlias )? ( propertyFetch )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(263, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_1);

				DebugLocation(263, 14);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(263, 19);
				// Hql.g:263:19: ( asAlias )?
				if (stream_asAlias.HasNext)
				{
					DebugLocation(263, 19);
					adaptor.AddChild(root_1, stream_asAlias.NextTree());

				}
				stream_asAlias.Reset();
				DebugLocation(263, 28);
				// Hql.g:263:28: ( propertyFetch )?
				if (stream_propertyFetch.HasNext)
				{
					DebugLocation(263, 28);
					adaptor.AddChild(root_1, stream_propertyFetch.NextTree());

				}
				stream_propertyFetch.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromClassOrOuterQueryPath", 23);
			LeaveRule("fromClassOrOuterQueryPath", 23);
			LeaveRule_fromClassOrOuterQueryPath();
	    }
	 	DebugLocation(264, 1);
		} finally { DebugExitRule(GrammarFileName, "fromClassOrOuterQueryPath"); }
		return retval;

	}
	// $ANTLR end "fromClassOrOuterQueryPath"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_inClassDeclaration() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_inClassDeclaration() {}
	// $ANTLR start "inClassDeclaration"
	// Hql.g:266:1: inClassDeclaration : alias IN ( CLASS )? path -> ^( RANGE path alias ) ;
	[GrammarRule("inClassDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inClassDeclaration()
	{
		EnterRule_inClassDeclaration();
		EnterRule("inClassDeclaration", 24);
		TraceIn("inClassDeclaration", 24);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken IN96 = default(IToken);
	    IToken CLASS97 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> alias95 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> path98 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode IN96_tree = default(IASTNode);
	    IASTNode CLASS97_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
	    RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
	    RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
	    RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		try { DebugEnterRule(GrammarFileName, "inClassDeclaration");
		DebugLocation(266, 1);
		try
		{
			// Hql.g:267:2: ( alias IN ( CLASS )? path -> ^( RANGE path alias ) )
			DebugEnterAlt(1);
			// Hql.g:267:4: alias IN ( CLASS )? path
			{
			DebugLocation(267, 4);
			PushFollow(Follow._alias_in_inClassDeclaration1381);
			alias95=alias();
			PopFollow();

			stream_alias.Add(alias95.Tree);
			DebugLocation(267, 10);
			IN96=(IToken)Match(input,IN,Follow._IN_in_inClassDeclaration1383);  
			stream_IN.Add(IN96);

			DebugLocation(267, 13);
			// Hql.g:267:13: ( CLASS )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, decisionCanBacktrack[36]);
			int LA36_1 = input.LA(1);

			if ((LA36_1==CLASS))
			{
				alt36 = 1;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:267:13: CLASS
				{
				DebugLocation(267, 13);
				CLASS97=(IToken)Match(input,CLASS,Follow._CLASS_in_inClassDeclaration1385);  
				stream_CLASS.Add(CLASS97);


				}
				break;

			}
			} finally { DebugExitSubRule(36); }

			DebugLocation(267, 20);
			PushFollow(Follow._path_in_inClassDeclaration1388);
			path98=path();
			PopFollow();

			stream_path.Add(path98.Tree);


			{
			// AST REWRITE
			// elements: path, alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 268:3: -> ^( RANGE path alias )
			{
				DebugLocation(268, 6);
				// Hql.g:268:6: ^( RANGE path alias )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(268, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_1);

				DebugLocation(268, 14);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(268, 19);
				adaptor.AddChild(root_1, stream_alias.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inClassDeclaration", 24);
			LeaveRule("inClassDeclaration", 24);
			LeaveRule_inClassDeclaration();
	    }
	 	DebugLocation(269, 1);
		} finally { DebugExitRule(GrammarFileName, "inClassDeclaration"); }
		return retval;

	}
	// $ANTLR end "inClassDeclaration"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_inCollectionDeclaration() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_inCollectionDeclaration() {}
	// $ANTLR start "inCollectionDeclaration"
	// Hql.g:271:1: inCollectionDeclaration : IN OPEN path CLOSE alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) ;
	[GrammarRule("inCollectionDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inCollectionDeclaration()
	{
		EnterRule_inCollectionDeclaration();
		EnterRule("inCollectionDeclaration", 25);
		TraceIn("inCollectionDeclaration", 25);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken IN99 = default(IToken);
	    IToken OPEN100 = default(IToken);
	    IToken CLOSE102 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> path101 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> alias103 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode IN99_tree = default(IASTNode);
	    IASTNode OPEN100_tree = default(IASTNode);
	    IASTNode CLOSE102_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
	    RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
	    RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
	    RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
	    RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		try { DebugEnterRule(GrammarFileName, "inCollectionDeclaration");
		DebugLocation(271, 4);
		try
		{
			// Hql.g:272:5: ( IN OPEN path CLOSE alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) )
			DebugEnterAlt(1);
			// Hql.g:272:7: IN OPEN path CLOSE alias
			{
			DebugLocation(272, 7);
			IN99=(IToken)Match(input,IN,Follow._IN_in_inCollectionDeclaration1416);  
			stream_IN.Add(IN99);

			DebugLocation(272, 10);
			OPEN100=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionDeclaration1418);  
			stream_OPEN.Add(OPEN100);

			DebugLocation(272, 15);
			PushFollow(Follow._path_in_inCollectionDeclaration1420);
			path101=path();
			PopFollow();

			stream_path.Add(path101.Tree);
			DebugLocation(272, 20);
			CLOSE102=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionDeclaration1422);  
			stream_CLOSE.Add(CLOSE102);

			DebugLocation(272, 26);
			PushFollow(Follow._alias_in_inCollectionDeclaration1424);
			alias103=alias();
			PopFollow();

			stream_alias.Add(alias103.Tree);


			{
			// AST REWRITE
			// elements: path, alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 273:6: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
			{
				DebugLocation(273, 9);
				// Hql.g:273:9: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(273, 11);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

				DebugLocation(273, 24);
				adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
				DebugLocation(273, 39);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(273, 44);
				adaptor.AddChild(root_1, stream_alias.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inCollectionDeclaration", 25);
			LeaveRule("inCollectionDeclaration", 25);
			LeaveRule_inCollectionDeclaration();
	    }
	 	DebugLocation(274, 4);
		} finally { DebugExitRule(GrammarFileName, "inCollectionDeclaration"); }
		return retval;

	}
	// $ANTLR end "inCollectionDeclaration"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_inCollectionElementsDeclaration() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_inCollectionElementsDeclaration() {}
	// $ANTLR start "inCollectionElementsDeclaration"
	// Hql.g:276:1: inCollectionElementsDeclaration : ( alias IN ELEMENTS OPEN path CLOSE -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) | ELEMENTS OPEN path CLOSE AS alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) );
	[GrammarRule("inCollectionElementsDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inCollectionElementsDeclaration()
	{
		EnterRule_inCollectionElementsDeclaration();
		EnterRule("inCollectionElementsDeclaration", 26);
		TraceIn("inCollectionElementsDeclaration", 26);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken IN105 = default(IToken);
	    IToken ELEMENTS106 = default(IToken);
	    IToken OPEN107 = default(IToken);
	    IToken CLOSE109 = default(IToken);
	    IToken ELEMENTS110 = default(IToken);
	    IToken OPEN111 = default(IToken);
	    IToken CLOSE113 = default(IToken);
	    IToken AS114 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> alias104 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> path108 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> path112 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> alias115 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode IN105_tree = default(IASTNode);
	    IASTNode ELEMENTS106_tree = default(IASTNode);
	    IASTNode OPEN107_tree = default(IASTNode);
	    IASTNode CLOSE109_tree = default(IASTNode);
	    IASTNode ELEMENTS110_tree = default(IASTNode);
	    IASTNode OPEN111_tree = default(IASTNode);
	    IASTNode CLOSE113_tree = default(IASTNode);
	    IASTNode AS114_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
	    RewriteRuleITokenStream stream_ELEMENTS=new RewriteRuleITokenStream(adaptor,"token ELEMENTS");
	    RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
	    RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
	    RewriteRuleITokenStream stream_AS=new RewriteRuleITokenStream(adaptor,"token AS");
	    RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
	    RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		try { DebugEnterRule(GrammarFileName, "inCollectionElementsDeclaration");
		DebugLocation(276, 4);
		try
		{
			// Hql.g:277:2: ( alias IN ELEMENTS OPEN path CLOSE -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) | ELEMENTS OPEN path CLOSE AS alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) )
			int alt37=2;
			try { DebugEnterDecision(37, decisionCanBacktrack[37]);
			int LA37_1 = input.LA(1);

			if ((LA37_1==IDENT))
			{
				alt37 = 1;
			}
			else if ((LA37_1==ELEMENTS))
			{
				alt37 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 37, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:277:4: alias IN ELEMENTS OPEN path CLOSE
				{
				DebugLocation(277, 4);
				PushFollow(Follow._alias_in_inCollectionElementsDeclaration1458);
				alias104=alias();
				PopFollow();

				stream_alias.Add(alias104.Tree);
				DebugLocation(277, 10);
				IN105=(IToken)Match(input,IN,Follow._IN_in_inCollectionElementsDeclaration1460);  
				stream_IN.Add(IN105);

				DebugLocation(277, 13);
				ELEMENTS106=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_inCollectionElementsDeclaration1462);  
				stream_ELEMENTS.Add(ELEMENTS106);

				DebugLocation(277, 22);
				OPEN107=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionElementsDeclaration1464);  
				stream_OPEN.Add(OPEN107);

				DebugLocation(277, 27);
				PushFollow(Follow._path_in_inCollectionElementsDeclaration1466);
				path108=path();
				PopFollow();

				stream_path.Add(path108.Tree);
				DebugLocation(277, 32);
				CLOSE109=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionElementsDeclaration1468);  
				stream_CLOSE.Add(CLOSE109);



				{
				// AST REWRITE
				// elements: path, alias
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 278:3: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
					DebugLocation(278, 6);
					// Hql.g:278:6: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(278, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

					DebugLocation(278, 21);
					adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
					DebugLocation(278, 36);
					adaptor.AddChild(root_1, stream_path.NextTree());
					DebugLocation(278, 41);
					adaptor.AddChild(root_1, stream_alias.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:279:4: ELEMENTS OPEN path CLOSE AS alias
				{
				DebugLocation(279, 4);
				ELEMENTS110=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_inCollectionElementsDeclaration1490);  
				stream_ELEMENTS.Add(ELEMENTS110);

				DebugLocation(279, 13);
				OPEN111=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionElementsDeclaration1492);  
				stream_OPEN.Add(OPEN111);

				DebugLocation(279, 18);
				PushFollow(Follow._path_in_inCollectionElementsDeclaration1494);
				path112=path();
				PopFollow();

				stream_path.Add(path112.Tree);
				DebugLocation(279, 23);
				CLOSE113=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionElementsDeclaration1496);  
				stream_CLOSE.Add(CLOSE113);

				DebugLocation(279, 29);
				AS114=(IToken)Match(input,AS,Follow._AS_in_inCollectionElementsDeclaration1498);  
				stream_AS.Add(AS114);

				DebugLocation(279, 32);
				PushFollow(Follow._alias_in_inCollectionElementsDeclaration1500);
				alias115=alias();
				PopFollow();

				stream_alias.Add(alias115.Tree);


				{
				// AST REWRITE
				// elements: path, alias
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 280:3: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
					DebugLocation(280, 6);
					// Hql.g:280:6: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(280, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

					DebugLocation(280, 21);
					adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
					DebugLocation(280, 36);
					adaptor.AddChild(root_1, stream_path.NextTree());
					DebugLocation(280, 41);
					adaptor.AddChild(root_1, stream_alias.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inCollectionElementsDeclaration", 26);
			LeaveRule("inCollectionElementsDeclaration", 26);
			LeaveRule_inCollectionElementsDeclaration();
	    }
	 	DebugLocation(281, 4);
		} finally { DebugExitRule(GrammarFileName, "inCollectionElementsDeclaration"); }
		return retval;

	}
	// $ANTLR end "inCollectionElementsDeclaration"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_asAlias() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_asAlias() {}
	// $ANTLR start "asAlias"
	// Hql.g:284:1: asAlias : ( AS !)? alias ;
	[GrammarRule("asAlias")]
	private AstParserRuleReturnScope<IASTNode, IToken> asAlias()
	{
		EnterRule_asAlias();
		EnterRule("asAlias", 27);
		TraceIn("asAlias", 27);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken AS116 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> alias117 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode AS116_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "asAlias");
		DebugLocation(284, 1);
		try
		{
			// Hql.g:285:2: ( ( AS !)? alias )
			DebugEnterAlt(1);
			// Hql.g:285:4: ( AS !)? alias
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(285, 4);
			// Hql.g:285:4: ( AS !)?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, decisionCanBacktrack[38]);
			int LA38_1 = input.LA(1);

			if ((LA38_1==AS))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:285:5: AS !
				{
				DebugLocation(285, 7);
				AS116=(IToken)Match(input,AS,Follow._AS_in_asAlias1532); 

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(285, 11);
			PushFollow(Follow._alias_in_asAlias1537);
			alias117=alias();
			PopFollow();

			adaptor.AddChild(root_0, alias117.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("asAlias", 27);
			LeaveRule("asAlias", 27);
			LeaveRule_asAlias();
	    }
	 	DebugLocation(286, 1);
		} finally { DebugExitRule(GrammarFileName, "asAlias"); }
		return retval;

	}
	// $ANTLR end "asAlias"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_alias() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_alias() {}
	// $ANTLR start "alias"
	// Hql.g:287:1: alias : i= identifier -> ^( ALIAS[$i.start] ) ;
	[GrammarRule("alias")]
	private AstParserRuleReturnScope<IASTNode, IToken> alias()
	{
		EnterRule_alias();
		EnterRule("alias", 28);
		TraceIn("alias", 28);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> i = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "alias");
		DebugLocation(287, 1);
		try
		{
			// Hql.g:288:2: (i= identifier -> ^( ALIAS[$i.start] ) )
			DebugEnterAlt(1);
			// Hql.g:288:4: i= identifier
			{
			DebugLocation(288, 5);
			PushFollow(Follow._identifier_in_alias1549);
			i=identifier();
			PopFollow();

			stream_identifier.Add(i.Tree);


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 289:2: -> ^( ALIAS[$i.start] )
			{
				DebugLocation(289, 5);
				// Hql.g:289:5: ^( ALIAS[$i.start] )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(289, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ALIAS, (i!=null?((IToken)i.Start):default(IToken))), root_1);

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alias", 28);
			LeaveRule("alias", 28);
			LeaveRule_alias();
	    }
	 	DebugLocation(290, 1);
		} finally { DebugExitRule(GrammarFileName, "alias"); }
		return retval;

	}
	// $ANTLR end "alias"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_propertyFetch() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_propertyFetch() {}
	// $ANTLR start "propertyFetch"
	// Hql.g:292:1: propertyFetch : FETCH ALL ! PROPERTIES !;
	[GrammarRule("propertyFetch")]
	private AstParserRuleReturnScope<IASTNode, IToken> propertyFetch()
	{
		EnterRule_propertyFetch();
		EnterRule("propertyFetch", 29);
		TraceIn("propertyFetch", 29);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken FETCH118 = default(IToken);
	    IToken ALL119 = default(IToken);
	    IToken PROPERTIES120 = default(IToken);

	    IASTNode FETCH118_tree = default(IASTNode);
	    IASTNode ALL119_tree = default(IASTNode);
	    IASTNode PROPERTIES120_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "propertyFetch");
		DebugLocation(292, 1);
		try
		{
			// Hql.g:293:2: ( FETCH ALL ! PROPERTIES !)
			DebugEnterAlt(1);
			// Hql.g:293:4: FETCH ALL ! PROPERTIES !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(293, 4);
			FETCH118=(IToken)Match(input,FETCH,Follow._FETCH_in_propertyFetch1568); 
			FETCH118_tree = (IASTNode)adaptor.Create(FETCH118);
			adaptor.AddChild(root_0, FETCH118_tree);

			DebugLocation(293, 13);
			ALL119=(IToken)Match(input,ALL,Follow._ALL_in_propertyFetch1570); 
			DebugLocation(293, 25);
			PROPERTIES120=(IToken)Match(input,PROPERTIES,Follow._PROPERTIES_in_propertyFetch1573); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyFetch", 29);
			LeaveRule("propertyFetch", 29);
			LeaveRule_propertyFetch();
	    }
	 	DebugLocation(294, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyFetch"); }
		return retval;

	}
	// $ANTLR end "propertyFetch"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_groupByClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_groupByClause() {}
	// $ANTLR start "groupByClause"
	// Hql.g:296:1: groupByClause : GROUP ^ 'by' ! expression ( COMMA ! expression )* ;
	[GrammarRule("groupByClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> groupByClause()
	{
		EnterRule_groupByClause();
		EnterRule("groupByClause", 30);
		TraceIn("groupByClause", 30);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken GROUP121 = default(IToken);
	    IToken string_literal122 = default(IToken);
	    IToken COMMA124 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> expression123 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression125 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode GROUP121_tree = default(IASTNode);
	    IASTNode string_literal122_tree = default(IASTNode);
	    IASTNode COMMA124_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "groupByClause");
		DebugLocation(296, 1);
		try
		{
			// Hql.g:297:2: ( GROUP ^ 'by' ! expression ( COMMA ! expression )* )
			DebugEnterAlt(1);
			// Hql.g:297:4: GROUP ^ 'by' ! expression ( COMMA ! expression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(297, 9);
			GROUP121=(IToken)Match(input,GROUP,Follow._GROUP_in_groupByClause1585); 
			GROUP121_tree = (IASTNode)adaptor.Create(GROUP121);
			root_0 = (IASTNode)adaptor.BecomeRoot(GROUP121_tree, root_0);

			DebugLocation(298, 7);
			string_literal122=(IToken)Match(input,LITERAL_by,Follow._LITERAL_by_in_groupByClause1591); 
			DebugLocation(298, 9);
			PushFollow(Follow._expression_in_groupByClause1594);
			expression123=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression123.Tree);
			DebugLocation(298, 20);
			// Hql.g:298:20: ( COMMA ! expression )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, decisionCanBacktrack[39]);
				int LA39_1 = input.LA(1);

				if ((LA39_1==COMMA))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:298:22: COMMA ! expression
					{
					DebugLocation(298, 27);
					COMMA124=(IToken)Match(input,COMMA,Follow._COMMA_in_groupByClause1598); 
					DebugLocation(298, 29);
					PushFollow(Follow._expression_in_groupByClause1601);
					expression125=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression125.Tree);

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("groupByClause", 30);
			LeaveRule("groupByClause", 30);
			LeaveRule_groupByClause();
	    }
	 	DebugLocation(299, 1);
		} finally { DebugExitRule(GrammarFileName, "groupByClause"); }
		return retval;

	}
	// $ANTLR end "groupByClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_orderByClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_orderByClause() {}
	// $ANTLR start "orderByClause"
	// Hql.g:301:1: orderByClause : ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )* ;
	[GrammarRule("orderByClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> orderByClause()
	{
		EnterRule_orderByClause();
		EnterRule("orderByClause", 31);
		TraceIn("orderByClause", 31);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken ORDER126 = default(IToken);
	    IToken string_literal127 = default(IToken);
	    IToken COMMA129 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> orderElement128 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> orderElement130 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode ORDER126_tree = default(IASTNode);
	    IASTNode string_literal127_tree = default(IASTNode);
	    IASTNode COMMA129_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "orderByClause");
		DebugLocation(301, 1);
		try
		{
			// Hql.g:302:2: ( ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )* )
			DebugEnterAlt(1);
			// Hql.g:302:4: ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(302, 9);
			ORDER126=(IToken)Match(input,ORDER,Follow._ORDER_in_orderByClause1615); 
			ORDER126_tree = (IASTNode)adaptor.Create(ORDER126);
			root_0 = (IASTNode)adaptor.BecomeRoot(ORDER126_tree, root_0);

			DebugLocation(302, 15);
			string_literal127=(IToken)Match(input,LITERAL_by,Follow._LITERAL_by_in_orderByClause1618); 
			DebugLocation(302, 17);
			PushFollow(Follow._orderElement_in_orderByClause1621);
			orderElement128=orderElement();
			PopFollow();

			adaptor.AddChild(root_0, orderElement128.Tree);
			DebugLocation(302, 30);
			// Hql.g:302:30: ( COMMA ! orderElement )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, decisionCanBacktrack[40]);
				int LA40_1 = input.LA(1);

				if ((LA40_1==COMMA))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:302:32: COMMA ! orderElement
					{
					DebugLocation(302, 37);
					COMMA129=(IToken)Match(input,COMMA,Follow._COMMA_in_orderByClause1625); 
					DebugLocation(302, 39);
					PushFollow(Follow._orderElement_in_orderByClause1628);
					orderElement130=orderElement();
					PopFollow();

					adaptor.AddChild(root_0, orderElement130.Tree);

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orderByClause", 31);
			LeaveRule("orderByClause", 31);
			LeaveRule_orderByClause();
	    }
	 	DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "orderByClause"); }
		return retval;

	}
	// $ANTLR end "orderByClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_skipClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_skipClause() {}
	// $ANTLR start "skipClause"
	// Hql.g:305:1: skipClause : SKIP ^ ( NUM_INT | parameter ) ;
	[GrammarRule("skipClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> skipClause()
	{
		EnterRule_skipClause();
		EnterRule("skipClause", 32);
		TraceIn("skipClause", 32);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken SKIP131 = default(IToken);
	    IToken NUM_INT132 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> parameter133 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode SKIP131_tree = default(IASTNode);
	    IASTNode NUM_INT132_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "skipClause");
		DebugLocation(305, 1);
		try
		{
			// Hql.g:306:2: ( SKIP ^ ( NUM_INT | parameter ) )
			DebugEnterAlt(1);
			// Hql.g:306:4: SKIP ^ ( NUM_INT | parameter )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(306, 8);
			SKIP131=(IToken)Match(input,SKIP,Follow._SKIP_in_skipClause1642); 
			SKIP131_tree = (IASTNode)adaptor.Create(SKIP131);
			root_0 = (IASTNode)adaptor.BecomeRoot(SKIP131_tree, root_0);

			DebugLocation(306, 10);
			// Hql.g:306:10: ( NUM_INT | parameter )
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, decisionCanBacktrack[41]);
			int LA41_1 = input.LA(1);

			if ((LA41_1==NUM_INT))
			{
				alt41 = 1;
			}
			else if ((LA41_1==COLON||LA41_1==PARAM))
			{
				alt41 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:306:11: NUM_INT
				{
				DebugLocation(306, 11);
				NUM_INT132=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_skipClause1646); 
				NUM_INT132_tree = (IASTNode)adaptor.Create(NUM_INT132);
				adaptor.AddChild(root_0, NUM_INT132_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:306:21: parameter
				{
				DebugLocation(306, 21);
				PushFollow(Follow._parameter_in_skipClause1650);
				parameter133=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter133.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(41); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("skipClause", 32);
			LeaveRule("skipClause", 32);
			LeaveRule_skipClause();
	    }
	 	DebugLocation(307, 1);
		} finally { DebugExitRule(GrammarFileName, "skipClause"); }
		return retval;

	}
	// $ANTLR end "skipClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_takeClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_takeClause() {}
	// $ANTLR start "takeClause"
	// Hql.g:309:1: takeClause : TAKE ^ ( NUM_INT | parameter ) ;
	[GrammarRule("takeClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> takeClause()
	{
		EnterRule_takeClause();
		EnterRule("takeClause", 33);
		TraceIn("takeClause", 33);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken TAKE134 = default(IToken);
	    IToken NUM_INT135 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> parameter136 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode TAKE134_tree = default(IASTNode);
	    IASTNode NUM_INT135_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "takeClause");
		DebugLocation(309, 1);
		try
		{
			// Hql.g:310:2: ( TAKE ^ ( NUM_INT | parameter ) )
			DebugEnterAlt(1);
			// Hql.g:310:4: TAKE ^ ( NUM_INT | parameter )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(310, 8);
			TAKE134=(IToken)Match(input,TAKE,Follow._TAKE_in_takeClause1662); 
			TAKE134_tree = (IASTNode)adaptor.Create(TAKE134);
			root_0 = (IASTNode)adaptor.BecomeRoot(TAKE134_tree, root_0);

			DebugLocation(310, 10);
			// Hql.g:310:10: ( NUM_INT | parameter )
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, decisionCanBacktrack[42]);
			int LA42_1 = input.LA(1);

			if ((LA42_1==NUM_INT))
			{
				alt42 = 1;
			}
			else if ((LA42_1==COLON||LA42_1==PARAM))
			{
				alt42 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:310:11: NUM_INT
				{
				DebugLocation(310, 11);
				NUM_INT135=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_takeClause1666); 
				NUM_INT135_tree = (IASTNode)adaptor.Create(NUM_INT135);
				adaptor.AddChild(root_0, NUM_INT135_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:310:21: parameter
				{
				DebugLocation(310, 21);
				PushFollow(Follow._parameter_in_takeClause1670);
				parameter136=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter136.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(42); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("takeClause", 33);
			LeaveRule("takeClause", 33);
			LeaveRule_takeClause();
	    }
	 	DebugLocation(311, 1);
		} finally { DebugExitRule(GrammarFileName, "takeClause"); }
		return retval;

	}
	// $ANTLR end "takeClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_parameter() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_parameter() {}
	// $ANTLR start "parameter"
	// Hql.g:313:1: parameter : ( COLON ^ identifier | PARAM ^ ( NUM_INT )? );
	[GrammarRule("parameter")]
	private AstParserRuleReturnScope<IASTNode, IToken> parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 34);
		TraceIn("parameter", 34);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken COLON137 = default(IToken);
	    IToken PARAM139 = default(IToken);
	    IToken NUM_INT140 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier138 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode COLON137_tree = default(IASTNode);
	    IASTNode PARAM139_tree = default(IASTNode);
	    IASTNode NUM_INT140_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(313, 1);
		try
		{
			// Hql.g:314:2: ( COLON ^ identifier | PARAM ^ ( NUM_INT )? )
			int alt44=2;
			try { DebugEnterDecision(44, decisionCanBacktrack[44]);
			int LA44_1 = input.LA(1);

			if ((LA44_1==COLON))
			{
				alt44 = 1;
			}
			else if ((LA44_1==PARAM))
			{
				alt44 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:314:4: COLON ^ identifier
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(314, 9);
				COLON137=(IToken)Match(input,COLON,Follow._COLON_in_parameter1682); 
				COLON137_tree = (IASTNode)adaptor.Create(COLON137);
				root_0 = (IASTNode)adaptor.BecomeRoot(COLON137_tree, root_0);

				DebugLocation(314, 11);
				PushFollow(Follow._identifier_in_parameter1685);
				identifier138=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier138.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:315:4: PARAM ^ ( NUM_INT )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(315, 9);
				PARAM139=(IToken)Match(input,PARAM,Follow._PARAM_in_parameter1690); 
				PARAM139_tree = (IASTNode)adaptor.Create(PARAM139);
				root_0 = (IASTNode)adaptor.BecomeRoot(PARAM139_tree, root_0);

				DebugLocation(315, 11);
				// Hql.g:315:11: ( NUM_INT )?
				int alt43=2;
				try { DebugEnterSubRule(43);
				try { DebugEnterDecision(43, decisionCanBacktrack[43]);
				int LA43_1 = input.LA(1);

				if ((LA43_1==NUM_INT))
				{
					alt43 = 1;
				}
				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:315:12: NUM_INT
					{
					DebugLocation(315, 12);
					NUM_INT140=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_parameter1694); 
					NUM_INT140_tree = (IASTNode)adaptor.Create(NUM_INT140);
					adaptor.AddChild(root_0, NUM_INT140_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(43); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter", 34);
			LeaveRule("parameter", 34);
			LeaveRule_parameter();
	    }
	 	DebugLocation(316, 1);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return retval;

	}
	// $ANTLR end "parameter"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_orderElement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_orderElement() {}
	// $ANTLR start "orderElement"
	// Hql.g:318:1: orderElement : expression ( ascendingOrDescending )? ;
	[GrammarRule("orderElement")]
	private AstParserRuleReturnScope<IASTNode, IToken> orderElement()
	{
		EnterRule_orderElement();
		EnterRule("orderElement", 35);
		TraceIn("orderElement", 35);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> expression141 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> ascendingOrDescending142 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "orderElement");
		DebugLocation(318, 1);
		try
		{
			// Hql.g:319:2: ( expression ( ascendingOrDescending )? )
			DebugEnterAlt(1);
			// Hql.g:319:4: expression ( ascendingOrDescending )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(319, 4);
			PushFollow(Follow._expression_in_orderElement1707);
			expression141=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression141.Tree);
			DebugLocation(319, 15);
			// Hql.g:319:15: ( ascendingOrDescending )?
			int alt45=2;
			try { DebugEnterSubRule(45);
			try { DebugEnterDecision(45, decisionCanBacktrack[45]);
			int LA45_1 = input.LA(1);

			if ((LA45_1==ASCENDING||LA45_1==DESCENDING||(LA45_1>=133 && LA45_1<=134)))
			{
				alt45 = 1;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:319:17: ascendingOrDescending
				{
				DebugLocation(319, 17);
				PushFollow(Follow._ascendingOrDescending_in_orderElement1711);
				ascendingOrDescending142=ascendingOrDescending();
				PopFollow();

				adaptor.AddChild(root_0, ascendingOrDescending142.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(45); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orderElement", 35);
			LeaveRule("orderElement", 35);
			LeaveRule_orderElement();
	    }
	 	DebugLocation(320, 1);
		} finally { DebugExitRule(GrammarFileName, "orderElement"); }
		return retval;

	}
	// $ANTLR end "orderElement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_ascendingOrDescending() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_ascendingOrDescending() {}
	// $ANTLR start "ascendingOrDescending"
	// Hql.g:322:1: ascendingOrDescending : ( (a= 'asc' |a= 'ascending' ) -> ^( ASCENDING[$a.Text] ) | (d= 'desc' |d= 'descending' ) -> ^( DESCENDING[$d.Text] ) );
	[GrammarRule("ascendingOrDescending")]
	private AstParserRuleReturnScope<IASTNode, IToken> ascendingOrDescending()
	{
		EnterRule_ascendingOrDescending();
		EnterRule("ascendingOrDescending", 36);
		TraceIn("ascendingOrDescending", 36);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken a = default(IToken);
	    IToken d = default(IToken);

	    IASTNode a_tree = default(IASTNode);
	    IASTNode d_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_ASCENDING=new RewriteRuleITokenStream(adaptor,"token ASCENDING");
	    RewriteRuleITokenStream stream_133=new RewriteRuleITokenStream(adaptor,"token 133");
	    RewriteRuleITokenStream stream_DESCENDING=new RewriteRuleITokenStream(adaptor,"token DESCENDING");
	    RewriteRuleITokenStream stream_134=new RewriteRuleITokenStream(adaptor,"token 134");

		try { DebugEnterRule(GrammarFileName, "ascendingOrDescending");
		DebugLocation(322, 1);
		try
		{
			// Hql.g:323:2: ( (a= 'asc' |a= 'ascending' ) -> ^( ASCENDING[$a.Text] ) | (d= 'desc' |d= 'descending' ) -> ^( DESCENDING[$d.Text] ) )
			int alt48=2;
			try { DebugEnterDecision(48, decisionCanBacktrack[48]);
			int LA48_1 = input.LA(1);

			if ((LA48_1==ASCENDING||LA48_1==133))
			{
				alt48 = 1;
			}
			else if ((LA48_1==DESCENDING||LA48_1==134))
			{
				alt48 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 48, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:323:4: (a= 'asc' |a= 'ascending' )
				{
				DebugLocation(323, 4);
				// Hql.g:323:4: (a= 'asc' |a= 'ascending' )
				int alt46=2;
				try { DebugEnterSubRule(46);
				try { DebugEnterDecision(46, decisionCanBacktrack[46]);
				int LA46_1 = input.LA(1);

				if ((LA46_1==ASCENDING))
				{
					alt46 = 1;
				}
				else if ((LA46_1==133))
				{
					alt46 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:323:6: a= 'asc'
					{
					DebugLocation(323, 7);
					a=(IToken)Match(input,ASCENDING,Follow._ASCENDING_in_ascendingOrDescending1729);  
					stream_ASCENDING.Add(a);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:323:16: a= 'ascending'
					{
					DebugLocation(323, 17);
					a=(IToken)Match(input,133,Follow._133_in_ascendingOrDescending1735);  
					stream_133.Add(a);


					}
					break;

				}
				} finally { DebugExitSubRule(46); }



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 324:3: -> ^( ASCENDING[$a.Text] )
				{
					DebugLocation(324, 6);
					// Hql.g:324:6: ^( ASCENDING[$a.Text] )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(324, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ASCENDING, a.Text), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:325:4: (d= 'desc' |d= 'descending' )
				{
				DebugLocation(325, 4);
				// Hql.g:325:4: (d= 'desc' |d= 'descending' )
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, decisionCanBacktrack[47]);
				int LA47_1 = input.LA(1);

				if ((LA47_1==DESCENDING))
				{
					alt47 = 1;
				}
				else if ((LA47_1==134))
				{
					alt47 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:325:6: d= 'desc'
					{
					DebugLocation(325, 7);
					d=(IToken)Match(input,DESCENDING,Follow._DESCENDING_in_ascendingOrDescending1755);  
					stream_DESCENDING.Add(d);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:325:17: d= 'descending'
					{
					DebugLocation(325, 18);
					d=(IToken)Match(input,134,Follow._134_in_ascendingOrDescending1761);  
					stream_134.Add(d);


					}
					break;

				}
				} finally { DebugExitSubRule(47); }



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 326:3: -> ^( DESCENDING[$d.Text] )
				{
					DebugLocation(326, 6);
					// Hql.g:326:6: ^( DESCENDING[$d.Text] )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(326, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(DESCENDING, d.Text), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ascendingOrDescending", 36);
			LeaveRule("ascendingOrDescending", 36);
			LeaveRule_ascendingOrDescending();
	    }
	 	DebugLocation(327, 1);
		} finally { DebugExitRule(GrammarFileName, "ascendingOrDescending"); }
		return retval;

	}
	// $ANTLR end "ascendingOrDescending"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_havingClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_havingClause() {}
	// $ANTLR start "havingClause"
	// Hql.g:329:1: havingClause : HAVING ^ logicalExpression ;
	[GrammarRule("havingClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> havingClause()
	{
		EnterRule_havingClause();
		EnterRule("havingClause", 37);
		TraceIn("havingClause", 37);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken HAVING143 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> logicalExpression144 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode HAVING143_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "havingClause");
		DebugLocation(329, 1);
		try
		{
			// Hql.g:330:2: ( HAVING ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:330:4: HAVING ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(330, 10);
			HAVING143=(IToken)Match(input,HAVING,Follow._HAVING_in_havingClause1782); 
			HAVING143_tree = (IASTNode)adaptor.Create(HAVING143);
			root_0 = (IASTNode)adaptor.BecomeRoot(HAVING143_tree, root_0);

			DebugLocation(330, 12);
			PushFollow(Follow._logicalExpression_in_havingClause1785);
			logicalExpression144=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression144.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("havingClause", 37);
			LeaveRule("havingClause", 37);
			LeaveRule_havingClause();
	    }
	 	DebugLocation(331, 1);
		} finally { DebugExitRule(GrammarFileName, "havingClause"); }
		return retval;

	}
	// $ANTLR end "havingClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_whereClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_whereClause() {}
	// $ANTLR start "whereClause"
	// Hql.g:333:1: whereClause : WHERE ^ logicalExpression ;
	[GrammarRule("whereClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> whereClause()
	{
		EnterRule_whereClause();
		EnterRule("whereClause", 38);
		TraceIn("whereClause", 38);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken WHERE145 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> logicalExpression146 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode WHERE145_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "whereClause");
		DebugLocation(333, 1);
		try
		{
			// Hql.g:334:2: ( WHERE ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:334:4: WHERE ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(334, 9);
			WHERE145=(IToken)Match(input,WHERE,Follow._WHERE_in_whereClause1796); 
			WHERE145_tree = (IASTNode)adaptor.Create(WHERE145);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHERE145_tree, root_0);

			DebugLocation(334, 11);
			PushFollow(Follow._logicalExpression_in_whereClause1799);
			logicalExpression146=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression146.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whereClause", 38);
			LeaveRule("whereClause", 38);
			LeaveRule_whereClause();
	    }
	 	DebugLocation(335, 1);
		} finally { DebugExitRule(GrammarFileName, "whereClause"); }
		return retval;

	}
	// $ANTLR end "whereClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_selectedPropertiesList() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_selectedPropertiesList() {}
	// $ANTLR start "selectedPropertiesList"
	// Hql.g:337:1: selectedPropertiesList : aliasedExpression ( COMMA ! aliasedExpression )* ;
	[GrammarRule("selectedPropertiesList")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList()
	{
		EnterRule_selectedPropertiesList();
		EnterRule("selectedPropertiesList", 39);
		TraceIn("selectedPropertiesList", 39);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken COMMA148 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression147 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression149 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode COMMA148_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "selectedPropertiesList");
		DebugLocation(337, 1);
		try
		{
			// Hql.g:338:2: ( aliasedExpression ( COMMA ! aliasedExpression )* )
			DebugEnterAlt(1);
			// Hql.g:338:4: aliasedExpression ( COMMA ! aliasedExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(338, 4);
			PushFollow(Follow._aliasedExpression_in_selectedPropertiesList1810);
			aliasedExpression147=aliasedExpression();
			PopFollow();

			adaptor.AddChild(root_0, aliasedExpression147.Tree);
			DebugLocation(338, 22);
			// Hql.g:338:22: ( COMMA ! aliasedExpression )*
			try { DebugEnterSubRule(49);
			while (true)
			{
				int alt49=2;
				try { DebugEnterDecision(49, decisionCanBacktrack[49]);
				int LA49_1 = input.LA(1);

				if ((LA49_1==COMMA))
				{
					alt49 = 1;
				}


				} finally { DebugExitDecision(49); }
				switch ( alt49 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:338:24: COMMA ! aliasedExpression
					{
					DebugLocation(338, 29);
					COMMA148=(IToken)Match(input,COMMA,Follow._COMMA_in_selectedPropertiesList1814); 
					DebugLocation(338, 31);
					PushFollow(Follow._aliasedExpression_in_selectedPropertiesList1817);
					aliasedExpression149=aliasedExpression();
					PopFollow();

					adaptor.AddChild(root_0, aliasedExpression149.Tree);

					}
					break;

				default:
					goto loop49;
				}
			}

			loop49:
				;

			} finally { DebugExitSubRule(49); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectedPropertiesList", 39);
			LeaveRule("selectedPropertiesList", 39);
			LeaveRule_selectedPropertiesList();
	    }
	 	DebugLocation(339, 1);
		} finally { DebugExitRule(GrammarFileName, "selectedPropertiesList"); }
		return retval;

	}
	// $ANTLR end "selectedPropertiesList"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_aliasedExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_aliasedExpression() {}
	// $ANTLR start "aliasedExpression"
	// Hql.g:341:1: aliasedExpression : expression ( AS ^ identifier )? ;
	[GrammarRule("aliasedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression()
	{
		EnterRule_aliasedExpression();
		EnterRule("aliasedExpression", 40);
		TraceIn("aliasedExpression", 40);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken AS151 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> expression150 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier152 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode AS151_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "aliasedExpression");
		DebugLocation(341, 1);
		try
		{
			// Hql.g:342:2: ( expression ( AS ^ identifier )? )
			DebugEnterAlt(1);
			// Hql.g:342:4: expression ( AS ^ identifier )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(342, 4);
			PushFollow(Follow._expression_in_aliasedExpression1832);
			expression150=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression150.Tree);
			DebugLocation(342, 15);
			// Hql.g:342:15: ( AS ^ identifier )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, decisionCanBacktrack[50]);
			int LA50_1 = input.LA(1);

			if ((LA50_1==AS))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:342:17: AS ^ identifier
				{
				DebugLocation(342, 19);
				AS151=(IToken)Match(input,AS,Follow._AS_in_aliasedExpression1836); 
				AS151_tree = (IASTNode)adaptor.Create(AS151);
				root_0 = (IASTNode)adaptor.BecomeRoot(AS151_tree, root_0);

				DebugLocation(342, 21);
				PushFollow(Follow._identifier_in_aliasedExpression1839);
				identifier152=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier152.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(50); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aliasedExpression", 40);
			LeaveRule("aliasedExpression", 40);
			LeaveRule_aliasedExpression();
	    }
	 	DebugLocation(343, 1);
		} finally { DebugExitRule(GrammarFileName, "aliasedExpression"); }
		return retval;

	}
	// $ANTLR end "aliasedExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_logicalExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_logicalExpression() {}
	// $ANTLR start "logicalExpression"
	// Hql.g:370:1: logicalExpression : expression ;
	[GrammarRule("logicalExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 41);
		TraceIn("logicalExpression", 41);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> expression153 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(370, 1);
		try
		{
			// Hql.g:371:2: ( expression )
			DebugEnterAlt(1);
			// Hql.g:371:4: expression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(371, 4);
			PushFollow(Follow._expression_in_logicalExpression1878);
			expression153=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression153.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalExpression", 41);
			LeaveRule("logicalExpression", 41);
			LeaveRule_logicalExpression();
	    }
	 	DebugLocation(372, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return retval;

	}
	// $ANTLR end "logicalExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expression() {}
	// $ANTLR start "expression"
	// Hql.g:375:1: expression : logicalOrExpression ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<IASTNode, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 42);
		TraceIn("expression", 42);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> logicalOrExpression154 = default(AstParserRuleReturnScope<IASTNode, IToken>);


		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(375, 1);
		try
		{
			// Hql.g:376:2: ( logicalOrExpression )
			DebugEnterAlt(1);
			// Hql.g:376:4: logicalOrExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(376, 4);
			PushFollow(Follow._logicalOrExpression_in_expression1890);
			logicalOrExpression154=logicalOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalOrExpression154.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 42);
			LeaveRule("expression", 42);
			LeaveRule_expression();
	    }
	 	DebugLocation(377, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_logicalOrExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_logicalOrExpression() {}
	// $ANTLR start "logicalOrExpression"
	// Hql.g:380:1: logicalOrExpression : logicalAndExpression ( OR ^ logicalAndExpression )* ;
	[GrammarRule("logicalOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 43);
		TraceIn("logicalOrExpression", 43);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken OR156 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression155 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression157 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode OR156_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(380, 1);
		try
		{
			// Hql.g:381:2: ( logicalAndExpression ( OR ^ logicalAndExpression )* )
			DebugEnterAlt(1);
			// Hql.g:381:4: logicalAndExpression ( OR ^ logicalAndExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(381, 4);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1902);
			logicalAndExpression155=logicalAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalAndExpression155.Tree);
			DebugLocation(381, 25);
			// Hql.g:381:25: ( OR ^ logicalAndExpression )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, decisionCanBacktrack[51]);
				int LA51_1 = input.LA(1);

				if ((LA51_1==OR))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:381:27: OR ^ logicalAndExpression
					{
					DebugLocation(381, 29);
					OR156=(IToken)Match(input,OR,Follow._OR_in_logicalOrExpression1906); 
					OR156_tree = (IASTNode)adaptor.Create(OR156);
					root_0 = (IASTNode)adaptor.BecomeRoot(OR156_tree, root_0);

					DebugLocation(381, 31);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1909);
					logicalAndExpression157=logicalAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, logicalAndExpression157.Tree);

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 43);
			LeaveRule("logicalOrExpression", 43);
			LeaveRule_logicalOrExpression();
	    }
	 	DebugLocation(382, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_logicalAndExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_logicalAndExpression() {}
	// $ANTLR start "logicalAndExpression"
	// Hql.g:385:1: logicalAndExpression : negatedExpression ( AND ^ negatedExpression )* ;
	[GrammarRule("logicalAndExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 44);
		TraceIn("logicalAndExpression", 44);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken AND159 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> negatedExpression158 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> negatedExpression160 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode AND159_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(385, 1);
		try
		{
			// Hql.g:386:2: ( negatedExpression ( AND ^ negatedExpression )* )
			DebugEnterAlt(1);
			// Hql.g:386:4: negatedExpression ( AND ^ negatedExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(386, 4);
			PushFollow(Follow._negatedExpression_in_logicalAndExpression1924);
			negatedExpression158=negatedExpression();
			PopFollow();

			adaptor.AddChild(root_0, negatedExpression158.Tree);
			DebugLocation(386, 22);
			// Hql.g:386:22: ( AND ^ negatedExpression )*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, decisionCanBacktrack[52]);
				int LA52_1 = input.LA(1);

				if ((LA52_1==AND))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:386:24: AND ^ negatedExpression
					{
					DebugLocation(386, 27);
					AND159=(IToken)Match(input,AND,Follow._AND_in_logicalAndExpression1928); 
					AND159_tree = (IASTNode)adaptor.Create(AND159);
					root_0 = (IASTNode)adaptor.BecomeRoot(AND159_tree, root_0);

					DebugLocation(386, 29);
					PushFollow(Follow._negatedExpression_in_logicalAndExpression1931);
					negatedExpression160=negatedExpression();
					PopFollow();

					adaptor.AddChild(root_0, negatedExpression160.Tree);

					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 44);
			LeaveRule("logicalAndExpression", 44);
			LeaveRule_logicalAndExpression();
	    }
	 	DebugLocation(387, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_negatedExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_negatedExpression() {}
	// $ANTLR start "negatedExpression"
	// Hql.g:391:1: negatedExpression : ( NOT x= negatedExpression -> ^() | equalityExpression -> ^( equalityExpression ) );
	[GrammarRule("negatedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> negatedExpression()
	{
		EnterRule_negatedExpression();
		EnterRule("negatedExpression", 45);
		TraceIn("negatedExpression", 45);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken NOT161 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> x = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> equalityExpression162 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode NOT161_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
	    RewriteRuleSubtreeStream stream_negatedExpression=new RewriteRuleSubtreeStream(adaptor,"rule negatedExpression");
	    RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpression");
	     WeakKeywords(); 
		try { DebugEnterRule(GrammarFileName, "negatedExpression");
		DebugLocation(391, 1);
		try
		{
			// Hql.g:393:2: ( NOT x= negatedExpression -> ^() | equalityExpression -> ^( equalityExpression ) )
			int alt53=2;
			try { DebugEnterDecision(53, decisionCanBacktrack[53]);
			int LA53_1 = input.LA(1);

			if ((LA53_1==NOT))
			{
				alt53 = 1;
			}
			else if ((LA53_1==ALL||LA53_1==ANY||LA53_1==AVG||LA53_1==BNOT||LA53_1==CASE||LA53_1==COLON||LA53_1==COUNT||LA53_1==ELEMENTS||LA53_1==EMPTY||LA53_1==EXISTS||LA53_1==FALSE||LA53_1==IDENT||LA53_1==INDICES||LA53_1==MAX||(LA53_1>=MIN && LA53_1<=MINUS)||(LA53_1>=NULL && LA53_1<=NUM_LONG)||LA53_1==OPEN||(LA53_1>=PARAM && LA53_1<=PLUS)||LA53_1==QUOTED_String||LA53_1==SOME||LA53_1==SUM||LA53_1==TRUE))
			{
				alt53 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:393:4: NOT x= negatedExpression
				{
				DebugLocation(393, 4);
				NOT161=(IToken)Match(input,NOT,Follow._NOT_in_negatedExpression1952);  
				stream_NOT.Add(NOT161);

				DebugLocation(393, 9);
				PushFollow(Follow._negatedExpression_in_negatedExpression1956);
				x=negatedExpression();
				PopFollow();

				stream_negatedExpression.Add(x.Tree);


				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 394:3: -> ^()
				{
					DebugLocation(394, 6);
					// Hql.g:394:6: ^()
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(394, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(NegateNode((x!=null?((IASTNode)x.Tree):default(IASTNode))), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:395:4: equalityExpression
				{
				DebugLocation(395, 4);
				PushFollow(Follow._equalityExpression_in_negatedExpression1969);
				equalityExpression162=equalityExpression();
				PopFollow();

				stream_equalityExpression.Add(equalityExpression162.Tree);


				{
				// AST REWRITE
				// elements: equalityExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 396:3: -> ^( equalityExpression )
				{
					DebugLocation(396, 6);
					// Hql.g:396:6: ^( equalityExpression )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(396, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_equalityExpression.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negatedExpression", 45);
			LeaveRule("negatedExpression", 45);
			LeaveRule_negatedExpression();
	    }
	 	DebugLocation(397, 1);
		} finally { DebugExitRule(GrammarFileName, "negatedExpression"); }
		return retval;

	}
	// $ANTLR end "negatedExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_equalityExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_equalityExpression() {}
	// $ANTLR start "equalityExpression"
	// Hql.g:402:1: equalityExpression : x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 46);
		TraceIn("equalityExpression", 46);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken isx = default(IToken);
	    IToken ne = default(IToken);
	    IToken EQ163 = default(IToken);
	    IToken NOT164 = default(IToken);
	    IToken NE165 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> x = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> y = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode isx_tree = default(IASTNode);
	    IASTNode ne_tree = default(IASTNode);
	    IASTNode EQ163_tree = default(IASTNode);
	    IASTNode NOT164_tree = default(IASTNode);
	    IASTNode NE165_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(402, 1);
		try
		{
			// Hql.g:407:2: (x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )* )
			DebugEnterAlt(1);
			// Hql.g:407:4: x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(407, 5);
			PushFollow(Follow._relationalExpression_in_equalityExpression1999);
			x=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, x.Tree);
			DebugLocation(407, 27);
			// Hql.g:407:27: ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, decisionCanBacktrack[56]);
				int LA56_1 = input.LA(1);

				if ((LA56_1==EQ||LA56_1==IS||LA56_1==NE||LA56_1==SQL_NE))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:408:3: ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression
					{
					DebugLocation(408, 3);
					// Hql.g:408:3: ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^)
					int alt55=4;
					try { DebugEnterSubRule(55);
					try { DebugEnterDecision(55, decisionCanBacktrack[55]);
					switch (input.LA(1))
					{
					case EQ:
						{
						alt55 = 1;
						}
						break;
					case IS:
						{
						alt55 = 2;
						}
						break;
					case NE:
						{
						alt55 = 3;
						}
						break;
					case SQL_NE:
						{
						alt55 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 55, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(55); }
					switch (alt55)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:408:5: EQ ^
						{
						DebugLocation(408, 7);
						EQ163=(IToken)Match(input,EQ,Follow._EQ_in_equalityExpression2007); 
						EQ163_tree = (IASTNode)adaptor.Create(EQ163);
						root_0 = (IASTNode)adaptor.BecomeRoot(EQ163_tree, root_0);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:409:5: isx= IS ^ ( NOT !)?
						{
						DebugLocation(409, 8);
						isx=(IToken)Match(input,IS,Follow._IS_in_equalityExpression2016); 
						isx_tree = (IASTNode)adaptor.Create(isx);
						root_0 = (IASTNode)adaptor.BecomeRoot(isx_tree, root_0);

						DebugLocation(409, 13);
						 isx.Type = EQ; 
						DebugLocation(409, 33);
						// Hql.g:409:33: ( NOT !)?
						int alt54=2;
						try { DebugEnterSubRule(54);
						try { DebugEnterDecision(54, decisionCanBacktrack[54]);
						int LA54_1 = input.LA(1);

						if ((LA54_1==NOT))
						{
							alt54 = 1;
						}
						} finally { DebugExitDecision(54); }
						switch (alt54)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:409:34: NOT !
							{
							DebugLocation(409, 37);
							NOT164=(IToken)Match(input,NOT,Follow._NOT_in_equalityExpression2022); 
							DebugLocation(409, 39);
							 isx.Type =NE; 

							}
							break;

						}
						} finally { DebugExitSubRule(54); }


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Hql.g:410:5: NE ^
						{
						DebugLocation(410, 7);
						NE165=(IToken)Match(input,NE,Follow._NE_in_equalityExpression2034); 
						NE165_tree = (IASTNode)adaptor.Create(NE165);
						root_0 = (IASTNode)adaptor.BecomeRoot(NE165_tree, root_0);


						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Hql.g:411:5: ne= SQL_NE ^
						{
						DebugLocation(411, 7);
						ne=(IToken)Match(input,SQL_NE,Follow._SQL_NE_in_equalityExpression2043); 
						ne_tree = (IASTNode)adaptor.Create(ne);
						root_0 = (IASTNode)adaptor.BecomeRoot(ne_tree, root_0);

						DebugLocation(411, 16);
						 ne.Type = NE; 

						}
						break;

					}
					} finally { DebugExitSubRule(55); }

					DebugLocation(412, 6);
					PushFollow(Follow._relationalExpression_in_equalityExpression2054);
					y=relationalExpression();
					PopFollow();

					adaptor.AddChild(root_0, y.Tree);

					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


						// Post process the equality expression to clean up 'is null', etc.
						retval.Tree =  ProcessEqualityExpression(retval.Tree);
					
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 46);
			LeaveRule("equalityExpression", 46);
			LeaveRule_equalityExpression();
	    }
	 	DebugLocation(413, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_relationalExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_relationalExpression() {}
	// $ANTLR start "relationalExpression"
	// Hql.g:419:1: relationalExpression : concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) ) ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 47);
		TraceIn("relationalExpression", 47);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken n = default(IToken);
	    IToken i = default(IToken);
	    IToken b = default(IToken);
	    IToken l = default(IToken);
	    IToken LT167 = default(IToken);
	    IToken GT168 = default(IToken);
	    IToken LE169 = default(IToken);
	    IToken GE170 = default(IToken);
	    IToken MEMBER176 = default(IToken);
	    IToken OF177 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> p = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> concatenation166 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression171 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> inList172 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> betweenList173 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> concatenation174 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> likeEscape175 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode n_tree = default(IASTNode);
	    IASTNode i_tree = default(IASTNode);
	    IASTNode b_tree = default(IASTNode);
	    IASTNode l_tree = default(IASTNode);
	    IASTNode LT167_tree = default(IASTNode);
	    IASTNode GT168_tree = default(IASTNode);
	    IASTNode LE169_tree = default(IASTNode);
	    IASTNode GE170_tree = default(IASTNode);
	    IASTNode MEMBER176_tree = default(IASTNode);
	    IASTNode OF177_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(419, 1);
		try
		{
			// Hql.g:420:2: ( concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) ) )
			DebugEnterAlt(1);
			// Hql.g:420:4: concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(420, 4);
			PushFollow(Follow._concatenation_in_relationalExpression2071);
			concatenation166=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation166.Tree);
			DebugLocation(420, 18);
			// Hql.g:420:18: ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) )
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, decisionCanBacktrack[62]);
			int LA62_1 = input.LA(1);

			if ((LA62_1==EOF||LA62_1==AND||(LA62_1>=AS && LA62_1<=ASCENDING)||(LA62_1>=CLOSE && LA62_1<=CLOSE_BRACKET)||LA62_1==COMMA||LA62_1==DESCENDING||LA62_1==ELSE||(LA62_1>=END && LA62_1<=EQ)||(LA62_1>=FROM && LA62_1<=HAVING)||LA62_1==INNER||LA62_1==IS||(LA62_1>=JOIN && LA62_1<=LE)||LA62_1==LEFT||LA62_1==LT||LA62_1==NE||(LA62_1>=OR && LA62_1<=ORDER)||LA62_1==RIGHT||LA62_1==SKIP||LA62_1==SQL_NE||(LA62_1>=TAKE && LA62_1<=THEN)||LA62_1==UNION||(LA62_1>=WHEN && LA62_1<=WHERE)||(LA62_1>=133 && LA62_1<=134)))
			{
				alt62 = 1;
			}
			else if ((LA62_1==BETWEEN||LA62_1==IN||LA62_1==LIKE||LA62_1==MEMBER||LA62_1==NOT))
			{
				alt62 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 62, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:421:3: ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* )
				{
				DebugLocation(421, 3);
				// Hql.g:421:3: ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* )
				DebugEnterAlt(1);
				// Hql.g:421:5: ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )*
				{
				DebugLocation(421, 5);
				// Hql.g:421:5: ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )*
				try { DebugEnterSubRule(58);
				while (true)
				{
					int alt58=2;
					try { DebugEnterDecision(58, decisionCanBacktrack[58]);
					int LA58_1 = input.LA(1);

					if ((LA58_1==GE||LA58_1==GT||LA58_1==LE||LA58_1==LT))
					{
						alt58 = 1;
					}


					} finally { DebugExitDecision(58); }
					switch ( alt58 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:421:7: ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression
						{
						DebugLocation(421, 7);
						// Hql.g:421:7: ( LT ^| GT ^| LE ^| GE ^)
						int alt57=4;
						try { DebugEnterSubRule(57);
						try { DebugEnterDecision(57, decisionCanBacktrack[57]);
						switch (input.LA(1))
						{
						case LT:
							{
							alt57 = 1;
							}
							break;
						case GT:
							{
							alt57 = 2;
							}
							break;
						case LE:
							{
							alt57 = 3;
							}
							break;
						case GE:
							{
							alt57 = 4;
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

						} finally { DebugExitDecision(57); }
						switch (alt57)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:421:9: LT ^
							{
							DebugLocation(421, 11);
							LT167=(IToken)Match(input,LT,Follow._LT_in_relationalExpression2083); 
							LT167_tree = (IASTNode)adaptor.Create(LT167);
							root_0 = (IASTNode)adaptor.BecomeRoot(LT167_tree, root_0);


							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Hql.g:421:15: GT ^
							{
							DebugLocation(421, 17);
							GT168=(IToken)Match(input,GT,Follow._GT_in_relationalExpression2088); 
							GT168_tree = (IASTNode)adaptor.Create(GT168);
							root_0 = (IASTNode)adaptor.BecomeRoot(GT168_tree, root_0);


							}
							break;
						case 3:
							DebugEnterAlt(3);
							// Hql.g:421:21: LE ^
							{
							DebugLocation(421, 23);
							LE169=(IToken)Match(input,LE,Follow._LE_in_relationalExpression2093); 
							LE169_tree = (IASTNode)adaptor.Create(LE169);
							root_0 = (IASTNode)adaptor.BecomeRoot(LE169_tree, root_0);


							}
							break;
						case 4:
							DebugEnterAlt(4);
							// Hql.g:421:27: GE ^
							{
							DebugLocation(421, 29);
							GE170=(IToken)Match(input,GE,Follow._GE_in_relationalExpression2098); 
							GE170_tree = (IASTNode)adaptor.Create(GE170);
							root_0 = (IASTNode)adaptor.BecomeRoot(GE170_tree, root_0);


							}
							break;

						}
						} finally { DebugExitSubRule(57); }

						DebugLocation(421, 33);
						PushFollow(Follow._bitwiseNotExpression_in_relationalExpression2103);
						bitwiseNotExpression171=bitwiseNotExpression();
						PopFollow();

						adaptor.AddChild(root_0, bitwiseNotExpression171.Tree);

						}
						break;

					default:
						goto loop58;
					}
				}

				loop58:
					;

				} finally { DebugExitSubRule(58); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:423:5: (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) )
				{
				DebugLocation(423, 5);
				// Hql.g:423:5: (n= NOT !)?
				int alt59=2;
				try { DebugEnterSubRule(59);
				try { DebugEnterDecision(59, decisionCanBacktrack[59]);
				int LA59_1 = input.LA(1);

				if ((LA59_1==NOT))
				{
					alt59 = 1;
				}
				} finally { DebugExitDecision(59); }
				switch (alt59)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:423:6: n= NOT !
					{
					DebugLocation(423, 7);
					n=(IToken)Match(input,NOT,Follow._NOT_in_relationalExpression2120); 

					}
					break;

				}
				} finally { DebugExitSubRule(59); }

				DebugLocation(423, 15);
				// Hql.g:423:15: ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) )
				int alt61=4;
				try { DebugEnterSubRule(61);
				try { DebugEnterDecision(61, decisionCanBacktrack[61]);
				switch (input.LA(1))
				{
				case IN:
					{
					alt61 = 1;
					}
					break;
				case BETWEEN:
					{
					alt61 = 2;
					}
					break;
				case LIKE:
					{
					alt61 = 3;
					}
					break;
				case MEMBER:
					{
					alt61 = 4;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 61, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(61); }
				switch (alt61)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:426:4: (i= IN ^ inList )
					{
					DebugLocation(426, 4);
					// Hql.g:426:4: (i= IN ^ inList )
					DebugEnterAlt(1);
					// Hql.g:426:5: i= IN ^ inList
					{
					DebugLocation(426, 6);
					i=(IToken)Match(input,IN,Follow._IN_in_relationalExpression2141); 
					i_tree = (IASTNode)adaptor.Create(i);
					root_0 = (IASTNode)adaptor.BecomeRoot(i_tree, root_0);

					DebugLocation(426, 11);

										i.Type = (n == null) ? IN : NOT_IN;
										i.Text = (n == null) ? "in" : "not in";
									
					DebugLocation(430, 5);
					PushFollow(Follow._inList_in_relationalExpression2150);
					inList172=inList();
					PopFollow();

					adaptor.AddChild(root_0, inList172.Tree);

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:431:6: (b= BETWEEN ^ betweenList )
					{
					DebugLocation(431, 6);
					// Hql.g:431:6: (b= BETWEEN ^ betweenList )
					DebugEnterAlt(1);
					// Hql.g:431:7: b= BETWEEN ^ betweenList
					{
					DebugLocation(431, 8);
					b=(IToken)Match(input,BETWEEN,Follow._BETWEEN_in_relationalExpression2161); 
					b_tree = (IASTNode)adaptor.Create(b);
					root_0 = (IASTNode)adaptor.BecomeRoot(b_tree, root_0);

					DebugLocation(431, 18);

										b.Type = (n == null) ? BETWEEN : NOT_BETWEEN;
										b.Text = (n == null) ? "between" : "not between";
									
					DebugLocation(435, 5);
					PushFollow(Follow._betweenList_in_relationalExpression2170);
					betweenList173=betweenList();
					PopFollow();

					adaptor.AddChild(root_0, betweenList173.Tree);

					}


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:436:6: (l= LIKE ^ concatenation likeEscape )
					{
					DebugLocation(436, 6);
					// Hql.g:436:6: (l= LIKE ^ concatenation likeEscape )
					DebugEnterAlt(1);
					// Hql.g:436:7: l= LIKE ^ concatenation likeEscape
					{
					DebugLocation(436, 8);
					l=(IToken)Match(input,LIKE,Follow._LIKE_in_relationalExpression2182); 
					l_tree = (IASTNode)adaptor.Create(l);
					root_0 = (IASTNode)adaptor.BecomeRoot(l_tree, root_0);

					DebugLocation(436, 15);

										l.Type = (n == null) ? LIKE : NOT_LIKE;
										l.Text = (n == null) ? "like" : "not like";
									
					DebugLocation(440, 5);
					PushFollow(Follow._concatenation_in_relationalExpression2191);
					concatenation174=concatenation();
					PopFollow();

					adaptor.AddChild(root_0, concatenation174.Tree);
					DebugLocation(440, 19);
					PushFollow(Follow._likeEscape_in_relationalExpression2193);
					likeEscape175=likeEscape();
					PopFollow();

					adaptor.AddChild(root_0, likeEscape175.Tree);

					}


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Hql.g:441:6: ( MEMBER ! ( OF !)? p= path !)
					{
					DebugLocation(441, 6);
					// Hql.g:441:6: ( MEMBER ! ( OF !)? p= path !)
					DebugEnterAlt(1);
					// Hql.g:441:7: MEMBER ! ( OF !)? p= path !
					{
					DebugLocation(441, 13);
					MEMBER176=(IToken)Match(input,MEMBER,Follow._MEMBER_in_relationalExpression2202); 
					DebugLocation(441, 15);
					// Hql.g:441:15: ( OF !)?
					int alt60=2;
					try { DebugEnterSubRule(60);
					try { DebugEnterDecision(60, decisionCanBacktrack[60]);
					int LA60_1 = input.LA(1);

					if ((LA60_1==OF))
					{
						alt60 = 1;
					}
					} finally { DebugExitDecision(60); }
					switch (alt60)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:441:16: OF !
						{
						DebugLocation(441, 18);
						OF177=(IToken)Match(input,OF,Follow._OF_in_relationalExpression2206); 

						}
						break;

					}
					} finally { DebugExitSubRule(60); }

					DebugLocation(441, 23);
					PushFollow(Follow._path_in_relationalExpression2213);
					p=path();
					PopFollow();

					DebugLocation(441, 30);

									root_0 = ProcessMemberOf(n,(p!=null?((IASTNode)p.Tree):default(IASTNode)), root_0);
								  

					}


					}
					break;

				}
				} finally { DebugExitSubRule(61); }


				}
				break;

			}
			} finally { DebugExitSubRule(62); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 47);
			LeaveRule("relationalExpression", 47);
			LeaveRule_relationalExpression();
	    }
	 	DebugLocation(446, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_likeEscape() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_likeEscape() {}
	// $ANTLR start "likeEscape"
	// Hql.g:448:1: likeEscape : ( ESCAPE ^ concatenation )? ;
	[GrammarRule("likeEscape")]
	private AstParserRuleReturnScope<IASTNode, IToken> likeEscape()
	{
		EnterRule_likeEscape();
		EnterRule("likeEscape", 48);
		TraceIn("likeEscape", 48);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken ESCAPE178 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> concatenation179 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode ESCAPE178_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "likeEscape");
		DebugLocation(448, 1);
		try
		{
			// Hql.g:449:2: ( ( ESCAPE ^ concatenation )? )
			DebugEnterAlt(1);
			// Hql.g:449:4: ( ESCAPE ^ concatenation )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(449, 4);
			// Hql.g:449:4: ( ESCAPE ^ concatenation )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, decisionCanBacktrack[63]);
			int LA63_1 = input.LA(1);

			if ((LA63_1==ESCAPE))
			{
				alt63 = 1;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:449:5: ESCAPE ^ concatenation
				{
				DebugLocation(449, 11);
				ESCAPE178=(IToken)Match(input,ESCAPE,Follow._ESCAPE_in_likeEscape2240); 
				ESCAPE178_tree = (IASTNode)adaptor.Create(ESCAPE178);
				root_0 = (IASTNode)adaptor.BecomeRoot(ESCAPE178_tree, root_0);

				DebugLocation(449, 13);
				PushFollow(Follow._concatenation_in_likeEscape2243);
				concatenation179=concatenation();
				PopFollow();

				adaptor.AddChild(root_0, concatenation179.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(63); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("likeEscape", 48);
			LeaveRule("likeEscape", 48);
			LeaveRule_likeEscape();
	    }
	 	DebugLocation(450, 1);
		} finally { DebugExitRule(GrammarFileName, "likeEscape"); }
		return retval;

	}
	// $ANTLR end "likeEscape"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_inList() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_inList() {}
	// $ANTLR start "inList"
	// Hql.g:452:1: inList : compoundExpr -> ^( IN_LIST[\"inList\"] compoundExpr ) ;
	[GrammarRule("inList")]
	private AstParserRuleReturnScope<IASTNode, IToken> inList()
	{
		EnterRule_inList();
		EnterRule("inList", 49);
		TraceIn("inList", 49);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> compoundExpr180 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_compoundExpr=new RewriteRuleSubtreeStream(adaptor,"rule compoundExpr");
		try { DebugEnterRule(GrammarFileName, "inList");
		DebugLocation(452, 1);
		try
		{
			// Hql.g:453:2: ( compoundExpr -> ^( IN_LIST[\"inList\"] compoundExpr ) )
			DebugEnterAlt(1);
			// Hql.g:453:4: compoundExpr
			{
			DebugLocation(453, 4);
			PushFollow(Follow._compoundExpr_in_inList2256);
			compoundExpr180=compoundExpr();
			PopFollow();

			stream_compoundExpr.Add(compoundExpr180.Tree);


			{
			// AST REWRITE
			// elements: compoundExpr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 454:2: -> ^( IN_LIST[\"inList\"] compoundExpr )
			{
				DebugLocation(454, 5);
				// Hql.g:454:5: ^( IN_LIST[\"inList\"] compoundExpr )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(454, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(IN_LIST, "inList"), root_1);

				DebugLocation(454, 25);
				adaptor.AddChild(root_1, stream_compoundExpr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inList", 49);
			LeaveRule("inList", 49);
			LeaveRule_inList();
	    }
	 	DebugLocation(455, 1);
		} finally { DebugExitRule(GrammarFileName, "inList"); }
		return retval;

	}
	// $ANTLR end "inList"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_betweenList() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_betweenList() {}
	// $ANTLR start "betweenList"
	// Hql.g:457:1: betweenList : concatenation AND ! concatenation ;
	[GrammarRule("betweenList")]
	private AstParserRuleReturnScope<IASTNode, IToken> betweenList()
	{
		EnterRule_betweenList();
		EnterRule("betweenList", 50);
		TraceIn("betweenList", 50);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken AND182 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> concatenation181 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> concatenation183 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode AND182_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "betweenList");
		DebugLocation(457, 1);
		try
		{
			// Hql.g:458:2: ( concatenation AND ! concatenation )
			DebugEnterAlt(1);
			// Hql.g:458:4: concatenation AND ! concatenation
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(458, 4);
			PushFollow(Follow._concatenation_in_betweenList2277);
			concatenation181=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation181.Tree);
			DebugLocation(458, 21);
			AND182=(IToken)Match(input,AND,Follow._AND_in_betweenList2279); 
			DebugLocation(458, 23);
			PushFollow(Follow._concatenation_in_betweenList2282);
			concatenation183=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation183.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("betweenList", 50);
			LeaveRule("betweenList", 50);
			LeaveRule_betweenList();
	    }
	 	DebugLocation(459, 1);
		} finally { DebugExitRule(GrammarFileName, "betweenList"); }
		return retval;

	}
	// $ANTLR end "betweenList"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_concatenation() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_concatenation() {}
	// $ANTLR start "concatenation"
	// Hql.g:462:1: concatenation : a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )? ;
	[GrammarRule("concatenation")]
	private AstParserRuleReturnScope<IASTNode, IToken> concatenation()
	{
		EnterRule_concatenation();
		EnterRule("concatenation", 51);
		TraceIn("concatenation", 51);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken c = default(IToken);
	    IToken CONCAT185 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> a = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression184 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression186 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode c_tree = default(IASTNode);
	    IASTNode CONCAT185_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "concatenation");
		DebugLocation(462, 1);
		try
		{
			// Hql.g:473:2: (a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )? )
			DebugEnterAlt(1);
			// Hql.g:473:4: a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(473, 5);
			PushFollow(Follow._bitwiseNotExpression_in_concatenation2301);
			a=bitwiseNotExpression();
			PopFollow();

			adaptor.AddChild(root_0, a.Tree);
			DebugLocation(474, 2);
			// Hql.g:474:2: (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, decisionCanBacktrack[65]);
			int LA65_1 = input.LA(1);

			if ((LA65_1==CONCAT))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:474:4: c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )*
				{
				DebugLocation(474, 5);
				c=(IToken)Match(input,CONCAT,Follow._CONCAT_in_concatenation2309); 
				c_tree = (IASTNode)adaptor.Create(c);
				root_0 = (IASTNode)adaptor.BecomeRoot(c_tree, root_0);

				DebugLocation(474, 14);
				 c.Type = EXPR_LIST; c.Text = "concatList"; 
				DebugLocation(475, 4);
				PushFollow(Follow._bitwiseNotExpression_in_concatenation2318);
				bitwiseNotExpression184=bitwiseNotExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseNotExpression184.Tree);
				DebugLocation(476, 4);
				// Hql.g:476:4: ( CONCAT ! bitwiseNotExpression )*
				try { DebugEnterSubRule(64);
				while (true)
				{
					int alt64=2;
					try { DebugEnterDecision(64, decisionCanBacktrack[64]);
					int LA64_1 = input.LA(1);

					if ((LA64_1==CONCAT))
					{
						alt64 = 1;
					}


					} finally { DebugExitDecision(64); }
					switch ( alt64 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:476:6: CONCAT ! bitwiseNotExpression
						{
						DebugLocation(476, 12);
						CONCAT185=(IToken)Match(input,CONCAT,Follow._CONCAT_in_concatenation2325); 
						DebugLocation(476, 14);
						PushFollow(Follow._bitwiseNotExpression_in_concatenation2328);
						bitwiseNotExpression186=bitwiseNotExpression();
						PopFollow();

						adaptor.AddChild(root_0, bitwiseNotExpression186.Tree);

						}
						break;

					default:
						goto loop64;
					}
				}

				loop64:
					;

				} finally { DebugExitSubRule(64); }


				}
				break;

			}
			} finally { DebugExitSubRule(65); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


			   if (c != null)
			   {
			      IASTNode mc = (IASTNode) adaptor.Create(METHOD_CALL, "||");
			      IASTNode concat = (IASTNode) adaptor.Create(IDENT, "concat");
			      mc.AddChild(concat);
			      mc.AddChild((IASTNode) retval.Tree);
			      retval.Tree = mc;
			   }

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concatenation", 51);
			LeaveRule("concatenation", 51);
			LeaveRule_concatenation();
	    }
	 	DebugLocation(478, 1);
		} finally { DebugExitRule(GrammarFileName, "concatenation"); }
		return retval;

	}
	// $ANTLR end "concatenation"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bitwiseNotExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bitwiseNotExpression() {}
	// $ANTLR start "bitwiseNotExpression"
	// Hql.g:481:1: bitwiseNotExpression : ( ( BNOT ^ bitwiseOrExpression ) | bitwiseOrExpression );
	[GrammarRule("bitwiseNotExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression()
	{
		EnterRule_bitwiseNotExpression();
		EnterRule("bitwiseNotExpression", 52);
		TraceIn("bitwiseNotExpression", 52);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken BNOT187 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression188 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression189 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode BNOT187_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "bitwiseNotExpression");
		DebugLocation(481, 1);
		try
		{
			// Hql.g:482:2: ( ( BNOT ^ bitwiseOrExpression ) | bitwiseOrExpression )
			int alt66=2;
			try { DebugEnterDecision(66, decisionCanBacktrack[66]);
			int LA66_1 = input.LA(1);

			if ((LA66_1==BNOT))
			{
				alt66 = 1;
			}
			else if ((LA66_1==ALL||LA66_1==ANY||LA66_1==AVG||LA66_1==CASE||LA66_1==COLON||LA66_1==COUNT||LA66_1==ELEMENTS||LA66_1==EMPTY||LA66_1==EXISTS||LA66_1==FALSE||LA66_1==IDENT||LA66_1==INDICES||LA66_1==MAX||(LA66_1>=MIN && LA66_1<=MINUS)||(LA66_1>=NULL && LA66_1<=NUM_LONG)||LA66_1==OPEN||(LA66_1>=PARAM && LA66_1<=PLUS)||LA66_1==QUOTED_String||LA66_1==SOME||LA66_1==SUM||LA66_1==TRUE))
			{
				alt66 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 66, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:482:4: ( BNOT ^ bitwiseOrExpression )
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(482, 4);
				// Hql.g:482:4: ( BNOT ^ bitwiseOrExpression )
				DebugEnterAlt(1);
				// Hql.g:482:5: BNOT ^ bitwiseOrExpression
				{
				DebugLocation(482, 9);
				BNOT187=(IToken)Match(input,BNOT,Follow._BNOT_in_bitwiseNotExpression2352); 
				BNOT187_tree = (IASTNode)adaptor.Create(BNOT187);
				root_0 = (IASTNode)adaptor.BecomeRoot(BNOT187_tree, root_0);

				DebugLocation(482, 11);
				PushFollow(Follow._bitwiseOrExpression_in_bitwiseNotExpression2355);
				bitwiseOrExpression188=bitwiseOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseOrExpression188.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:483:4: bitwiseOrExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(483, 4);
				PushFollow(Follow._bitwiseOrExpression_in_bitwiseNotExpression2361);
				bitwiseOrExpression189=bitwiseOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseOrExpression189.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseNotExpression", 52);
			LeaveRule("bitwiseNotExpression", 52);
			LeaveRule_bitwiseNotExpression();
	    }
	 	DebugLocation(484, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseNotExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseNotExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bitwiseOrExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bitwiseOrExpression() {}
	// $ANTLR start "bitwiseOrExpression"
	// Hql.g:486:1: bitwiseOrExpression : bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )* ;
	[GrammarRule("bitwiseOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression()
	{
		EnterRule_bitwiseOrExpression();
		EnterRule("bitwiseOrExpression", 53);
		TraceIn("bitwiseOrExpression", 53);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken BOR191 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression190 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression192 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode BOR191_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "bitwiseOrExpression");
		DebugLocation(486, 1);
		try
		{
			// Hql.g:487:2: ( bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )* )
			DebugEnterAlt(1);
			// Hql.g:487:4: bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(487, 4);
			PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression2373);
			bitwiseXOrExpression190=bitwiseXOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseXOrExpression190.Tree);
			DebugLocation(487, 25);
			// Hql.g:487:25: ( BOR ^ bitwiseXOrExpression )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, decisionCanBacktrack[67]);
				int LA67_1 = input.LA(1);

				if ((LA67_1==BOR))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:487:26: BOR ^ bitwiseXOrExpression
					{
					DebugLocation(487, 29);
					BOR191=(IToken)Match(input,BOR,Follow._BOR_in_bitwiseOrExpression2376); 
					BOR191_tree = (IASTNode)adaptor.Create(BOR191);
					root_0 = (IASTNode)adaptor.BecomeRoot(BOR191_tree, root_0);

					DebugLocation(487, 31);
					PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression2379);
					bitwiseXOrExpression192=bitwiseXOrExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseXOrExpression192.Tree);

					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseOrExpression", 53);
			LeaveRule("bitwiseOrExpression", 53);
			LeaveRule_bitwiseOrExpression();
	    }
	 	DebugLocation(488, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseOrExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bitwiseXOrExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bitwiseXOrExpression() {}
	// $ANTLR start "bitwiseXOrExpression"
	// Hql.g:490:1: bitwiseXOrExpression : bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )* ;
	[GrammarRule("bitwiseXOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression()
	{
		EnterRule_bitwiseXOrExpression();
		EnterRule("bitwiseXOrExpression", 54);
		TraceIn("bitwiseXOrExpression", 54);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken BXOR194 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression193 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression195 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode BXOR194_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "bitwiseXOrExpression");
		DebugLocation(490, 1);
		try
		{
			// Hql.g:491:2: ( bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )* )
			DebugEnterAlt(1);
			// Hql.g:491:4: bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(491, 4);
			PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression2393);
			bitwiseAndExpression193=bitwiseAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseAndExpression193.Tree);
			DebugLocation(491, 25);
			// Hql.g:491:25: ( BXOR ^ bitwiseAndExpression )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, decisionCanBacktrack[68]);
				int LA68_1 = input.LA(1);

				if ((LA68_1==BXOR))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:491:26: BXOR ^ bitwiseAndExpression
					{
					DebugLocation(491, 30);
					BXOR194=(IToken)Match(input,BXOR,Follow._BXOR_in_bitwiseXOrExpression2396); 
					BXOR194_tree = (IASTNode)adaptor.Create(BXOR194);
					root_0 = (IASTNode)adaptor.BecomeRoot(BXOR194_tree, root_0);

					DebugLocation(491, 32);
					PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression2399);
					bitwiseAndExpression195=bitwiseAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseAndExpression195.Tree);

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXOrExpression", 54);
			LeaveRule("bitwiseXOrExpression", 54);
			LeaveRule_bitwiseXOrExpression();
	    }
	 	DebugLocation(492, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXOrExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_bitwiseAndExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_bitwiseAndExpression() {}
	// $ANTLR start "bitwiseAndExpression"
	// Hql.g:494:1: bitwiseAndExpression : additiveExpression ( BAND ^ additiveExpression )* ;
	[GrammarRule("bitwiseAndExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression()
	{
		EnterRule_bitwiseAndExpression();
		EnterRule("bitwiseAndExpression", 55);
		TraceIn("bitwiseAndExpression", 55);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken BAND197 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> additiveExpression196 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> additiveExpression198 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode BAND197_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "bitwiseAndExpression");
		DebugLocation(494, 1);
		try
		{
			// Hql.g:495:2: ( additiveExpression ( BAND ^ additiveExpression )* )
			DebugEnterAlt(1);
			// Hql.g:495:4: additiveExpression ( BAND ^ additiveExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(495, 4);
			PushFollow(Follow._additiveExpression_in_bitwiseAndExpression2413);
			additiveExpression196=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, additiveExpression196.Tree);
			DebugLocation(495, 23);
			// Hql.g:495:23: ( BAND ^ additiveExpression )*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, decisionCanBacktrack[69]);
				int LA69_1 = input.LA(1);

				if ((LA69_1==BAND))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:495:24: BAND ^ additiveExpression
					{
					DebugLocation(495, 28);
					BAND197=(IToken)Match(input,BAND,Follow._BAND_in_bitwiseAndExpression2416); 
					BAND197_tree = (IASTNode)adaptor.Create(BAND197);
					root_0 = (IASTNode)adaptor.BecomeRoot(BAND197_tree, root_0);

					DebugLocation(495, 30);
					PushFollow(Follow._additiveExpression_in_bitwiseAndExpression2419);
					additiveExpression198=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, additiveExpression198.Tree);

					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseAndExpression", 55);
			LeaveRule("bitwiseAndExpression", 55);
			LeaveRule_bitwiseAndExpression();
	    }
	 	DebugLocation(496, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseAndExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseAndExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_additiveExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_additiveExpression() {}
	// $ANTLR start "additiveExpression"
	// Hql.g:499:1: additiveExpression : multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 56);
		TraceIn("additiveExpression", 56);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken PLUS200 = default(IToken);
	    IToken MINUS201 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression199 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression202 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode PLUS200_tree = default(IASTNode);
	    IASTNode MINUS201_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(499, 1);
		try
		{
			// Hql.g:500:2: ( multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )* )
			DebugEnterAlt(1);
			// Hql.g:500:4: multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(500, 4);
			PushFollow(Follow._multiplyExpression_in_additiveExpression2433);
			multiplyExpression199=multiplyExpression();
			PopFollow();

			adaptor.AddChild(root_0, multiplyExpression199.Tree);
			DebugLocation(500, 23);
			// Hql.g:500:23: ( ( PLUS ^| MINUS ^) multiplyExpression )*
			try { DebugEnterSubRule(71);
			while (true)
			{
				int alt71=2;
				try { DebugEnterDecision(71, decisionCanBacktrack[71]);
				int LA71_1 = input.LA(1);

				if ((LA71_1==MINUS||LA71_1==PLUS))
				{
					alt71 = 1;
				}


				} finally { DebugExitDecision(71); }
				switch ( alt71 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:500:25: ( PLUS ^| MINUS ^) multiplyExpression
					{
					DebugLocation(500, 25);
					// Hql.g:500:25: ( PLUS ^| MINUS ^)
					int alt70=2;
					try { DebugEnterSubRule(70);
					try { DebugEnterDecision(70, decisionCanBacktrack[70]);
					int LA70_1 = input.LA(1);

					if ((LA70_1==PLUS))
					{
						alt70 = 1;
					}
					else if ((LA70_1==MINUS))
					{
						alt70 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(70); }
					switch (alt70)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:500:27: PLUS ^
						{
						DebugLocation(500, 31);
						PLUS200=(IToken)Match(input,PLUS,Follow._PLUS_in_additiveExpression2439); 
						PLUS200_tree = (IASTNode)adaptor.Create(PLUS200);
						root_0 = (IASTNode)adaptor.BecomeRoot(PLUS200_tree, root_0);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:500:35: MINUS ^
						{
						DebugLocation(500, 40);
						MINUS201=(IToken)Match(input,MINUS,Follow._MINUS_in_additiveExpression2444); 
						MINUS201_tree = (IASTNode)adaptor.Create(MINUS201);
						root_0 = (IASTNode)adaptor.BecomeRoot(MINUS201_tree, root_0);


						}
						break;

					}
					} finally { DebugExitSubRule(70); }

					DebugLocation(500, 44);
					PushFollow(Follow._multiplyExpression_in_additiveExpression2449);
					multiplyExpression202=multiplyExpression();
					PopFollow();

					adaptor.AddChild(root_0, multiplyExpression202.Tree);

					}
					break;

				default:
					goto loop71;
				}
			}

			loop71:
				;

			} finally { DebugExitSubRule(71); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 56);
			LeaveRule("additiveExpression", 56);
			LeaveRule_additiveExpression();
	    }
	 	DebugLocation(501, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_multiplyExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_multiplyExpression() {}
	// $ANTLR start "multiplyExpression"
	// Hql.g:504:1: multiplyExpression : unaryExpression ( ( STAR ^| DIV ^) unaryExpression )* ;
	[GrammarRule("multiplyExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression()
	{
		EnterRule_multiplyExpression();
		EnterRule("multiplyExpression", 57);
		TraceIn("multiplyExpression", 57);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken STAR204 = default(IToken);
	    IToken DIV205 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> unaryExpression203 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> unaryExpression206 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode STAR204_tree = default(IASTNode);
	    IASTNode DIV205_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "multiplyExpression");
		DebugLocation(504, 1);
		try
		{
			// Hql.g:505:2: ( unaryExpression ( ( STAR ^| DIV ^) unaryExpression )* )
			DebugEnterAlt(1);
			// Hql.g:505:4: unaryExpression ( ( STAR ^| DIV ^) unaryExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(505, 4);
			PushFollow(Follow._unaryExpression_in_multiplyExpression2464);
			unaryExpression203=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression203.Tree);
			DebugLocation(505, 20);
			// Hql.g:505:20: ( ( STAR ^| DIV ^) unaryExpression )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, decisionCanBacktrack[73]);
				int LA73_1 = input.LA(1);

				if ((LA73_1==DIV||LA73_1==STAR))
				{
					alt73 = 1;
				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:505:22: ( STAR ^| DIV ^) unaryExpression
					{
					DebugLocation(505, 22);
					// Hql.g:505:22: ( STAR ^| DIV ^)
					int alt72=2;
					try { DebugEnterSubRule(72);
					try { DebugEnterDecision(72, decisionCanBacktrack[72]);
					int LA72_1 = input.LA(1);

					if ((LA72_1==STAR))
					{
						alt72 = 1;
					}
					else if ((LA72_1==DIV))
					{
						alt72 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 72, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(72); }
					switch (alt72)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:505:24: STAR ^
						{
						DebugLocation(505, 28);
						STAR204=(IToken)Match(input,STAR,Follow._STAR_in_multiplyExpression2470); 
						STAR204_tree = (IASTNode)adaptor.Create(STAR204);
						root_0 = (IASTNode)adaptor.BecomeRoot(STAR204_tree, root_0);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:505:32: DIV ^
						{
						DebugLocation(505, 35);
						DIV205=(IToken)Match(input,DIV,Follow._DIV_in_multiplyExpression2475); 
						DIV205_tree = (IASTNode)adaptor.Create(DIV205);
						root_0 = (IASTNode)adaptor.BecomeRoot(DIV205_tree, root_0);


						}
						break;

					}
					} finally { DebugExitSubRule(72); }

					DebugLocation(505, 39);
					PushFollow(Follow._unaryExpression_in_multiplyExpression2480);
					unaryExpression206=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, unaryExpression206.Tree);

					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplyExpression", 57);
			LeaveRule("multiplyExpression", 57);
			LeaveRule_multiplyExpression();
	    }
	 	DebugLocation(506, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplyExpression"); }
		return retval;

	}
	// $ANTLR end "multiplyExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_unaryExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_unaryExpression() {}
	// $ANTLR start "unaryExpression"
	// Hql.g:509:1: unaryExpression : (m= MINUS mu= unaryExpression -> ^( UNARY_MINUS[$m] $mu) |p= PLUS pu= unaryExpression -> ^( UNARY_PLUS[$p] $pu) |c= caseExpression -> ^( $c) |q= quantifiedExpression -> ^( $q) |a= atom -> ^( $a) );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 58);
		TraceIn("unaryExpression", 58);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken m = default(IToken);
	    IToken p = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> mu = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> pu = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> c = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> q = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> a = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode m_tree = default(IASTNode);
	    IASTNode p_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
	    RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
	    RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
	    RewriteRuleSubtreeStream stream_caseExpression=new RewriteRuleSubtreeStream(adaptor,"rule caseExpression");
	    RewriteRuleSubtreeStream stream_quantifiedExpression=new RewriteRuleSubtreeStream(adaptor,"rule quantifiedExpression");
	    RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(509, 1);
		try
		{
			// Hql.g:510:2: (m= MINUS mu= unaryExpression -> ^( UNARY_MINUS[$m] $mu) |p= PLUS pu= unaryExpression -> ^( UNARY_PLUS[$p] $pu) |c= caseExpression -> ^( $c) |q= quantifiedExpression -> ^( $q) |a= atom -> ^( $a) )
			int alt74=5;
			try { DebugEnterDecision(74, decisionCanBacktrack[74]);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt74 = 1;
				}
				break;
			case PLUS:
				{
				alt74 = 2;
				}
				break;
			case CASE:
				{
				alt74 = 3;
				}
				break;
			case ALL:
			case ANY:
			case EXISTS:
			case SOME:
				{
				alt74 = 4;
				}
				break;
			case AVG:
			case COLON:
			case COUNT:
			case ELEMENTS:
			case EMPTY:
			case FALSE:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case OPEN:
			case PARAM:
			case QUOTED_String:
			case SUM:
			case TRUE:
				{
				alt74 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 74, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:510:4: m= MINUS mu= unaryExpression
				{
				DebugLocation(510, 5);
				m=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression2498);  
				stream_MINUS.Add(m);

				DebugLocation(510, 14);
				PushFollow(Follow._unaryExpression_in_unaryExpression2502);
				mu=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(mu.Tree);


				{
				// AST REWRITE
				// elements: mu
				// token labels: 
				// rule labels: mu, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_mu=new RewriteRuleSubtreeStream(adaptor,"rule mu",mu!=null?mu.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 510:31: -> ^( UNARY_MINUS[$m] $mu)
				{
					DebugLocation(510, 34);
					// Hql.g:510:34: ^( UNARY_MINUS[$m] $mu)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(510, 36);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(UNARY_MINUS, m), root_1);

					DebugLocation(510, 53);
					adaptor.AddChild(root_1, stream_mu.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:511:4: p= PLUS pu= unaryExpression
				{
				DebugLocation(511, 5);
				p=(IToken)Match(input,PLUS,Follow._PLUS_in_unaryExpression2519);  
				stream_PLUS.Add(p);

				DebugLocation(511, 13);
				PushFollow(Follow._unaryExpression_in_unaryExpression2523);
				pu=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(pu.Tree);


				{
				// AST REWRITE
				// elements: pu
				// token labels: 
				// rule labels: pu, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_pu=new RewriteRuleSubtreeStream(adaptor,"rule pu",pu!=null?pu.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 511:30: -> ^( UNARY_PLUS[$p] $pu)
				{
					DebugLocation(511, 33);
					// Hql.g:511:33: ^( UNARY_PLUS[$p] $pu)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(511, 35);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(UNARY_PLUS, p), root_1);

					DebugLocation(511, 51);
					adaptor.AddChild(root_1, stream_pu.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:512:4: c= caseExpression
				{
				DebugLocation(512, 5);
				PushFollow(Follow._caseExpression_in_unaryExpression2540);
				c=caseExpression();
				PopFollow();

				stream_caseExpression.Add(c.Tree);


				{
				// AST REWRITE
				// elements: c
				// token labels: 
				// rule labels: c, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,"rule c",c!=null?c.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 512:21: -> ^( $c)
				{
					DebugLocation(512, 24);
					// Hql.g:512:24: ^( $c)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(512, 27);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_c.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:513:4: q= quantifiedExpression
				{
				DebugLocation(513, 5);
				PushFollow(Follow._quantifiedExpression_in_unaryExpression2554);
				q=quantifiedExpression();
				PopFollow();

				stream_quantifiedExpression.Add(q.Tree);


				{
				// AST REWRITE
				// elements: q
				// token labels: 
				// rule labels: q, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 513:27: -> ^( $q)
				{
					DebugLocation(513, 30);
					// Hql.g:513:30: ^( $q)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(513, 33);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_q.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Hql.g:514:4: a= atom
				{
				DebugLocation(514, 5);
				PushFollow(Follow._atom_in_unaryExpression2569);
				a=atom();
				PopFollow();

				stream_atom.Add(a.Tree);


				{
				// AST REWRITE
				// elements: a
				// token labels: 
				// rule labels: a, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 514:11: -> ^( $a)
				{
					DebugLocation(514, 14);
					// Hql.g:514:14: ^( $a)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(514, 17);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_a.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 58);
			LeaveRule("unaryExpression", 58);
			LeaveRule_unaryExpression();
	    }
	 	DebugLocation(515, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_caseExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_caseExpression() {}
	// $ANTLR start "caseExpression"
	// Hql.g:517:1: caseExpression : ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) );
	[GrammarRule("caseExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> caseExpression()
	{
		EnterRule_caseExpression();
		EnterRule("caseExpression", 59);
		TraceIn("caseExpression", 59);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken CASE207 = default(IToken);
	    IToken END210 = default(IToken);
	    IToken CASE211 = default(IToken);
	    IToken END215 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> whenClause208 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> elseClause209 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> unaryExpression212 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> altWhenClause213 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> elseClause214 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode CASE207_tree = default(IASTNode);
	    IASTNode END210_tree = default(IASTNode);
	    IASTNode CASE211_tree = default(IASTNode);
	    IASTNode END215_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
	    RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
	    RewriteRuleSubtreeStream stream_whenClause=new RewriteRuleSubtreeStream(adaptor,"rule whenClause");
	    RewriteRuleSubtreeStream stream_elseClause=new RewriteRuleSubtreeStream(adaptor,"rule elseClause");
	    RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
	    RewriteRuleSubtreeStream stream_altWhenClause=new RewriteRuleSubtreeStream(adaptor,"rule altWhenClause");
		try { DebugEnterRule(GrammarFileName, "caseExpression");
		DebugLocation(517, 1);
		try
		{
			// Hql.g:518:2: ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) )
			int alt79=2;
			try { DebugEnterDecision(79, decisionCanBacktrack[79]);
			int LA79_1 = input.LA(1);

			if ((LA79_1==CASE))
			{
				int LA79_2 = input.LA(2);

				if ((LA79_2==WHEN))
				{
					alt79 = 1;
				}
				else if ((LA79_2==ALL||LA79_2==ANY||LA79_2==AVG||LA79_2==CASE||LA79_2==COLON||LA79_2==COUNT||LA79_2==ELEMENTS||LA79_2==EMPTY||LA79_2==EXISTS||LA79_2==FALSE||LA79_2==IDENT||LA79_2==INDICES||LA79_2==MAX||(LA79_2>=MIN && LA79_2<=MINUS)||(LA79_2>=NULL && LA79_2<=NUM_LONG)||LA79_2==OPEN||(LA79_2>=PARAM && LA79_2<=PLUS)||LA79_2==QUOTED_String||LA79_2==SOME||LA79_2==SUM||LA79_2==TRUE))
				{
					alt79 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 79, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 79, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:518:4: CASE ( whenClause )+ ( elseClause )? END
				{
				DebugLocation(518, 4);
				CASE207=(IToken)Match(input,CASE,Follow._CASE_in_caseExpression2588);  
				stream_CASE.Add(CASE207);

				DebugLocation(518, 9);
				// Hql.g:518:9: ( whenClause )+
				int cnt75=0;
				try { DebugEnterSubRule(75);
				while (true)
				{
					int alt75=2;
					try { DebugEnterDecision(75, decisionCanBacktrack[75]);
					int LA75_1 = input.LA(1);

					if ((LA75_1==WHEN))
					{
						alt75 = 1;
					}


					} finally { DebugExitDecision(75); }
					switch (alt75)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:518:10: whenClause
						{
						DebugLocation(518, 10);
						PushFollow(Follow._whenClause_in_caseExpression2591);
						whenClause208=whenClause();
						PopFollow();

						stream_whenClause.Add(whenClause208.Tree);

						}
						break;

					default:
						if (cnt75 >= 1)
							goto loop75;

						EarlyExitException eee75 = new EarlyExitException( 75, input );
						DebugRecognitionException(eee75);
						throw eee75;
					}
					cnt75++;
				}
				loop75:
					;

				} finally { DebugExitSubRule(75); }

				DebugLocation(518, 23);
				// Hql.g:518:23: ( elseClause )?
				int alt76=2;
				try { DebugEnterSubRule(76);
				try { DebugEnterDecision(76, decisionCanBacktrack[76]);
				int LA76_1 = input.LA(1);

				if ((LA76_1==ELSE))
				{
					alt76 = 1;
				}
				} finally { DebugExitDecision(76); }
				switch (alt76)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:518:24: elseClause
					{
					DebugLocation(518, 24);
					PushFollow(Follow._elseClause_in_caseExpression2596);
					elseClause209=elseClause();
					PopFollow();

					stream_elseClause.Add(elseClause209.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(76); }

				DebugLocation(518, 37);
				END210=(IToken)Match(input,END,Follow._END_in_caseExpression2600);  
				stream_END.Add(END210);



				{
				// AST REWRITE
				// elements: CASE, whenClause, elseClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 519:3: -> ^( CASE ( whenClause )+ ( elseClause )? )
				{
					DebugLocation(519, 6);
					// Hql.g:519:6: ^( CASE ( whenClause )+ ( elseClause )? )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(519, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

					DebugLocation(519, 13);
					if (!(stream_whenClause.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_whenClause.HasNext )
					{
						DebugLocation(519, 13);
						adaptor.AddChild(root_1, stream_whenClause.NextTree());

					}
					stream_whenClause.Reset();
					DebugLocation(519, 25);
					// Hql.g:519:25: ( elseClause )?
					if (stream_elseClause.HasNext)
					{
						DebugLocation(519, 25);
						adaptor.AddChild(root_1, stream_elseClause.NextTree());

					}
					stream_elseClause.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:520:4: CASE unaryExpression ( altWhenClause )+ ( elseClause )? END
				{
				DebugLocation(520, 4);
				CASE211=(IToken)Match(input,CASE,Follow._CASE_in_caseExpression2620);  
				stream_CASE.Add(CASE211);

				DebugLocation(520, 9);
				PushFollow(Follow._unaryExpression_in_caseExpression2622);
				unaryExpression212=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(unaryExpression212.Tree);
				DebugLocation(520, 25);
				// Hql.g:520:25: ( altWhenClause )+
				int cnt77=0;
				try { DebugEnterSubRule(77);
				while (true)
				{
					int alt77=2;
					try { DebugEnterDecision(77, decisionCanBacktrack[77]);
					int LA77_1 = input.LA(1);

					if ((LA77_1==WHEN))
					{
						alt77 = 1;
					}


					} finally { DebugExitDecision(77); }
					switch (alt77)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:520:26: altWhenClause
						{
						DebugLocation(520, 26);
						PushFollow(Follow._altWhenClause_in_caseExpression2625);
						altWhenClause213=altWhenClause();
						PopFollow();

						stream_altWhenClause.Add(altWhenClause213.Tree);

						}
						break;

					default:
						if (cnt77 >= 1)
							goto loop77;

						EarlyExitException eee77 = new EarlyExitException( 77, input );
						DebugRecognitionException(eee77);
						throw eee77;
					}
					cnt77++;
				}
				loop77:
					;

				} finally { DebugExitSubRule(77); }

				DebugLocation(520, 42);
				// Hql.g:520:42: ( elseClause )?
				int alt78=2;
				try { DebugEnterSubRule(78);
				try { DebugEnterDecision(78, decisionCanBacktrack[78]);
				int LA78_1 = input.LA(1);

				if ((LA78_1==ELSE))
				{
					alt78 = 1;
				}
				} finally { DebugExitDecision(78); }
				switch (alt78)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:520:43: elseClause
					{
					DebugLocation(520, 43);
					PushFollow(Follow._elseClause_in_caseExpression2630);
					elseClause214=elseClause();
					PopFollow();

					stream_elseClause.Add(elseClause214.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(78); }

				DebugLocation(520, 56);
				END215=(IToken)Match(input,END,Follow._END_in_caseExpression2634);  
				stream_END.Add(END215);



				{
				// AST REWRITE
				// elements: unaryExpression, altWhenClause, elseClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 521:3: -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )
				{
					DebugLocation(521, 6);
					// Hql.g:521:6: ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(521, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CASE2, "CASE2"), root_1);

					DebugLocation(521, 14);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());
					DebugLocation(521, 30);
					if (!(stream_altWhenClause.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_altWhenClause.HasNext )
					{
						DebugLocation(521, 30);
						adaptor.AddChild(root_1, stream_altWhenClause.NextTree());

					}
					stream_altWhenClause.Reset();
					DebugLocation(521, 45);
					// Hql.g:521:45: ( elseClause )?
					if (stream_elseClause.HasNext)
					{
						DebugLocation(521, 45);
						adaptor.AddChild(root_1, stream_elseClause.NextTree());

					}
					stream_elseClause.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseExpression", 59);
			LeaveRule("caseExpression", 59);
			LeaveRule_caseExpression();
	    }
	 	DebugLocation(522, 1);
		} finally { DebugExitRule(GrammarFileName, "caseExpression"); }
		return retval;

	}
	// $ANTLR end "caseExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_whenClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_whenClause() {}
	// $ANTLR start "whenClause"
	// Hql.g:524:1: whenClause : ( WHEN ^ logicalExpression THEN ! expression ) ;
	[GrammarRule("whenClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> whenClause()
	{
		EnterRule_whenClause();
		EnterRule("whenClause", 60);
		TraceIn("whenClause", 60);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken WHEN216 = default(IToken);
	    IToken THEN218 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> logicalExpression217 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression219 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode WHEN216_tree = default(IASTNode);
	    IASTNode THEN218_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "whenClause");
		DebugLocation(524, 1);
		try
		{
			// Hql.g:525:2: ( ( WHEN ^ logicalExpression THEN ! expression ) )
			DebugEnterAlt(1);
			// Hql.g:525:4: ( WHEN ^ logicalExpression THEN ! expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(525, 4);
			// Hql.g:525:4: ( WHEN ^ logicalExpression THEN ! expression )
			DebugEnterAlt(1);
			// Hql.g:525:5: WHEN ^ logicalExpression THEN ! expression
			{
			DebugLocation(525, 9);
			WHEN216=(IToken)Match(input,WHEN,Follow._WHEN_in_whenClause2663); 
			WHEN216_tree = (IASTNode)adaptor.Create(WHEN216);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHEN216_tree, root_0);

			DebugLocation(525, 11);
			PushFollow(Follow._logicalExpression_in_whenClause2666);
			logicalExpression217=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression217.Tree);
			DebugLocation(525, 33);
			THEN218=(IToken)Match(input,THEN,Follow._THEN_in_whenClause2668); 
			DebugLocation(525, 35);
			PushFollow(Follow._expression_in_whenClause2671);
			expression219=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression219.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whenClause", 60);
			LeaveRule("whenClause", 60);
			LeaveRule_whenClause();
	    }
	 	DebugLocation(526, 1);
		} finally { DebugExitRule(GrammarFileName, "whenClause"); }
		return retval;

	}
	// $ANTLR end "whenClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_altWhenClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_altWhenClause() {}
	// $ANTLR start "altWhenClause"
	// Hql.g:528:1: altWhenClause : ( WHEN ^ unaryExpression THEN ! expression ) ;
	[GrammarRule("altWhenClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> altWhenClause()
	{
		EnterRule_altWhenClause();
		EnterRule("altWhenClause", 61);
		TraceIn("altWhenClause", 61);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken WHEN220 = default(IToken);
	    IToken THEN222 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> unaryExpression221 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression223 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode WHEN220_tree = default(IASTNode);
	    IASTNode THEN222_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "altWhenClause");
		DebugLocation(528, 1);
		try
		{
			// Hql.g:529:2: ( ( WHEN ^ unaryExpression THEN ! expression ) )
			DebugEnterAlt(1);
			// Hql.g:529:4: ( WHEN ^ unaryExpression THEN ! expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(529, 4);
			// Hql.g:529:4: ( WHEN ^ unaryExpression THEN ! expression )
			DebugEnterAlt(1);
			// Hql.g:529:5: WHEN ^ unaryExpression THEN ! expression
			{
			DebugLocation(529, 9);
			WHEN220=(IToken)Match(input,WHEN,Follow._WHEN_in_altWhenClause2685); 
			WHEN220_tree = (IASTNode)adaptor.Create(WHEN220);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHEN220_tree, root_0);

			DebugLocation(529, 11);
			PushFollow(Follow._unaryExpression_in_altWhenClause2688);
			unaryExpression221=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression221.Tree);
			DebugLocation(529, 31);
			THEN222=(IToken)Match(input,THEN,Follow._THEN_in_altWhenClause2690); 
			DebugLocation(529, 33);
			PushFollow(Follow._expression_in_altWhenClause2693);
			expression223=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression223.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("altWhenClause", 61);
			LeaveRule("altWhenClause", 61);
			LeaveRule_altWhenClause();
	    }
	 	DebugLocation(530, 1);
		} finally { DebugExitRule(GrammarFileName, "altWhenClause"); }
		return retval;

	}
	// $ANTLR end "altWhenClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_elseClause() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_elseClause() {}
	// $ANTLR start "elseClause"
	// Hql.g:532:1: elseClause : ( ELSE ^ expression ) ;
	[GrammarRule("elseClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> elseClause()
	{
		EnterRule_elseClause();
		EnterRule("elseClause", 62);
		TraceIn("elseClause", 62);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken ELSE224 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> expression225 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode ELSE224_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "elseClause");
		DebugLocation(532, 1);
		try
		{
			// Hql.g:533:2: ( ( ELSE ^ expression ) )
			DebugEnterAlt(1);
			// Hql.g:533:4: ( ELSE ^ expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(533, 4);
			// Hql.g:533:4: ( ELSE ^ expression )
			DebugEnterAlt(1);
			// Hql.g:533:5: ELSE ^ expression
			{
			DebugLocation(533, 9);
			ELSE224=(IToken)Match(input,ELSE,Follow._ELSE_in_elseClause2707); 
			ELSE224_tree = (IASTNode)adaptor.Create(ELSE224);
			root_0 = (IASTNode)adaptor.BecomeRoot(ELSE224_tree, root_0);

			DebugLocation(533, 11);
			PushFollow(Follow._expression_in_elseClause2710);
			expression225=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression225.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elseClause", 62);
			LeaveRule("elseClause", 62);
			LeaveRule_elseClause();
	    }
	 	DebugLocation(534, 1);
		} finally { DebugExitRule(GrammarFileName, "elseClause"); }
		return retval;

	}
	// $ANTLR end "elseClause"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_quantifiedExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_quantifiedExpression() {}
	// $ANTLR start "quantifiedExpression"
	// Hql.g:536:1: quantifiedExpression : ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) ) ;
	[GrammarRule("quantifiedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> quantifiedExpression()
	{
		EnterRule_quantifiedExpression();
		EnterRule("quantifiedExpression", 63);
		TraceIn("quantifiedExpression", 63);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken SOME226 = default(IToken);
	    IToken EXISTS227 = default(IToken);
	    IToken ALL228 = default(IToken);
	    IToken ANY229 = default(IToken);
	    IToken OPEN232 = default(IToken);
	    IToken CLOSE234 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier230 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> collectionExpr231 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> subQuery233 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode SOME226_tree = default(IASTNode);
	    IASTNode EXISTS227_tree = default(IASTNode);
	    IASTNode ALL228_tree = default(IASTNode);
	    IASTNode ANY229_tree = default(IASTNode);
	    IASTNode OPEN232_tree = default(IASTNode);
	    IASTNode CLOSE234_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "quantifiedExpression");
		DebugLocation(536, 1);
		try
		{
			// Hql.g:537:2: ( ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) ) )
			DebugEnterAlt(1);
			// Hql.g:537:4: ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(537, 4);
			// Hql.g:537:4: ( SOME ^| EXISTS ^| ALL ^| ANY ^)
			int alt80=4;
			try { DebugEnterSubRule(80);
			try { DebugEnterDecision(80, decisionCanBacktrack[80]);
			switch (input.LA(1))
			{
			case SOME:
				{
				alt80 = 1;
				}
				break;
			case EXISTS:
				{
				alt80 = 2;
				}
				break;
			case ALL:
				{
				alt80 = 3;
				}
				break;
			case ANY:
				{
				alt80 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 80, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:537:6: SOME ^
				{
				DebugLocation(537, 10);
				SOME226=(IToken)Match(input,SOME,Follow._SOME_in_quantifiedExpression2725); 
				SOME226_tree = (IASTNode)adaptor.Create(SOME226);
				root_0 = (IASTNode)adaptor.BecomeRoot(SOME226_tree, root_0);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:537:14: EXISTS ^
				{
				DebugLocation(537, 20);
				EXISTS227=(IToken)Match(input,EXISTS,Follow._EXISTS_in_quantifiedExpression2730); 
				EXISTS227_tree = (IASTNode)adaptor.Create(EXISTS227);
				root_0 = (IASTNode)adaptor.BecomeRoot(EXISTS227_tree, root_0);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:537:24: ALL ^
				{
				DebugLocation(537, 27);
				ALL228=(IToken)Match(input,ALL,Follow._ALL_in_quantifiedExpression2735); 
				ALL228_tree = (IASTNode)adaptor.Create(ALL228);
				root_0 = (IASTNode)adaptor.BecomeRoot(ALL228_tree, root_0);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:537:31: ANY ^
				{
				DebugLocation(537, 34);
				ANY229=(IToken)Match(input,ANY,Follow._ANY_in_quantifiedExpression2740); 
				ANY229_tree = (IASTNode)adaptor.Create(ANY229);
				root_0 = (IASTNode)adaptor.BecomeRoot(ANY229_tree, root_0);


				}
				break;

			}
			} finally { DebugExitSubRule(80); }

			DebugLocation(538, 2);
			// Hql.g:538:2: ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) )
			int alt81=3;
			try { DebugEnterSubRule(81);
			try { DebugEnterDecision(81, decisionCanBacktrack[81]);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt81 = 1;
				}
				break;
			case ELEMENTS:
			case INDICES:
				{
				alt81 = 2;
				}
				break;
			case OPEN:
				{
				alt81 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 81, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:538:4: identifier
				{
				DebugLocation(538, 4);
				PushFollow(Follow._identifier_in_quantifiedExpression2749);
				identifier230=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier230.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:538:17: collectionExpr
				{
				DebugLocation(538, 17);
				PushFollow(Follow._collectionExpr_in_quantifiedExpression2753);
				collectionExpr231=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr231.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:538:34: ( OPEN ! ( subQuery ) CLOSE !)
				{
				DebugLocation(538, 34);
				// Hql.g:538:34: ( OPEN ! ( subQuery ) CLOSE !)
				DebugEnterAlt(1);
				// Hql.g:538:35: OPEN ! ( subQuery ) CLOSE !
				{
				DebugLocation(538, 39);
				OPEN232=(IToken)Match(input,OPEN,Follow._OPEN_in_quantifiedExpression2758); 
				DebugLocation(538, 41);
				// Hql.g:538:41: ( subQuery )
				DebugEnterAlt(1);
				// Hql.g:538:43: subQuery
				{
				DebugLocation(538, 43);
				PushFollow(Follow._subQuery_in_quantifiedExpression2763);
				subQuery233=subQuery();
				PopFollow();

				adaptor.AddChild(root_0, subQuery233.Tree);

				}

				DebugLocation(538, 59);
				CLOSE234=(IToken)Match(input,CLOSE,Follow._CLOSE_in_quantifiedExpression2767); 

				}


				}
				break;

			}
			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifiedExpression", 63);
			LeaveRule("quantifiedExpression", 63);
			LeaveRule_quantifiedExpression();
	    }
	 	DebugLocation(539, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifiedExpression"); }
		return retval;

	}
	// $ANTLR end "quantifiedExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}
	// $ANTLR start "atom"
	// Hql.g:544:1: atom : primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)* ;
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<IASTNode, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 64);
		TraceIn("atom", 64);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken op = default(IToken);
	    IToken lb = default(IToken);
	    IToken DOT236 = default(IToken);
	    IToken CLOSE239 = default(IToken);
	    IToken CLOSE_BRACKET241 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> primaryExpression235 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier237 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> exprList238 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression240 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode op_tree = default(IASTNode);
	    IASTNode lb_tree = default(IASTNode);
	    IASTNode DOT236_tree = default(IASTNode);
	    IASTNode CLOSE239_tree = default(IASTNode);
	    IASTNode CLOSE_BRACKET241_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(544, 1);
		try
		{
			// Hql.g:545:3: ( primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)* )
			DebugEnterAlt(1);
			// Hql.g:545:5: primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(545, 5);
			PushFollow(Follow._primaryExpression_in_atom2786);
			primaryExpression235=primaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, primaryExpression235.Tree);
			DebugLocation(546, 3);
			// Hql.g:546:3: ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=3;
				try { DebugEnterDecision(83, decisionCanBacktrack[83]);
				int LA83_1 = input.LA(1);

				if ((LA83_1==DOT))
				{
					alt83 = 1;
				}
				else if ((LA83_1==OPEN_BRACKET))
				{
					alt83 = 2;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:547:4: DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )?
					{
					DebugLocation(547, 7);
					DOT236=(IToken)Match(input,DOT,Follow._DOT_in_atom2795); 
					DOT236_tree = (IASTNode)adaptor.Create(DOT236);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT236_tree, root_0);

					DebugLocation(547, 9);
					PushFollow(Follow._identifier_in_atom2798);
					identifier237=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier237.Tree);
					DebugLocation(548, 5);
					// Hql.g:548:5: ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )?
					int alt82=2;
					try { DebugEnterSubRule(82);
					try { DebugEnterDecision(82, decisionCanBacktrack[82]);
					int LA82_1 = input.LA(1);

					if ((LA82_1==OPEN))
					{
						alt82 = 1;
					}
					} finally { DebugExitDecision(82); }
					switch (alt82)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:549:6: (op= OPEN ^ exprList CLOSE !)
						{
						DebugLocation(549, 6);
						// Hql.g:549:6: (op= OPEN ^ exprList CLOSE !)
						DebugEnterAlt(1);
						// Hql.g:549:8: op= OPEN ^ exprList CLOSE !
						{
						DebugLocation(549, 10);
						op=(IToken)Match(input,OPEN,Follow._OPEN_in_atom2826); 
						op_tree = (IASTNode)adaptor.Create(op);
						root_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);

						DebugLocation(549, 17);
						op.Type = METHOD_CALL; 
						DebugLocation(549, 44);
						PushFollow(Follow._exprList_in_atom2831);
						exprList238=exprList();
						PopFollow();

						adaptor.AddChild(root_0, exprList238.Tree);
						DebugLocation(549, 58);
						CLOSE239=(IToken)Match(input,CLOSE,Follow._CLOSE_in_atom2833); 

						}


						}
						break;

					}
					} finally { DebugExitSubRule(82); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:550:5: lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !
					{
					DebugLocation(550, 7);
					lb=(IToken)Match(input,OPEN_BRACKET,Follow._OPEN_BRACKET_in_atom2847); 
					lb_tree = (IASTNode)adaptor.Create(lb);
					root_0 = (IASTNode)adaptor.BecomeRoot(lb_tree, root_0);

					DebugLocation(550, 22);
					lb.Type = INDEX_OP; 
					DebugLocation(550, 46);
					PushFollow(Follow._expression_in_atom2852);
					expression240=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression240.Tree);
					DebugLocation(550, 70);
					CLOSE_BRACKET241=(IToken)Match(input,CLOSE_BRACKET,Follow._CLOSE_BRACKET_in_atom2854); 

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 64);
			LeaveRule("atom", 64);
			LeaveRule_atom();
	    }
	 	DebugLocation(552, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_primaryExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_primaryExpression() {}
	// $ANTLR start "primaryExpression"
	// Hql.g:555:1: primaryExpression : ( identPrimary ( options {greedy=true; } : DOT ^ 'class' )? | constant | COLON ^ identifier | OPEN ! ( expressionOrVector | subQuery ) CLOSE !| PARAM ^ ( NUM_INT )? );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 65);
		TraceIn("primaryExpression", 65);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken DOT243 = default(IToken);
	    IToken string_literal244 = default(IToken);
	    IToken COLON246 = default(IToken);
	    IToken OPEN248 = default(IToken);
	    IToken CLOSE251 = default(IToken);
	    IToken PARAM252 = default(IToken);
	    IToken NUM_INT253 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> identPrimary242 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> constant245 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier247 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expressionOrVector249 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> subQuery250 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode DOT243_tree = default(IASTNode);
	    IASTNode string_literal244_tree = default(IASTNode);
	    IASTNode COLON246_tree = default(IASTNode);
	    IASTNode OPEN248_tree = default(IASTNode);
	    IASTNode CLOSE251_tree = default(IASTNode);
	    IASTNode PARAM252_tree = default(IASTNode);
	    IASTNode NUM_INT253_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(555, 1);
		try
		{
			// Hql.g:556:2: ( identPrimary ( options {greedy=true; } : DOT ^ 'class' )? | constant | COLON ^ identifier | OPEN ! ( expressionOrVector | subQuery ) CLOSE !| PARAM ^ ( NUM_INT )? )
			int alt87=5;
			try { DebugEnterDecision(87, decisionCanBacktrack[87]);
			switch (input.LA(1))
			{
			case AVG:
			case COUNT:
			case ELEMENTS:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case SUM:
				{
				alt87 = 1;
				}
				break;
			case EMPTY:
			case FALSE:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case QUOTED_String:
			case TRUE:
				{
				alt87 = 2;
				}
				break;
			case COLON:
				{
				alt87 = 3;
				}
				break;
			case OPEN:
				{
				alt87 = 4;
				}
				break;
			case PARAM:
				{
				alt87 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 87, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(87); }
			switch (alt87)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:556:6: identPrimary ( options {greedy=true; } : DOT ^ 'class' )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(556, 6);
				PushFollow(Follow._identPrimary_in_primaryExpression2874);
				identPrimary242=identPrimary();
				PopFollow();

				adaptor.AddChild(root_0, identPrimary242.Tree);
				DebugLocation(556, 19);
				// Hql.g:556:19: ( options {greedy=true; } : DOT ^ 'class' )?
				int alt84=2;
				try { DebugEnterSubRule(84);
				try { DebugEnterDecision(84, decisionCanBacktrack[84]);
				int LA84_1 = input.LA(1);

				if ((LA84_1==DOT))
				{
					int LA84_2 = input.LA(2);

					if ((LA84_2==CLASS))
					{
						alt84 = 1;
					}
				}
				} finally { DebugExitDecision(84); }
				switch (alt84)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:556:46: DOT ^ 'class'
					{
					DebugLocation(556, 49);
					DOT243=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpression2887); 
					DOT243_tree = (IASTNode)adaptor.Create(DOT243);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT243_tree, root_0);

					DebugLocation(556, 51);
					string_literal244=(IToken)Match(input,CLASS,Follow._CLASS_in_primaryExpression2890); 
					string_literal244_tree = (IASTNode)adaptor.Create(string_literal244);
					adaptor.AddChild(root_0, string_literal244_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(84); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:557:6: constant
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(557, 6);
				PushFollow(Follow._constant_in_primaryExpression2900);
				constant245=constant();
				PopFollow();

				adaptor.AddChild(root_0, constant245.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:558:6: COLON ^ identifier
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(558, 11);
				COLON246=(IToken)Match(input,COLON,Follow._COLON_in_primaryExpression2907); 
				COLON246_tree = (IASTNode)adaptor.Create(COLON246);
				root_0 = (IASTNode)adaptor.BecomeRoot(COLON246_tree, root_0);

				DebugLocation(558, 13);
				PushFollow(Follow._identifier_in_primaryExpression2910);
				identifier247=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier247.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:560:6: OPEN ! ( expressionOrVector | subQuery ) CLOSE !
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(560, 10);
				OPEN248=(IToken)Match(input,OPEN,Follow._OPEN_in_primaryExpression2919); 
				DebugLocation(560, 12);
				// Hql.g:560:12: ( expressionOrVector | subQuery )
				int alt85=2;
				try { DebugEnterSubRule(85);
				try { DebugEnterDecision(85, decisionCanBacktrack[85]);
				int LA85_1 = input.LA(1);

				if ((LA85_1==ALL||LA85_1==ANY||LA85_1==AVG||LA85_1==BNOT||LA85_1==CASE||LA85_1==COLON||LA85_1==COUNT||LA85_1==ELEMENTS||LA85_1==EMPTY||LA85_1==EXISTS||LA85_1==FALSE||LA85_1==IDENT||LA85_1==INDICES||LA85_1==MAX||(LA85_1>=MIN && LA85_1<=MINUS)||LA85_1==NOT||(LA85_1>=NULL && LA85_1<=NUM_LONG)||LA85_1==OPEN||(LA85_1>=PARAM && LA85_1<=PLUS)||LA85_1==QUOTED_String||LA85_1==SOME||LA85_1==SUM||LA85_1==TRUE))
				{
					alt85 = 1;
				}
				else if ((LA85_1==EOF||LA85_1==CLOSE||LA85_1==FROM||LA85_1==GROUP||LA85_1==HAVING||LA85_1==ORDER||LA85_1==SELECT||LA85_1==SKIP||LA85_1==TAKE||LA85_1==UNION||LA85_1==WHERE))
				{
					alt85 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 85, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(85); }
				switch (alt85)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:560:13: expressionOrVector
					{
					DebugLocation(560, 13);
					PushFollow(Follow._expressionOrVector_in_primaryExpression2923);
					expressionOrVector249=expressionOrVector();
					PopFollow();

					adaptor.AddChild(root_0, expressionOrVector249.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:560:34: subQuery
					{
					DebugLocation(560, 34);
					PushFollow(Follow._subQuery_in_primaryExpression2927);
					subQuery250=subQuery();
					PopFollow();

					adaptor.AddChild(root_0, subQuery250.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(85); }

				DebugLocation(560, 49);
				CLOSE251=(IToken)Match(input,CLOSE,Follow._CLOSE_in_primaryExpression2930); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Hql.g:561:6: PARAM ^ ( NUM_INT )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(561, 11);
				PARAM252=(IToken)Match(input,PARAM,Follow._PARAM_in_primaryExpression2938); 
				PARAM252_tree = (IASTNode)adaptor.Create(PARAM252);
				root_0 = (IASTNode)adaptor.BecomeRoot(PARAM252_tree, root_0);

				DebugLocation(561, 13);
				// Hql.g:561:13: ( NUM_INT )?
				int alt86=2;
				try { DebugEnterSubRule(86);
				try { DebugEnterDecision(86, decisionCanBacktrack[86]);
				int LA86_1 = input.LA(1);

				if ((LA86_1==NUM_INT))
				{
					alt86 = 1;
				}
				} finally { DebugExitDecision(86); }
				switch (alt86)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:561:14: NUM_INT
					{
					DebugLocation(561, 14);
					NUM_INT253=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_primaryExpression2942); 
					NUM_INT253_tree = (IASTNode)adaptor.Create(NUM_INT253);
					adaptor.AddChild(root_0, NUM_INT253_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(86); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 65);
			LeaveRule("primaryExpression", 65);
			LeaveRule_primaryExpression();
	    }
	 	DebugLocation(562, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expressionOrVector() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expressionOrVector() {}
	// $ANTLR start "expressionOrVector"
	// Hql.g:566:1: expressionOrVector : e= expression (v= vectorExpr )? -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v) -> ^( $e) ;
	[GrammarRule("expressionOrVector")]
	private AstParserRuleReturnScope<IASTNode, IToken> expressionOrVector()
	{
		EnterRule_expressionOrVector();
		EnterRule("expressionOrVector", 66);
		TraceIn("expressionOrVector", 66);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> e = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> v = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
	    RewriteRuleSubtreeStream stream_vectorExpr=new RewriteRuleSubtreeStream(adaptor,"rule vectorExpr");
		try { DebugEnterRule(GrammarFileName, "expressionOrVector");
		DebugLocation(566, 1);
		try
		{
			// Hql.g:567:2: (e= expression (v= vectorExpr )? -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v) -> ^( $e) )
			DebugEnterAlt(1);
			// Hql.g:567:4: e= expression (v= vectorExpr )?
			{
			DebugLocation(567, 5);
			PushFollow(Follow._expression_in_expressionOrVector2960);
			e=expression();
			PopFollow();

			stream_expression.Add(e.Tree);
			DebugLocation(567, 17);
			// Hql.g:567:17: (v= vectorExpr )?
			int alt88=2;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, decisionCanBacktrack[88]);
			int LA88_1 = input.LA(1);

			if ((LA88_1==COMMA))
			{
				alt88 = 1;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:567:19: v= vectorExpr
				{
				DebugLocation(567, 20);
				PushFollow(Follow._vectorExpr_in_expressionOrVector2966);
				v=vectorExpr();
				PopFollow();

				stream_vectorExpr.Add(v.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(88); }



			{
			// AST REWRITE
			// elements: e, v, e
			// token labels: 
			// rule labels: e, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.Tree:null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 568:2: -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v)
			if (v != null)
			{
				DebugLocation(568, 18);
				// Hql.g:568:18: ^( VECTOR_EXPR[\"{vector}\"] $e $v)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(568, 20);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(VECTOR_EXPR, "{vector}"), root_1);

				DebugLocation(568, 45);
				adaptor.AddChild(root_1, stream_e.NextTree());
				DebugLocation(568, 48);
				adaptor.AddChild(root_1, stream_v.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 569:2: -> ^( $e)
			{
				DebugLocation(569, 5);
				// Hql.g:569:5: ^( $e)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(569, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot(stream_e.NextNode(), root_1);

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionOrVector", 66);
			LeaveRule("expressionOrVector", 66);
			LeaveRule_expressionOrVector();
	    }
	 	DebugLocation(570, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionOrVector"); }
		return retval;

	}
	// $ANTLR end "expressionOrVector"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_vectorExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_vectorExpr() {}
	// $ANTLR start "vectorExpr"
	// Hql.g:572:1: vectorExpr : COMMA ! expression ( COMMA ! expression )* ;
	[GrammarRule("vectorExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> vectorExpr()
	{
		EnterRule_vectorExpr();
		EnterRule("vectorExpr", 67);
		TraceIn("vectorExpr", 67);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken COMMA254 = default(IToken);
	    IToken COMMA256 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> expression255 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression257 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode COMMA254_tree = default(IASTNode);
	    IASTNode COMMA256_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "vectorExpr");
		DebugLocation(572, 1);
		try
		{
			// Hql.g:573:2: ( COMMA ! expression ( COMMA ! expression )* )
			DebugEnterAlt(1);
			// Hql.g:573:4: COMMA ! expression ( COMMA ! expression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(573, 9);
			COMMA254=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorExpr3005); 
			DebugLocation(573, 11);
			PushFollow(Follow._expression_in_vectorExpr3008);
			expression255=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression255.Tree);
			DebugLocation(573, 22);
			// Hql.g:573:22: ( COMMA ! expression )*
			try { DebugEnterSubRule(89);
			while (true)
			{
				int alt89=2;
				try { DebugEnterDecision(89, decisionCanBacktrack[89]);
				int LA89_1 = input.LA(1);

				if ((LA89_1==COMMA))
				{
					alt89 = 1;
				}


				} finally { DebugExitDecision(89); }
				switch ( alt89 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:573:23: COMMA ! expression
					{
					DebugLocation(573, 28);
					COMMA256=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorExpr3011); 
					DebugLocation(573, 30);
					PushFollow(Follow._expression_in_vectorExpr3014);
					expression257=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression257.Tree);

					}
					break;

				default:
					goto loop89;
				}
			}

			loop89:
				;

			} finally { DebugExitSubRule(89); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vectorExpr", 67);
			LeaveRule("vectorExpr", 67);
			LeaveRule_vectorExpr();
	    }
	 	DebugLocation(574, 1);
		} finally { DebugExitRule(GrammarFileName, "vectorExpr"); }
		return retval;

	}
	// $ANTLR end "vectorExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_identPrimary() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_identPrimary() {}
	// $ANTLR start "identPrimary"
	// Hql.g:579:1: identPrimary : ( identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )? | aggregate );
	[GrammarRule("identPrimary")]
	private AstParserRuleReturnScope<IASTNode, IToken> identPrimary()
	{
		EnterRule_identPrimary();
		EnterRule("identPrimary", 68);
		TraceIn("identPrimary", 68);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken o = default(IToken);
	    IToken op = default(IToken);
	    IToken DOT259 = default(IToken);
	    IToken CLOSE262 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier258 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier260 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> exprList261 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> aggregate263 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode o_tree = default(IASTNode);
	    IASTNode op_tree = default(IASTNode);
	    IASTNode DOT259_tree = default(IASTNode);
	    IASTNode CLOSE262_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "identPrimary");
		DebugLocation(579, 1);
		try
		{
			// Hql.g:580:2: ( identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )? | aggregate )
			int alt93=2;
			try { DebugEnterDecision(93, decisionCanBacktrack[93]);
			int LA93_1 = input.LA(1);

			if ((LA93_1==IDENT))
			{
				alt93 = 1;
			}
			else if ((LA93_1==AVG||LA93_1==COUNT||LA93_1==ELEMENTS||LA93_1==INDICES||LA93_1==MAX||LA93_1==MIN||LA93_1==SUM))
			{
				alt93 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 93, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(93); }
			switch (alt93)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:580:4: identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(580, 4);
				PushFollow(Follow._identifier_in_identPrimary3030);
				identifier258=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier258.Tree);
				DebugLocation(580, 15);
				 HandleDotIdent(); 
				DebugLocation(581, 4);
				// Hql.g:581:4: ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )*
				try { DebugEnterSubRule(91);
				while (true)
				{
					int alt91=2;
					try { DebugEnterDecision(91, decisionCanBacktrack[91]);
					int LA91_1 = input.LA(1);

					if ((LA91_1==DOT))
					{
						int LA91_2 = input.LA(2);

						if ((LA91_2==IDENT||LA91_2==OBJECT))
						{
							alt91 = 1;
						}


					}


					} finally { DebugExitDecision(91); }
					switch ( alt91 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:581:31: DOT ^ ( identifier |o= OBJECT )
						{
						DebugLocation(581, 34);
						DOT259=(IToken)Match(input,DOT,Follow._DOT_in_identPrimary3048); 
						DOT259_tree = (IASTNode)adaptor.Create(DOT259);
						root_0 = (IASTNode)adaptor.BecomeRoot(DOT259_tree, root_0);

						DebugLocation(581, 36);
						// Hql.g:581:36: ( identifier |o= OBJECT )
						int alt90=2;
						try { DebugEnterSubRule(90);
						try { DebugEnterDecision(90, decisionCanBacktrack[90]);
						int LA90_1 = input.LA(1);

						if ((LA90_1==IDENT))
						{
							alt90 = 1;
						}
						else if ((LA90_1==OBJECT))
						{
							alt90 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 90, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(90); }
						switch (alt90)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:581:38: identifier
							{
							DebugLocation(581, 38);
							PushFollow(Follow._identifier_in_identPrimary3053);
							identifier260=identifier();
							PopFollow();

							adaptor.AddChild(root_0, identifier260.Tree);

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Hql.g:581:51: o= OBJECT
							{
							DebugLocation(581, 52);
							o=(IToken)Match(input,OBJECT,Follow._OBJECT_in_identPrimary3059); 
							o_tree = (IASTNode)adaptor.Create(o);
							adaptor.AddChild(root_0, o_tree);

							DebugLocation(581, 60);
							 o.Type = IDENT; 

							}
							break;

						}
						} finally { DebugExitSubRule(90); }


						}
						break;

					default:
						goto loop91;
					}
				}

				loop91:
					;

				} finally { DebugExitSubRule(91); }

				DebugLocation(582, 4);
				// Hql.g:582:4: ( (op= OPEN ^ exprList CLOSE !) )?
				int alt92=2;
				try { DebugEnterSubRule(92);
				try { DebugEnterDecision(92, decisionCanBacktrack[92]);
				int LA92_1 = input.LA(1);

				if ((LA92_1==OPEN))
				{
					alt92 = 1;
				}
				} finally { DebugExitDecision(92); }
				switch (alt92)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:582:6: (op= OPEN ^ exprList CLOSE !)
					{
					DebugLocation(582, 6);
					// Hql.g:582:6: (op= OPEN ^ exprList CLOSE !)
					DebugEnterAlt(1);
					// Hql.g:582:8: op= OPEN ^ exprList CLOSE !
					{
					DebugLocation(582, 10);
					op=(IToken)Match(input,OPEN,Follow._OPEN_in_identPrimary3077); 
					op_tree = (IASTNode)adaptor.Create(op);
					root_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);

					DebugLocation(582, 17);
					 op.Type = METHOD_CALL;
					DebugLocation(582, 44);
					PushFollow(Follow._exprList_in_identPrimary3082);
					exprList261=exprList();
					PopFollow();

					adaptor.AddChild(root_0, exprList261.Tree);
					DebugLocation(582, 58);
					CLOSE262=(IToken)Match(input,CLOSE,Follow._CLOSE_in_identPrimary3084); 

					}


					}
					break;

				}
				} finally { DebugExitSubRule(92); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:585:4: aggregate
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(585, 4);
				PushFollow(Follow._aggregate_in_identPrimary3100);
				aggregate263=aggregate();
				PopFollow();

				adaptor.AddChild(root_0, aggregate263.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identPrimary", 68);
			LeaveRule("identPrimary", 68);
			LeaveRule_identPrimary();
	    }
	 	DebugLocation(586, 1);
		} finally { DebugExitRule(GrammarFileName, "identPrimary"); }
		return retval;

	}
	// $ANTLR end "identPrimary"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_aggregate() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_aggregate() {}
	// $ANTLR start "aggregate"
	// Hql.g:593:1: aggregate : ( (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE -> ^( AGGREGATE[$op] additiveExpression ) | COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE -> {s == null}? ^( COUNT $p) -> ^( COUNT ^( ROW_STAR[\"*\"] ) ) | collectionExpr );
	[GrammarRule("aggregate")]
	private AstParserRuleReturnScope<IASTNode, IToken> aggregate()
	{
		EnterRule_aggregate();
		EnterRule("aggregate", 69);
		TraceIn("aggregate", 69);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken op = default(IToken);
	    IToken s = default(IToken);
	    IToken OPEN264 = default(IToken);
	    IToken CLOSE266 = default(IToken);
	    IToken COUNT267 = default(IToken);
	    IToken OPEN268 = default(IToken);
	    IToken CLOSE269 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> p = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> additiveExpression265 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> collectionExpr270 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode op_tree = default(IASTNode);
	    IASTNode s_tree = default(IASTNode);
	    IASTNode OPEN264_tree = default(IASTNode);
	    IASTNode CLOSE266_tree = default(IASTNode);
	    IASTNode COUNT267_tree = default(IASTNode);
	    IASTNode OPEN268_tree = default(IASTNode);
	    IASTNode CLOSE269_tree = default(IASTNode);
	    RewriteRuleITokenStream stream_SUM=new RewriteRuleITokenStream(adaptor,"token SUM");
	    RewriteRuleITokenStream stream_AVG=new RewriteRuleITokenStream(adaptor,"token AVG");
	    RewriteRuleITokenStream stream_MAX=new RewriteRuleITokenStream(adaptor,"token MAX");
	    RewriteRuleITokenStream stream_MIN=new RewriteRuleITokenStream(adaptor,"token MIN");
	    RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
	    RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
	    RewriteRuleITokenStream stream_COUNT=new RewriteRuleITokenStream(adaptor,"token COUNT");
	    RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
	    RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
	    RewriteRuleSubtreeStream stream_aggregateDistinctAll=new RewriteRuleSubtreeStream(adaptor,"rule aggregateDistinctAll");
		try { DebugEnterRule(GrammarFileName, "aggregate");
		DebugLocation(593, 1);
		try
		{
			// Hql.g:594:2: ( (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE -> ^( AGGREGATE[$op] additiveExpression ) | COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE -> {s == null}? ^( COUNT $p) -> ^( COUNT ^( ROW_STAR[\"*\"] ) ) | collectionExpr )
			int alt96=3;
			try { DebugEnterDecision(96, decisionCanBacktrack[96]);
			switch (input.LA(1))
			{
			case AVG:
			case MAX:
			case MIN:
			case SUM:
				{
				alt96 = 1;
				}
				break;
			case COUNT:
				{
				alt96 = 2;
				}
				break;
			case ELEMENTS:
			case INDICES:
				{
				alt96 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 96, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:594:4: (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE
				{
				DebugLocation(594, 4);
				// Hql.g:594:4: (op= SUM |op= AVG |op= MAX |op= MIN )
				int alt94=4;
				try { DebugEnterSubRule(94);
				try { DebugEnterDecision(94, decisionCanBacktrack[94]);
				switch (input.LA(1))
				{
				case SUM:
					{
					alt94 = 1;
					}
					break;
				case AVG:
					{
					alt94 = 2;
					}
					break;
				case MAX:
					{
					alt94 = 3;
					}
					break;
				case MIN:
					{
					alt94 = 4;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 94, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(94); }
				switch (alt94)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:594:6: op= SUM
					{
					DebugLocation(594, 8);
					op=(IToken)Match(input,SUM,Follow._SUM_in_aggregate3121);  
					stream_SUM.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:594:15: op= AVG
					{
					DebugLocation(594, 17);
					op=(IToken)Match(input,AVG,Follow._AVG_in_aggregate3127);  
					stream_AVG.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:594:24: op= MAX
					{
					DebugLocation(594, 26);
					op=(IToken)Match(input,MAX,Follow._MAX_in_aggregate3133);  
					stream_MAX.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Hql.g:594:33: op= MIN
					{
					DebugLocation(594, 35);
					op=(IToken)Match(input,MIN,Follow._MIN_in_aggregate3139);  
					stream_MIN.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(94); }

				DebugLocation(594, 42);
				OPEN264=(IToken)Match(input,OPEN,Follow._OPEN_in_aggregate3143);  
				stream_OPEN.Add(OPEN264);

				DebugLocation(594, 47);
				PushFollow(Follow._additiveExpression_in_aggregate3145);
				additiveExpression265=additiveExpression();
				PopFollow();

				stream_additiveExpression.Add(additiveExpression265.Tree);
				DebugLocation(594, 66);
				CLOSE266=(IToken)Match(input,CLOSE,Follow._CLOSE_in_aggregate3147);  
				stream_CLOSE.Add(CLOSE266);



				{
				// AST REWRITE
				// elements: additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 595:3: -> ^( AGGREGATE[$op] additiveExpression )
				{
					DebugLocation(595, 6);
					// Hql.g:595:6: ^( AGGREGATE[$op] additiveExpression )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(595, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(AGGREGATE, op), root_1);

					DebugLocation(595, 23);
					adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:597:5: COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE
				{
				DebugLocation(597, 5);
				COUNT267=(IToken)Match(input,COUNT,Follow._COUNT_in_aggregate3166);  
				stream_COUNT.Add(COUNT267);

				DebugLocation(597, 11);
				OPEN268=(IToken)Match(input,OPEN,Follow._OPEN_in_aggregate3168);  
				stream_OPEN.Add(OPEN268);

				DebugLocation(597, 16);
				// Hql.g:597:16: (s= STAR |p= aggregateDistinctAll )
				int alt95=2;
				try { DebugEnterSubRule(95);
				try { DebugEnterDecision(95, decisionCanBacktrack[95]);
				int LA95_1 = input.LA(1);

				if ((LA95_1==STAR))
				{
					alt95 = 1;
				}
				else if ((LA95_1==ALL||LA95_1==DISTINCT||LA95_1==ELEMENTS||LA95_1==IDENT||LA95_1==INDICES))
				{
					alt95 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 95, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(95); }
				switch (alt95)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:597:18: s= STAR
					{
					DebugLocation(597, 19);
					s=(IToken)Match(input,STAR,Follow._STAR_in_aggregate3174);  
					stream_STAR.Add(s);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:597:27: p= aggregateDistinctAll
					{
					DebugLocation(597, 28);
					PushFollow(Follow._aggregateDistinctAll_in_aggregate3180);
					p=aggregateDistinctAll();
					PopFollow();

					stream_aggregateDistinctAll.Add(p.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(95); }

				DebugLocation(597, 52);
				CLOSE269=(IToken)Match(input,CLOSE,Follow._CLOSE_in_aggregate3184);  
				stream_CLOSE.Add(CLOSE269);



				{
				// AST REWRITE
				// elements: COUNT, p, COUNT
				// token labels: 
				// rule labels: p, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 598:3: -> {s == null}? ^( COUNT $p)
				if (s == null)
				{
					DebugLocation(598, 19);
					// Hql.g:598:19: ^( COUNT $p)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(598, 21);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_COUNT.NextNode(), root_1);

					DebugLocation(598, 28);
					adaptor.AddChild(root_1, stream_p.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 599:3: -> ^( COUNT ^( ROW_STAR[\"*\"] ) )
				{
					DebugLocation(599, 6);
					// Hql.g:599:6: ^( COUNT ^( ROW_STAR[\"*\"] ) )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(599, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_COUNT.NextNode(), root_1);

					DebugLocation(599, 14);
					// Hql.g:599:14: ^( ROW_STAR[\"*\"] )
					{
					IASTNode root_2 = (IASTNode)adaptor.Nil();
					DebugLocation(599, 16);
					root_2 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ROW_STAR, "*"), root_2);

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:600:5: collectionExpr
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(600, 5);
				PushFollow(Follow._collectionExpr_in_aggregate3216);
				collectionExpr270=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr270.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregate", 69);
			LeaveRule("aggregate", 69);
			LeaveRule_aggregate();
	    }
	 	DebugLocation(601, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregate"); }
		return retval;

	}
	// $ANTLR end "aggregate"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_aggregateDistinctAll() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_aggregateDistinctAll() {}
	// $ANTLR start "aggregateDistinctAll"
	// Hql.g:603:1: aggregateDistinctAll : ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) ;
	[GrammarRule("aggregateDistinctAll")]
	private AstParserRuleReturnScope<IASTNode, IToken> aggregateDistinctAll()
	{
		EnterRule_aggregateDistinctAll();
		EnterRule("aggregateDistinctAll", 70);
		TraceIn("aggregateDistinctAll", 70);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken set271 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> path272 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> collectionExpr273 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode set271_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "aggregateDistinctAll");
		DebugLocation(603, 1);
		try
		{
			// Hql.g:604:2: ( ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) )
			DebugEnterAlt(1);
			// Hql.g:604:4: ( ( DISTINCT | ALL )? ( path | collectionExpr ) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(604, 4);
			// Hql.g:604:4: ( ( DISTINCT | ALL )? ( path | collectionExpr ) )
			DebugEnterAlt(1);
			// Hql.g:604:6: ( DISTINCT | ALL )? ( path | collectionExpr )
			{
			DebugLocation(604, 6);
			// Hql.g:604:6: ( DISTINCT | ALL )?
			int alt97=2;
			try { DebugEnterSubRule(97);
			try { DebugEnterDecision(97, decisionCanBacktrack[97]);
			int LA97_1 = input.LA(1);

			if ((LA97_1==ALL||LA97_1==DISTINCT))
			{
				alt97 = 1;
			}
			} finally { DebugExitDecision(97); }
			switch (alt97)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:
				{
				DebugLocation(604, 6);

				set271=(IToken)input.LT(1);
				if (input.LA(1)==ALL||input.LA(1)==DISTINCT)
				{
					input.Consume();
					adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set271));
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(97); }

			DebugLocation(604, 26);
			// Hql.g:604:26: ( path | collectionExpr )
			int alt98=2;
			try { DebugEnterSubRule(98);
			try { DebugEnterDecision(98, decisionCanBacktrack[98]);
			int LA98_1 = input.LA(1);

			if ((LA98_1==IDENT))
			{
				alt98 = 1;
			}
			else if ((LA98_1==ELEMENTS||LA98_1==INDICES))
			{
				alt98 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 98, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:604:28: path
				{
				DebugLocation(604, 28);
				PushFollow(Follow._path_in_aggregateDistinctAll3242);
				path272=path();
				PopFollow();

				adaptor.AddChild(root_0, path272.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:604:35: collectionExpr
				{
				DebugLocation(604, 35);
				PushFollow(Follow._collectionExpr_in_aggregateDistinctAll3246);
				collectionExpr273=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr273.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(98); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregateDistinctAll", 70);
			LeaveRule("aggregateDistinctAll", 70);
			LeaveRule_aggregateDistinctAll();
	    }
	 	DebugLocation(605, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregateDistinctAll"); }
		return retval;

	}
	// $ANTLR end "aggregateDistinctAll"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_collectionExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_collectionExpr() {}
	// $ANTLR start "collectionExpr"
	// Hql.g:609:1: collectionExpr : ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !;
	[GrammarRule("collectionExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> collectionExpr()
	{
		EnterRule_collectionExpr();
		EnterRule("collectionExpr", 71);
		TraceIn("collectionExpr", 71);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken ELEMENTS274 = default(IToken);
	    IToken INDICES275 = default(IToken);
	    IToken OPEN276 = default(IToken);
	    IToken CLOSE278 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> path277 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode ELEMENTS274_tree = default(IASTNode);
	    IASTNode INDICES275_tree = default(IASTNode);
	    IASTNode OPEN276_tree = default(IASTNode);
	    IASTNode CLOSE278_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "collectionExpr");
		DebugLocation(609, 1);
		try
		{
			// Hql.g:610:2: ( ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !)
			DebugEnterAlt(1);
			// Hql.g:610:4: ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(610, 4);
			// Hql.g:610:4: ( ELEMENTS ^| INDICES ^)
			int alt99=2;
			try { DebugEnterSubRule(99);
			try { DebugEnterDecision(99, decisionCanBacktrack[99]);
			int LA99_1 = input.LA(1);

			if ((LA99_1==ELEMENTS))
			{
				alt99 = 1;
			}
			else if ((LA99_1==INDICES))
			{
				alt99 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 99, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:610:5: ELEMENTS ^
				{
				DebugLocation(610, 13);
				ELEMENTS274=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_collectionExpr3265); 
				ELEMENTS274_tree = (IASTNode)adaptor.Create(ELEMENTS274);
				root_0 = (IASTNode)adaptor.BecomeRoot(ELEMENTS274_tree, root_0);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:610:17: INDICES ^
				{
				DebugLocation(610, 24);
				INDICES275=(IToken)Match(input,INDICES,Follow._INDICES_in_collectionExpr3270); 
				INDICES275_tree = (IASTNode)adaptor.Create(INDICES275);
				root_0 = (IASTNode)adaptor.BecomeRoot(INDICES275_tree, root_0);


				}
				break;

			}
			} finally { DebugExitSubRule(99); }

			DebugLocation(610, 31);
			OPEN276=(IToken)Match(input,OPEN,Follow._OPEN_in_collectionExpr3274); 
			DebugLocation(610, 33);
			PushFollow(Follow._path_in_collectionExpr3277);
			path277=path();
			PopFollow();

			adaptor.AddChild(root_0, path277.Tree);
			DebugLocation(610, 43);
			CLOSE278=(IToken)Match(input,CLOSE,Follow._CLOSE_in_collectionExpr3279); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionExpr", 71);
			LeaveRule("collectionExpr", 71);
			LeaveRule_collectionExpr();
	    }
	 	DebugLocation(611, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionExpr"); }
		return retval;

	}
	// $ANTLR end "collectionExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_compoundExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_compoundExpr() {}
	// $ANTLR start "compoundExpr"
	// Hql.g:613:1: compoundExpr : ( collectionExpr | path | ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !) );
	[GrammarRule("compoundExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> compoundExpr()
	{
		EnterRule_compoundExpr();
		EnterRule("compoundExpr", 72);
		TraceIn("compoundExpr", 72);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken OPEN281 = default(IToken);
	    IToken COMMA284 = default(IToken);
	    IToken CLOSE286 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> collectionExpr279 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> path280 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> subQuery282 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression283 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression285 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode OPEN281_tree = default(IASTNode);
	    IASTNode COMMA284_tree = default(IASTNode);
	    IASTNode CLOSE286_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "compoundExpr");
		DebugLocation(613, 1);
		try
		{
			// Hql.g:614:2: ( collectionExpr | path | ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !) )
			int alt102=3;
			try { DebugEnterDecision(102, decisionCanBacktrack[102]);
			switch (input.LA(1))
			{
			case ELEMENTS:
			case INDICES:
				{
				alt102 = 1;
				}
				break;
			case IDENT:
				{
				alt102 = 2;
				}
				break;
			case OPEN:
				{
				alt102 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 102, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:614:4: collectionExpr
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(614, 4);
				PushFollow(Follow._collectionExpr_in_compoundExpr3334);
				collectionExpr279=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr279.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:615:4: path
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(615, 4);
				PushFollow(Follow._path_in_compoundExpr3339);
				path280=path();
				PopFollow();

				adaptor.AddChild(root_0, path280.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:616:4: ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !)
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(616, 4);
				// Hql.g:616:4: ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !)
				DebugEnterAlt(1);
				// Hql.g:616:5: OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !
				{
				DebugLocation(616, 9);
				OPEN281=(IToken)Match(input,OPEN,Follow._OPEN_in_compoundExpr3345); 
				DebugLocation(616, 11);
				// Hql.g:616:11: ( subQuery | ( expression ( COMMA ! expression )* ) )
				int alt101=2;
				try { DebugEnterSubRule(101);
				try { DebugEnterDecision(101, decisionCanBacktrack[101]);
				int LA101_1 = input.LA(1);

				if ((LA101_1==EOF||LA101_1==CLOSE||LA101_1==FROM||LA101_1==GROUP||LA101_1==HAVING||LA101_1==ORDER||LA101_1==SELECT||LA101_1==SKIP||LA101_1==TAKE||LA101_1==UNION||LA101_1==WHERE))
				{
					alt101 = 1;
				}
				else if ((LA101_1==ALL||LA101_1==ANY||LA101_1==AVG||LA101_1==BNOT||LA101_1==CASE||LA101_1==COLON||LA101_1==COUNT||LA101_1==ELEMENTS||LA101_1==EMPTY||LA101_1==EXISTS||LA101_1==FALSE||LA101_1==IDENT||LA101_1==INDICES||LA101_1==MAX||(LA101_1>=MIN && LA101_1<=MINUS)||LA101_1==NOT||(LA101_1>=NULL && LA101_1<=NUM_LONG)||LA101_1==OPEN||(LA101_1>=PARAM && LA101_1<=PLUS)||LA101_1==QUOTED_String||LA101_1==SOME||LA101_1==SUM||LA101_1==TRUE))
				{
					alt101 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 101, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(101); }
				switch (alt101)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:616:13: subQuery
					{
					DebugLocation(616, 13);
					PushFollow(Follow._subQuery_in_compoundExpr3350);
					subQuery282=subQuery();
					PopFollow();

					adaptor.AddChild(root_0, subQuery282.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:616:24: ( expression ( COMMA ! expression )* )
					{
					DebugLocation(616, 24);
					// Hql.g:616:24: ( expression ( COMMA ! expression )* )
					DebugEnterAlt(1);
					// Hql.g:616:25: expression ( COMMA ! expression )*
					{
					DebugLocation(616, 25);
					PushFollow(Follow._expression_in_compoundExpr3355);
					expression283=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression283.Tree);
					DebugLocation(616, 36);
					// Hql.g:616:36: ( COMMA ! expression )*
					try { DebugEnterSubRule(100);
					while (true)
					{
						int alt100=2;
						try { DebugEnterDecision(100, decisionCanBacktrack[100]);
						int LA100_1 = input.LA(1);

						if ((LA100_1==COMMA))
						{
							alt100 = 1;
						}


						} finally { DebugExitDecision(100); }
						switch ( alt100 )
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:616:37: COMMA ! expression
							{
							DebugLocation(616, 42);
							COMMA284=(IToken)Match(input,COMMA,Follow._COMMA_in_compoundExpr3358); 
							DebugLocation(616, 44);
							PushFollow(Follow._expression_in_compoundExpr3361);
							expression285=expression();
							PopFollow();

							adaptor.AddChild(root_0, expression285.Tree);

							}
							break;

						default:
							goto loop100;
						}
					}

					loop100:
						;

					} finally { DebugExitSubRule(100); }


					}


					}
					break;

				}
				} finally { DebugExitSubRule(101); }

				DebugLocation(616, 65);
				CLOSE286=(IToken)Match(input,CLOSE,Follow._CLOSE_in_compoundExpr3368); 

				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compoundExpr", 72);
			LeaveRule("compoundExpr", 72);
			LeaveRule_compoundExpr();
	    }
	 	DebugLocation(617, 1);
		} finally { DebugExitRule(GrammarFileName, "compoundExpr"); }
		return retval;

	}
	// $ANTLR end "compoundExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_exprList() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_exprList() {}
	// $ANTLR start "exprList"
	// Hql.g:619:1: exprList : ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )? ;
	[GrammarRule("exprList")]
	private AstParserRuleReturnScope<IASTNode, IToken> exprList()
	{
		EnterRule_exprList();
		EnterRule("exprList", 73);
		TraceIn("exprList", 73);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken f = default(IToken);
	    IToken f2 = default(IToken);
	    IToken TRAILING287 = default(IToken);
	    IToken LEADING288 = default(IToken);
	    IToken BOTH289 = default(IToken);
	    IToken COMMA291 = default(IToken);
	    IToken AS294 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> expression290 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression292 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression293 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier295 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> expression296 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode f_tree = default(IASTNode);
	    IASTNode f2_tree = default(IASTNode);
	    IASTNode TRAILING287_tree = default(IASTNode);
	    IASTNode LEADING288_tree = default(IASTNode);
	    IASTNode BOTH289_tree = default(IASTNode);
	    IASTNode COMMA291_tree = default(IASTNode);
	    IASTNode AS294_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "exprList");
		DebugLocation(619, 1);
		try
		{
			// Hql.g:625:2: ( ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )? )
			DebugEnterAlt(1);
			// Hql.g:625:4: ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(625, 4);
			// Hql.g:625:4: ( TRAILING | LEADING | BOTH )?
			int alt103=4;
			try { DebugEnterSubRule(103);
			try { DebugEnterDecision(103, decisionCanBacktrack[103]);
			switch (input.LA(1))
			{
			case TRAILING:
				{
				alt103 = 1;
				}
				break;
			case LEADING:
				{
				alt103 = 2;
				}
				break;
			case BOTH:
				{
				alt103 = 3;
				}
				break;
			}

			} finally { DebugExitDecision(103); }
			switch (alt103)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:625:5: TRAILING
				{
				DebugLocation(625, 5);
				TRAILING287=(IToken)Match(input,TRAILING,Follow._TRAILING_in_exprList3387); 
				TRAILING287_tree = (IASTNode)adaptor.Create(TRAILING287);
				adaptor.AddChild(root_0, TRAILING287_tree);

				DebugLocation(625, 14);
				TRAILING287.Type = IDENT;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:626:10: LEADING
				{
				DebugLocation(626, 10);
				LEADING288=(IToken)Match(input,LEADING,Follow._LEADING_in_exprList3400); 
				LEADING288_tree = (IASTNode)adaptor.Create(LEADING288);
				adaptor.AddChild(root_0, LEADING288_tree);

				DebugLocation(626, 18);
				LEADING288.Type = IDENT;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:627:10: BOTH
				{
				DebugLocation(627, 10);
				BOTH289=(IToken)Match(input,BOTH,Follow._BOTH_in_exprList3413); 
				BOTH289_tree = (IASTNode)adaptor.Create(BOTH289);
				adaptor.AddChild(root_0, BOTH289_tree);

				DebugLocation(627, 15);
				BOTH289.Type = IDENT;

				}
				break;

			}
			} finally { DebugExitSubRule(103); }

			DebugLocation(629, 4);
			// Hql.g:629:4: ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )?
			int alt106=3;
			try { DebugEnterSubRule(106);
			try { DebugEnterDecision(106, decisionCanBacktrack[106]);
			int LA106_1 = input.LA(1);

			if ((LA106_1==ALL||LA106_1==ANY||LA106_1==AVG||LA106_1==BNOT||LA106_1==CASE||LA106_1==COLON||LA106_1==COUNT||LA106_1==ELEMENTS||LA106_1==EMPTY||LA106_1==EXISTS||LA106_1==FALSE||LA106_1==IDENT||LA106_1==INDICES||LA106_1==MAX||(LA106_1>=MIN && LA106_1<=MINUS)||LA106_1==NOT||(LA106_1>=NULL && LA106_1<=NUM_LONG)||LA106_1==OPEN||(LA106_1>=PARAM && LA106_1<=PLUS)||LA106_1==QUOTED_String||LA106_1==SOME||LA106_1==SUM||LA106_1==TRUE))
			{
				alt106 = 1;
			}
			else if ((LA106_1==FROM))
			{
				alt106 = 2;
			}
			} finally { DebugExitDecision(106); }
			switch (alt106)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:630:5: expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )?
				{
				DebugLocation(630, 5);
				PushFollow(Follow._expression_in_exprList3437);
				expression290=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression290.Tree);
				DebugLocation(630, 16);
				// Hql.g:630:16: ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )?
				int alt105=4;
				try { DebugEnterSubRule(105);
				try { DebugEnterDecision(105, decisionCanBacktrack[105]);
				switch (input.LA(1))
				{
				case COMMA:
					{
					alt105 = 1;
					}
					break;
				case FROM:
					{
					alt105 = 2;
					}
					break;
				case AS:
					{
					alt105 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(105); }
				switch (alt105)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:630:18: ( COMMA ! expression )+
					{
					DebugLocation(630, 18);
					// Hql.g:630:18: ( COMMA ! expression )+
					int cnt104=0;
					try { DebugEnterSubRule(104);
					while (true)
					{
						int alt104=2;
						try { DebugEnterDecision(104, decisionCanBacktrack[104]);
						int LA104_1 = input.LA(1);

						if ((LA104_1==COMMA))
						{
							alt104 = 1;
						}


						} finally { DebugExitDecision(104); }
						switch (alt104)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:630:19: COMMA ! expression
							{
							DebugLocation(630, 24);
							COMMA291=(IToken)Match(input,COMMA,Follow._COMMA_in_exprList3442); 
							DebugLocation(630, 26);
							PushFollow(Follow._expression_in_exprList3445);
							expression292=expression();
							PopFollow();

							adaptor.AddChild(root_0, expression292.Tree);

							}
							break;

						default:
							if (cnt104 >= 1)
								goto loop104;

							EarlyExitException eee104 = new EarlyExitException( 104, input );
							DebugRecognitionException(eee104);
							throw eee104;
						}
						cnt104++;
					}
					loop104:
						;

					} finally { DebugExitSubRule(104); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:631:9: f= FROM expression
					{
					DebugLocation(631, 10);
					f=(IToken)Match(input,FROM,Follow._FROM_in_exprList3460); 
					f_tree = (IASTNode)adaptor.Create(f);
					adaptor.AddChild(root_0, f_tree);

					DebugLocation(631, 16);
					PushFollow(Follow._expression_in_exprList3462);
					expression293=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression293.Tree);
					DebugLocation(631, 27);
					f.Type = IDENT;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:632:9: AS ! identifier
					{
					DebugLocation(632, 11);
					AS294=(IToken)Match(input,AS,Follow._AS_in_exprList3474); 
					DebugLocation(632, 13);
					PushFollow(Follow._identifier_in_exprList3477);
					identifier295=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier295.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(105); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:633:7: f2= FROM expression
				{
				DebugLocation(633, 9);
				f2=(IToken)Match(input,FROM,Follow._FROM_in_exprList3491); 
				f2_tree = (IASTNode)adaptor.Create(f2);
				adaptor.AddChild(root_0, f2_tree);

				DebugLocation(633, 15);
				PushFollow(Follow._expression_in_exprList3493);
				expression296=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression296.Tree);
				DebugLocation(633, 26);
				f2.Type = IDENT;

				}
				break;

			}
			} finally { DebugExitSubRule(106); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


			   IASTNode root = (IASTNode) adaptor.Create(EXPR_LIST, "exprList");
			   root.AddChild((IASTNode)retval.Tree);
			   retval.Tree = root;

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprList", 73);
			LeaveRule("exprList", 73);
			LeaveRule_exprList();
	    }
	 	DebugLocation(635, 1);
		} finally { DebugExitRule(GrammarFileName, "exprList"); }
		return retval;

	}
	// $ANTLR end "exprList"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_subQuery() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_subQuery() {}
	// $ANTLR start "subQuery"
	// Hql.g:637:1: subQuery : innerSubQuery ( UNION ^ innerSubQuery )* ;
	[GrammarRule("subQuery")]
	private AstParserRuleReturnScope<IASTNode, IToken> subQuery()
	{
		EnterRule_subQuery();
		EnterRule("subQuery", 74);
		TraceIn("subQuery", 74);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken UNION298 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery297 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery299 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode UNION298_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "subQuery");
		DebugLocation(637, 1);
		try
		{
			// Hql.g:638:2: ( innerSubQuery ( UNION ^ innerSubQuery )* )
			DebugEnterAlt(1);
			// Hql.g:638:4: innerSubQuery ( UNION ^ innerSubQuery )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(638, 4);
			PushFollow(Follow._innerSubQuery_in_subQuery3513);
			innerSubQuery297=innerSubQuery();
			PopFollow();

			adaptor.AddChild(root_0, innerSubQuery297.Tree);
			DebugLocation(638, 18);
			// Hql.g:638:18: ( UNION ^ innerSubQuery )*
			try { DebugEnterSubRule(107);
			while (true)
			{
				int alt107=2;
				try { DebugEnterDecision(107, decisionCanBacktrack[107]);
				int LA107_1 = input.LA(1);

				if ((LA107_1==UNION))
				{
					alt107 = 1;
				}


				} finally { DebugExitDecision(107); }
				switch ( alt107 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:638:19: UNION ^ innerSubQuery
					{
					DebugLocation(638, 24);
					UNION298=(IToken)Match(input,UNION,Follow._UNION_in_subQuery3516); 
					UNION298_tree = (IASTNode)adaptor.Create(UNION298);
					root_0 = (IASTNode)adaptor.BecomeRoot(UNION298_tree, root_0);

					DebugLocation(638, 26);
					PushFollow(Follow._innerSubQuery_in_subQuery3519);
					innerSubQuery299=innerSubQuery();
					PopFollow();

					adaptor.AddChild(root_0, innerSubQuery299.Tree);

					}
					break;

				default:
					goto loop107;
				}
			}

			loop107:
				;

			} finally { DebugExitSubRule(107); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subQuery", 74);
			LeaveRule("subQuery", 74);
			LeaveRule_subQuery();
	    }
	 	DebugLocation(639, 1);
		} finally { DebugExitRule(GrammarFileName, "subQuery"); }
		return retval;

	}
	// $ANTLR end "subQuery"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_innerSubQuery() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_innerSubQuery() {}
	// $ANTLR start "innerSubQuery"
	// Hql.g:641:1: innerSubQuery : queryRule -> ^( QUERY[\"query\"] queryRule ) ;
	[GrammarRule("innerSubQuery")]
	private AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery()
	{
		EnterRule_innerSubQuery();
		EnterRule("innerSubQuery", 75);
		TraceIn("innerSubQuery", 75);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    AstParserRuleReturnScope<IASTNode, IToken> queryRule300 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    RewriteRuleSubtreeStream stream_queryRule=new RewriteRuleSubtreeStream(adaptor,"rule queryRule");
		try { DebugEnterRule(GrammarFileName, "innerSubQuery");
		DebugLocation(641, 1);
		try
		{
			// Hql.g:642:2: ( queryRule -> ^( QUERY[\"query\"] queryRule ) )
			DebugEnterAlt(1);
			// Hql.g:642:4: queryRule
			{
			DebugLocation(642, 4);
			PushFollow(Follow._queryRule_in_innerSubQuery3533);
			queryRule300=queryRule();
			PopFollow();

			stream_queryRule.Add(queryRule300.Tree);


			{
			// AST REWRITE
			// elements: queryRule
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 643:2: -> ^( QUERY[\"query\"] queryRule )
			{
				DebugLocation(643, 5);
				// Hql.g:643:5: ^( QUERY[\"query\"] queryRule )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(643, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(QUERY, "query"), root_1);

				DebugLocation(643, 22);
				adaptor.AddChild(root_1, stream_queryRule.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("innerSubQuery", 75);
			LeaveRule("innerSubQuery", 75);
			LeaveRule_innerSubQuery();
	    }
	 	DebugLocation(644, 1);
		} finally { DebugExitRule(GrammarFileName, "innerSubQuery"); }
		return retval;

	}
	// $ANTLR end "innerSubQuery"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_constant() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_constant() {}
	// $ANTLR start "constant"
	// Hql.g:646:1: constant : ( NUM_INT | NUM_FLOAT | NUM_LONG | NUM_DOUBLE | NUM_DECIMAL | QUOTED_String | NULL | TRUE | FALSE | EMPTY );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<IASTNode, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 76);
		TraceIn("constant", 76);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken set301 = default(IToken);

	    IASTNode set301_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(646, 1);
		try
		{
			// Hql.g:647:2: ( NUM_INT | NUM_FLOAT | NUM_LONG | NUM_DOUBLE | NUM_DECIMAL | QUOTED_String | NULL | TRUE | FALSE | EMPTY )
			DebugEnterAlt(1);
			// Hql.g:
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(647, 2);

			set301=(IToken)input.LT(1);
			if (input.LA(1)==EMPTY||input.LA(1)==FALSE||(input.LA(1)>=NULL && input.LA(1)<=NUM_LONG)||input.LA(1)==QUOTED_String||input.LA(1)==TRUE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set301));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 76);
			LeaveRule("constant", 76);
			LeaveRule_constant();
	    }
	 	DebugLocation(657, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_path() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_path() {}
	// $ANTLR start "path"
	// Hql.g:665:1: path : identifier ( DOT ^ identifier )* ;
	[GrammarRule("path")]
	private AstParserRuleReturnScope<IASTNode, IToken> path()
	{
		EnterRule_path();
		EnterRule("path", 77);
		TraceIn("path", 77);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken DOT303 = default(IToken);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier302 = default(AstParserRuleReturnScope<IASTNode, IToken>);
	    AstParserRuleReturnScope<IASTNode, IToken> identifier304 = default(AstParserRuleReturnScope<IASTNode, IToken>);

	    IASTNode DOT303_tree = default(IASTNode);


	    // TODO - need to clean up DotIdent - suspect that DotIdent2 supersedes the other one, but need to do the analysis
	    //HandleDotIdent2();

		try { DebugEnterRule(GrammarFileName, "path");
		DebugLocation(665, 1);
		try
		{
			// Hql.g:670:2: ( identifier ( DOT ^ identifier )* )
			DebugEnterAlt(1);
			// Hql.g:670:4: identifier ( DOT ^ identifier )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(670, 4);
			PushFollow(Follow._identifier_in_path3621);
			identifier302=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier302.Tree);
			DebugLocation(670, 15);
			// Hql.g:670:15: ( DOT ^ identifier )*
			try { DebugEnterSubRule(108);
			while (true)
			{
				int alt108=2;
				try { DebugEnterDecision(108, decisionCanBacktrack[108]);
				int LA108_1 = input.LA(1);

				if ((LA108_1==DOT))
				{
					alt108 = 1;
				}


				} finally { DebugExitDecision(108); }
				switch ( alt108 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:670:17: DOT ^ identifier
					{
					DebugLocation(670, 20);
					DOT303=(IToken)Match(input,DOT,Follow._DOT_in_path3625); 
					DOT303_tree = (IASTNode)adaptor.Create(DOT303);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT303_tree, root_0);

					DebugLocation(670, 22);
					 WeakKeywords(); 
					DebugLocation(670, 42);
					PushFollow(Follow._identifier_in_path3630);
					identifier304=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier304.Tree);

					}
					break;

				default:
					goto loop108;
				}
			}

			loop108:
				;

			} finally { DebugExitSubRule(108); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("path", 77);
			LeaveRule("path", 77);
			LeaveRule_path();
	    }
	 	DebugLocation(671, 1);
		} finally { DebugExitRule(GrammarFileName, "path"); }
		return retval;

	}
	// $ANTLR end "path"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_identifier() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_identifier() {}
	// $ANTLR start "identifier"
	// Hql.g:675:1: identifier : IDENT ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<IASTNode, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 78);
		TraceIn("identifier", 78);
	    AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    IASTNode root_0 = default(IASTNode);

	    IToken IDENT305 = default(IToken);

	    IASTNode IDENT305_tree = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(675, 1);
		try
		{
			// Hql.g:676:2: ( IDENT )
			DebugEnterAlt(1);
			// Hql.g:676:4: IDENT
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(676, 4);
			IDENT305=(IToken)Match(input,IDENT,Follow._IDENT_in_identifier3646); 
			IDENT305_tree = (IASTNode)adaptor.Create(IDENT305);
			adaptor.AddChild(root_0, IDENT305_tree);


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException ex)
		{

					retval.Tree = HandleIdentifierError(input.LT(1),ex);
				
		}

		finally
		{
			TraceOut("identifier", 78);
			LeaveRule("identifier", 78);
			LeaveRule_identifier();
	    }
	 	DebugLocation(677, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _updateStatement_in_statement611 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _deleteStatement_in_statement615 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _selectStatement_in_statement619 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _insertStatement_in_statement623 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_statement627 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UPDATE_in_updateStatement639 = new BitSet(new ulong[]{0x81000000000000UL,0x8000000000000000UL});
		public static readonly BitSet _VERSIONED_in_updateStatement643 = new BitSet(new ulong[]{0x81000000000000UL});
		public static readonly BitSet _optionalFromTokenFromClause_in_updateStatement649 = new BitSet(new ulong[]{0x0UL,0x1000000000000UL});
		public static readonly BitSet _setClause_in_updateStatement653 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_updateStatement658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SET_in_setClause672 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _assignment_in_setClause675 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_setClause678 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _assignment_in_setClause681 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _stateField_in_assignment695 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _EQ_in_assignment697 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _newValue_in_assignment700 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_stateField713 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_newValue726 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_deleteStatement737 = new BitSet(new ulong[]{0x81000000000000UL});
		public static readonly BitSet _optionalFromTokenFromClause_in_deleteStatement743 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_deleteStatement749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _optionalFromTokenFromClause2_in_optionalFromTokenFromClause764 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_optionalFromTokenFromClause766 = new BitSet(new ulong[]{0x80000000000202UL});
		public static readonly BitSet _asAlias_in_optionalFromTokenFromClause769 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_optionalFromTokenFromClause2800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _queryRule_in_selectStatement814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INSERT_in_insertStatement843 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _intoClause_in_insertStatement846 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _selectStatement_in_insertStatement848 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTO_in_intoClause859 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_intoClause862 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _insertablePropertySpec_in_intoClause866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_insertablePropertySpec877 = new BitSet(new ulong[]{0x1080101410800800UL,0x22004411F809000UL});
		public static readonly BitSet _primaryExpression_in_insertablePropertySpec879 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _COMMA_in_insertablePropertySpec883 = new BitSet(new ulong[]{0x1080101410800800UL,0x22004411F809000UL});
		public static readonly BitSet _primaryExpression_in_insertablePropertySpec885 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _CLOSE_in_insertablePropertySpec890 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectFrom_in_queryRule916 = new BitSet(new ulong[]{0x28000000000002UL,0x42000800000000UL,0x4UL});
		public static readonly BitSet _whereClause_in_queryRule921 = new BitSet(new ulong[]{0x28000000000002UL,0x42000800000000UL});
		public static readonly BitSet _groupByClause_in_queryRule928 = new BitSet(new ulong[]{0x20000000000002UL,0x42000800000000UL});
		public static readonly BitSet _havingClause_in_queryRule935 = new BitSet(new ulong[]{0x2UL,0x42000800000000UL});
		public static readonly BitSet _orderByClause_in_queryRule942 = new BitSet(new ulong[]{0x2UL,0x42000000000000UL});
		public static readonly BitSet _skipClause_in_queryRule949 = new BitSet(new ulong[]{0x2UL,0x40000000000000UL});
		public static readonly BitSet _takeClause_in_queryRule956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectClause_in_selectFrom974 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _fromClause_in_selectFrom981 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELECT_in_selectClause1030 = new BitSet(new ulong[]{0x1080121490844940UL,0x22404C13F8D9000UL});
		public static readonly BitSet _DISTINCT_in_selectClause1042 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C13F8D9000UL});
		public static readonly BitSet _selectedPropertiesList_in_selectClause1048 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_selectClause1052 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectObject_in_selectClause1056 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression1070 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_newExpression1072 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_newExpression1077 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _selectedPropertiesList_in_newExpression1079 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_newExpression1081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJECT_in_selectObject1107 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_selectObject1110 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_selectObject1113 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_selectObject1115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_fromClause1133 = new BitSet(new ulong[]{0x480000400000000UL});
		public static readonly BitSet _fromRange_in_fromClause1138 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _fromJoin_in_fromClause1142 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _COMMA_in_fromClause1146 = new BitSet(new ulong[]{0x480000400000000UL});
		public static readonly BitSet _fromRange_in_fromClause1151 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _set_in_fromJoin1169 = new BitSet(new ulong[]{0x0UL,0x2000000020UL});
		public static readonly BitSet _OUTER_in_fromJoin1180 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _FULL_in_fromJoin1188 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _INNER_in_fromJoin1192 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _JOIN_in_fromJoin1197 = new BitSet(new ulong[]{0x80200000000000UL});
		public static readonly BitSet _FETCH_in_fromJoin1201 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_fromJoin1205 = new BitSet(new ulong[]{0x80200000000202UL,0x0UL,0x8UL});
		public static readonly BitSet _asAlias_in_fromJoin1208 = new BitSet(new ulong[]{0x200000000002UL,0x0UL,0x8UL});
		public static readonly BitSet _propertyFetch_in_fromJoin1213 = new BitSet(new ulong[]{0x2UL,0x0UL,0x8UL});
		public static readonly BitSet _withClause_in_fromJoin1218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_fromJoin1229 = new BitSet(new ulong[]{0x0UL,0x2000000020UL});
		public static readonly BitSet _OUTER_in_fromJoin1240 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _FULL_in_fromJoin1248 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _INNER_in_fromJoin1252 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _JOIN_in_fromJoin1257 = new BitSet(new ulong[]{0x200400000000UL});
		public static readonly BitSet _FETCH_in_fromJoin1261 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ELEMENTS_in_fromJoin1265 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_fromJoin1268 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_fromJoin1271 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_fromJoin1273 = new BitSet(new ulong[]{0x80200000000202UL,0x0UL,0x8UL});
		public static readonly BitSet _asAlias_in_fromJoin1277 = new BitSet(new ulong[]{0x200000000002UL,0x0UL,0x8UL});
		public static readonly BitSet _propertyFetch_in_fromJoin1282 = new BitSet(new ulong[]{0x2UL,0x0UL,0x8UL});
		public static readonly BitSet _withClause_in_fromJoin1287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withClause1300 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_withClause1303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _fromClassOrOuterQueryPath_in_fromRange1314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inClassDeclaration_in_fromRange1319 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inCollectionDeclaration_in_fromRange1324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inCollectionElementsDeclaration_in_fromRange1329 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_fromClassOrOuterQueryPath1341 = new BitSet(new ulong[]{0x80200000000202UL});
		public static readonly BitSet _asAlias_in_fromClassOrOuterQueryPath1346 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _propertyFetch_in_fromClassOrOuterQueryPath1351 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_in_inClassDeclaration1381 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _IN_in_inClassDeclaration1383 = new BitSet(new ulong[]{0x80000000100000UL});
		public static readonly BitSet _CLASS_in_inClassDeclaration1385 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inClassDeclaration1388 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IN_in_inCollectionDeclaration1416 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionDeclaration1418 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionDeclaration1420 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionDeclaration1422 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_inCollectionDeclaration1424 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_in_inCollectionElementsDeclaration1458 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _IN_in_inCollectionElementsDeclaration1460 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ELEMENTS_in_inCollectionElementsDeclaration1462 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionElementsDeclaration1464 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionElementsDeclaration1466 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionElementsDeclaration1468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELEMENTS_in_inCollectionElementsDeclaration1490 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionElementsDeclaration1492 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionElementsDeclaration1494 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionElementsDeclaration1496 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _AS_in_inCollectionElementsDeclaration1498 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_inCollectionElementsDeclaration1500 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_asAlias1532 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_asAlias1537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_alias1549 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FETCH_in_propertyFetch1568 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ALL_in_propertyFetch1570 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _PROPERTIES_in_propertyFetch1573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GROUP_in_groupByClause1585 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _LITERAL_by_in_groupByClause1591 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_groupByClause1594 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_groupByClause1598 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_groupByClause1601 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _ORDER_in_orderByClause1615 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _LITERAL_by_in_orderByClause1618 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _orderElement_in_orderByClause1621 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_orderByClause1625 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _orderElement_in_orderByClause1628 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _SKIP_in_skipClause1642 = new BitSet(new ulong[]{0x800000UL,0x4008000000UL});
		public static readonly BitSet _NUM_INT_in_skipClause1646 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_skipClause1650 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TAKE_in_takeClause1662 = new BitSet(new ulong[]{0x800000UL,0x4008000000UL});
		public static readonly BitSet _NUM_INT_in_takeClause1666 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_takeClause1670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_parameter1682 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_parameter1685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_parameter1690 = new BitSet(new ulong[]{0x2UL,0x8000000UL});
		public static readonly BitSet _NUM_INT_in_parameter1694 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_orderElement1707 = new BitSet(new ulong[]{0x40000402UL,0x0UL,0x60UL});
		public static readonly BitSet _ascendingOrDescending_in_orderElement1711 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASCENDING_in_ascendingOrDescending1729 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _133_in_ascendingOrDescending1735 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DESCENDING_in_ascendingOrDescending1755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _134_in_ascendingOrDescending1761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HAVING_in_havingClause1782 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_havingClause1785 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHERE_in_whereClause1796 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_whereClause1799 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aliasedExpression_in_selectedPropertiesList1810 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_selectedPropertiesList1814 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _aliasedExpression_in_selectedPropertiesList1817 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _expression_in_aliasedExpression1832 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _AS_in_aliasedExpression1836 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_aliasedExpression1839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_logicalExpression1878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalOrExpression_in_expression1890 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1902 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _OR_in_logicalOrExpression1906 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1909 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _negatedExpression_in_logicalAndExpression1924 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_logicalAndExpression1928 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _negatedExpression_in_logicalAndExpression1931 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _NOT_in_negatedExpression1952 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _negatedExpression_in_negatedExpression1956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_negatedExpression1969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1999 = new BitSet(new ulong[]{0x4000000002UL,0x8000000020002UL});
		public static readonly BitSet _EQ_in_equalityExpression2007 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _IS_in_equalityExpression2016 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _NOT_in_equalityExpression2022 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _NE_in_equalityExpression2034 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _SQL_NE_in_equalityExpression2043 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression2054 = new BitSet(new ulong[]{0x4000000002UL,0x8000000020002UL});
		public static readonly BitSet _concatenation_in_relationalExpression2071 = new BitSet(new ulong[]{0x414000000002002UL,0x82A40UL});
		public static readonly BitSet _LT_in_relationalExpression2083 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _GT_in_relationalExpression2088 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _LE_in_relationalExpression2093 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _GE_in_relationalExpression2098 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_relationalExpression2103 = new BitSet(new ulong[]{0x14000000000002UL,0x840UL});
		public static readonly BitSet _NOT_in_relationalExpression2120 = new BitSet(new ulong[]{0x400000000002000UL,0x2200UL});
		public static readonly BitSet _IN_in_relationalExpression2141 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _inList_in_relationalExpression2150 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BETWEEN_in_relationalExpression2161 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _betweenList_in_relationalExpression2170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIKE_in_relationalExpression2182 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_relationalExpression2191 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _likeEscape_in_relationalExpression2193 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MEMBER_in_relationalExpression2202 = new BitSet(new ulong[]{0x80000000000000UL,0x40000000UL});
		public static readonly BitSet _OF_in_relationalExpression2206 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_relationalExpression2213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ESCAPE_in_likeEscape2240 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_likeEscape2243 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compoundExpr_in_inList2256 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_betweenList2277 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _AND_in_betweenList2279 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_betweenList2282 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2301 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _CONCAT_in_concatenation2309 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2318 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _CONCAT_in_concatenation2325 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2328 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _BNOT_in_bitwiseNotExpression2352 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseNotExpression2355 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseNotExpression2361 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression2373 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _BOR_in_bitwiseOrExpression2376 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression2379 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression2393 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _BXOR_in_bitwiseXOrExpression2396 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression2399 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _additiveExpression_in_bitwiseAndExpression2413 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _BAND_in_bitwiseAndExpression2416 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _additiveExpression_in_bitwiseAndExpression2419 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _multiplyExpression_in_additiveExpression2433 = new BitSet(new ulong[]{0x2UL,0x8000010000UL});
		public static readonly BitSet _PLUS_in_additiveExpression2439 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _MINUS_in_additiveExpression2444 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _multiplyExpression_in_additiveExpression2449 = new BitSet(new ulong[]{0x2UL,0x8000010000UL});
		public static readonly BitSet _unaryExpression_in_multiplyExpression2464 = new BitSet(new ulong[]{0x100000002UL,0x10000000000000UL});
		public static readonly BitSet _STAR_in_multiplyExpression2470 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _DIV_in_multiplyExpression2475 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_multiplyExpression2480 = new BitSet(new ulong[]{0x100000002UL,0x10000000000000UL});
		public static readonly BitSet _MINUS_in_unaryExpression2498 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_unaryExpression2519 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _caseExpression_in_unaryExpression2540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quantifiedExpression_in_unaryExpression2554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_unaryExpression2569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpression2588 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _whenClause_in_caseExpression2591 = new BitSet(new ulong[]{0x2800000000UL,0x0UL,0x2UL});
		public static readonly BitSet _elseClause_in_caseExpression2596 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _END_in_caseExpression2600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpression2620 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_caseExpression2622 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _altWhenClause_in_caseExpression2625 = new BitSet(new ulong[]{0x2800000000UL,0x0UL,0x2UL});
		public static readonly BitSet _elseClause_in_caseExpression2630 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _END_in_caseExpression2634 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_whenClause2663 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_whenClause2666 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _THEN_in_whenClause2668 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_whenClause2671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_altWhenClause2685 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_altWhenClause2688 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _THEN_in_altWhenClause2690 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_altWhenClause2693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_elseClause2707 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_elseClause2710 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SOME_in_quantifiedExpression2725 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _EXISTS_in_quantifiedExpression2730 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _ALL_in_quantifiedExpression2735 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _ANY_in_quantifiedExpression2740 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _identifier_in_quantifiedExpression2749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_quantifiedExpression2753 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_quantifiedExpression2758 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _subQuery_in_quantifiedExpression2763 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_quantifiedExpression2767 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_atom2786 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _DOT_in_atom2795 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_atom2798 = new BitSet(new ulong[]{0x200000002UL,0x300000000UL});
		public static readonly BitSet _OPEN_in_atom2826 = new BitSet(new ulong[]{0x1081121410A54940UL,0x32404C11F899080UL});
		public static readonly BitSet _exprList_in_atom2831 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_atom2833 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _OPEN_BRACKET_in_atom2847 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_atom2852 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _CLOSE_BRACKET_in_atom2854 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _identPrimary_in_primaryExpression2874 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _DOT_in_primaryExpression2887 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CLASS_in_primaryExpression2890 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primaryExpression2900 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_primaryExpression2907 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_primaryExpression2910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_primaryExpression2919 = new BitSet(new ulong[]{0x10A9121410844940UL,0x26644C91F899000UL,0x4UL});
		public static readonly BitSet _expressionOrVector_in_primaryExpression2923 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _subQuery_in_primaryExpression2927 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_primaryExpression2930 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_primaryExpression2938 = new BitSet(new ulong[]{0x2UL,0x8000000UL});
		public static readonly BitSet _NUM_INT_in_primaryExpression2942 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionOrVector2960 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _vectorExpr_in_expressionOrVector2966 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_vectorExpr3005 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_vectorExpr3008 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_vectorExpr3011 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_vectorExpr3014 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _identifier_in_identPrimary3030 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _DOT_in_identPrimary3048 = new BitSet(new ulong[]{0x80000000000000UL,0x20000000UL});
		public static readonly BitSet _identifier_in_identPrimary3053 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _OBJECT_in_identPrimary3059 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_identPrimary3077 = new BitSet(new ulong[]{0x1081121410A54940UL,0x32404C11F899080UL});
		public static readonly BitSet _exprList_in_identPrimary3082 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_identPrimary3084 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_identPrimary3100 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUM_in_aggregate3121 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _AVG_in_aggregate3127 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _MAX_in_aggregate3133 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _MIN_in_aggregate3139 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_aggregate3143 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _additiveExpression_in_aggregate3145 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_aggregate3147 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COUNT_in_aggregate3166 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_aggregate3168 = new BitSet(new ulong[]{0x1080000480000040UL,0x10000000000000UL});
		public static readonly BitSet _STAR_in_aggregate3174 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _aggregateDistinctAll_in_aggregate3180 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_aggregate3184 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_aggregate3216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_aggregateDistinctAll3242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_aggregateDistinctAll3246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELEMENTS_in_collectionExpr3265 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _INDICES_in_collectionExpr3270 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_collectionExpr3274 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_collectionExpr3277 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_collectionExpr3279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_compoundExpr3334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_compoundExpr3339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_compoundExpr3345 = new BitSet(new ulong[]{0x10A9121410844940UL,0x26644C91F899000UL,0x4UL});
		public static readonly BitSet _subQuery_in_compoundExpr3350 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _expression_in_compoundExpr3355 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _COMMA_in_compoundExpr3358 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_compoundExpr3361 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _CLOSE_in_compoundExpr3368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRAILING_in_exprList3387 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _LEADING_in_exprList3400 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _BOTH_in_exprList3413 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3437 = new BitSet(new ulong[]{0x1000001000202UL});
		public static readonly BitSet _COMMA_in_exprList3442 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3445 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _FROM_in_exprList3460 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_exprList3474 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_exprList3477 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_exprList3491 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3493 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _innerSubQuery_in_subQuery3513 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _UNION_in_subQuery3516 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _innerSubQuery_in_subQuery3519 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _queryRule_in_innerSubQuery3533 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_path3621 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _DOT_in_path3625 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_path3630 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _IDENT_in_identifier3646 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  NHibernate.Hql.Ast.ANTLR 
