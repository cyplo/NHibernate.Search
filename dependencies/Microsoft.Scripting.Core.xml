<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Scripting.Core</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Linq.Expressions.Compiler.LambdaCompiler">
            <summary>
            Dynamic Language Runtime Compiler.
            This part compiles lambdas.
            </summary>
            <summary>
            LambdaCompiler is responsible for compiling individual lambda (LambdaExpression). The complete tree may
            contain multiple lambdas, the Compiler class is reponsible for compiling the whole tree, individual
            lambdas are then compiled by the LambdaCompiler.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitCatchStart(Microsoft.Linq.Expressions.CatchBlock)">
            <summary>
            Emits the start of a catch block.  The exception value that is provided by the
            CLR is stored in the variable specified by the catch block or popped if no
            variable is provided.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.Significant(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Expression is significant if:
              * it is not an empty expression
            == or ==
              * it is an empty expression, and 
              * it has a valid span, and
              * we are emitting debug symbols
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitDelegateConstruction(Microsoft.Linq.Expressions.Compiler.LambdaCompiler,System.Type,System.Boolean)">
            <summary>
            Emits code which creates new instance of the delegateType delegate.
            
            Since the delegate is getting closed over the "Closure" argument, this
            cannot be used with virtual/instance methods (delegateFunction must be static method)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitDelegateConstruction(Microsoft.Linq.Expressions.LambdaExpression,System.Type)">
            <summary>
            Emits a delegate to the method generated for the LambdaExpression.
            May end up creating a wrapper to match the requested delegate type.
            </summary>
            <param name="lambda">Lambda for which to generate a delegate</param>
            <param name="delegateType">Type of the delegate.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.MakeParameterTypeArray(System.Collections.Generic.IList{System.Type},System.Boolean,System.Boolean)">
            <summary>
            Creates the signature for the actual CLR method to create. The base types come from the
            lambda/LambdaExpression (or its wrapper method), this method may pre-pend an argument to hold
            closure information (for closing over constant pool or the lexical closure)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.ComputeSignature(Microsoft.Linq.Expressions.LambdaExpression,System.Collections.Generic.List{System.Type}@,System.Collections.Generic.List{System.String}@,System.String@,System.Type@)">
            <summary>
            Creates the signature for the lambda as list of types and list of names separately
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitExpression(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Generates code for this expression in a value position.
            This method will leave the value of the expression
            on the top of the stack typed as Type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitExpressionAsVoid(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Emits an expression and discards the result.  For some nodes this emits
            more optimial code then EmitExpression/Pop
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.LambdaCompiler._paramTypes">
            <summary>
            Argument types
            
            This list contains _all_ arguments on the underlying method builder (except for the
            "this"). There are two views on the list. First provides the raw view (shows all
            arguments), the second view provides view of the arguments which are in the original
            lambda (so first argument, which may be closure argument, is skipped in that case)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CompileLambda(Microsoft.Linq.Expressions.LambdaExpression,System.Type,System.Boolean,System.Boolean,System.Reflection.MethodInfo@)">
            <summary>
            Compiler entry point
            </summary>
            <param name="lambda">LambdaExpression to compile.</param>
            <param name="method">Product of compilation</param>
            <param name="delegateType">Type of the delegate to create</param>
            <param name="emitDebugSymbols">True to emit debug symbols, false otherwise.</param>
            <param name="forceDynamic">Force dynamic method regardless of save assemblies.</param>
            <returns>The compiled delegate.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CompileLambda(Microsoft.Linq.Expressions.LambdaExpression,System.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes,System.Boolean)">
            <summary>
            Creates and returns a MethodBuilder
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.GetLambdaArgument(System.Int32)">
            <summary>
            Gets the argument slot corresponding to the parameter at the given
            index. Assumes that the method takes a certain number of prefix
            arguments, followed by the real parameters stored in Parameters
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.EmitLambdaArgument(System.Int32)">
            <summary>
            Returns the index-th argument. This method provides access to the actual arguments
            defined on the lambda itself, and excludes the possible 0-th closure argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CreateLambdaCompiler(Microsoft.Linq.Expressions.Compiler.CompilerScope,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.String[],System.Boolean)">
            <summary>
            Creates a compiler that shares the same characteristic as "this". If compiling into
            DynamicMethod (both fake or real), it will create compiler backed by dynamic method
            (also fake or real), if compiling into a type, it will create compiler linked to
            a new (static) method on the same type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CreateDynamicLambdaCompiler(Microsoft.Linq.Expressions.Compiler.CompilerScope,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a compiler backed by dynamic method. Sometimes (when debugging is required) the dynamic
            method is actually a 'fake' dynamic method and is backed by static type created specifically for
            the one method
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.LambdaCompiler.CreateStaticLambdaCompiler(Microsoft.Linq.Expressions.Compiler.CompilerScope,System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a LambdaCompiler backed by a method on a static type
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.ExpressionTreeVisitor">
            <summary>
            Base class for visiting and rewriting trees. Subclasses can override
            individual Visit methods from which they can return rewritten nodes.
            If a node is rewritten, all parent nodes will be rewritten
            automatically.
            
            TODO: rename back to ExpressionVisitor (fix the Linq test that has a copy)
            TODO: needs public API vetting
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionTreeVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},Microsoft.Func{``0,``0})">
            <summary>
            Visits all nodes in the collection using a specified element visitor.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="nodes">Input collection.</param>
            <param name="elementVisitor">Delegate that visits a single element.</param>
            <returns>Collection of visited nodes. Original collection is returned if no nodes were modified.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionTreeVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
            <summary>
            Visits all of the nodes in the collection, and tries to convert each
            result back to the original type. If any conversion fails, it
            throws an error
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionTreeVisitor.VisitExtension(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Override called for Extension nodes. This can be overriden to
            rewrite certain extension nodes. If it's not overriden, this method
            will call into Expression.Visit, which gives the node a chance to
            walk its children
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.RuntimeOps.RuleMatched(System.Delegate)">
            <summary>
            Called by generated code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.Variant">
            <summary>
            Variant is the basic COM type for late-binding. It can contain any other COM data type.
            This type definition precisely matches the unmanaged data layout so that the struct can be passed
            to and from COM calls.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.Variant.IsPrimitiveType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Primitive types are the basic COM types. It includes valuetypes like ints, but also reference tyeps
            like BStrs. It does not include composite types like arrays and user-defined COM types (IUnknown/IDispatch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.Variant.ToObject">
            <summary>
            Get the managed object representing the Variant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Com.Variant.Clear">
            <summary>
            Release any unmanaged memory associated with the Variant
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Com.GenericComObject">
            <summary>
            We have no additional information about this COM object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComObject">
            <summary>
            This is a helper class for runtime-callable-wrappers of COM instances. We create one instance of this type
            for every generic RCW instance.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Com.ComObject._rcw">
            <summary>
            The runtime-callable wrapper
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComObject.ObjectToComObject(System.Object)">
            <summary>
            This is the factory method to get the ComObject corresponding to an RCW
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Expression">
            <summary>
            Factory methods.
            TODO: review which of these overloads we actually need
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods
            </summary>
            <summary>
            Expression is the base type for all nodes in Expression Trees
            </summary>
            <summary>
            Factory methods.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Assign(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Annotations)">
            <summary>
            Performs an assignment variable = value
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.AssignField(Microsoft.Linq.Expressions.Expression,System.Reflection.FieldInfo,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Creates MemberExpression representing field access, instance or static.
            For static field, expression must be null and FieldInfo.IsStatic == true
            For instance field, expression must be non-null and FieldInfo.IsStatic == false.
            </summary>
            <param name="expression">Expression that evaluates to the instance for the field access.</param>
            <param name="field">Field represented by this Member expression.</param>
            <param name="value">Value to set this field to.</param>
            <returns>New instance of Member expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.AssignProperty(Microsoft.Linq.Expressions.Expression,System.Reflection.PropertyInfo,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Creates MemberExpression representing property access, instance or static.
            For static properties, expression must be null and property.IsStatic == true.
            For instance properties, expression must be non-null and property.IsStatic == false.
            </summary>
            <param name="expression">Expression that evaluates to the instance for instance property access.</param>
            <param name="property">PropertyInfo of the property to access</param>
            <param name="value">Value to set this property to.</param>
            <returns>New instance of the MemberExpression.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.SimpleCallHelper(System.Reflection.MethodInfo,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Expression.Convert())
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.SimpleCallHelper(Microsoft.Linq.Expressions.Expression,System.Reflection.MethodInfo,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Expression.Convert())
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ComplexCallHelper(System.Reflection.MethodInfo,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            The complex call helper to create the AST method call node.
            Will add conversions (Expression.Convert()), deals with default parameter values and params arrays.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.WeakConstant(System.Object)">
            <summary>
            Wraps the given value in a WeakReference and returns a tree that will retrieve
            the value from the WeakReference.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.NewArrayInit(System.Type,Microsoft.Linq.Expressions.Expression[])">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">A Type that represents the element type of the array.</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">A Type that represents the element type of the array.</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Reduce">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.VisitChildren(Microsoft.Linq.Expressions.ExpressionTreeVisitor)">
            <summary>
            Override this to provide logic to walk the node's children. A
            typical implementation will call visitor.Visit on each of its
            children, and if any of them change, should return a new copy of
            itself with the modified children.
            
            The default implementation will reduce the node and then walk it
            This will throw an exception if the node is not reducible
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReduceAndCheck">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            
            Unlike Reduce, this method checks that the reduced node satisfies
            certain invaraints.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.ReduceExtensions">
            <summary>
            Reduces the expression to a known node type (i.e. not an Extension node)
            or simply returns the expression if it is already a known type.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Creates a list of expressions whose value is void.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Expression.Comma(System.Collections.Generic.IEnumerable{Microsoft.Linq.Expressions.Expression})">
            <summary>
            Creates a list of expressions whose value is the value of the last expression.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Expression.CanReduce">
            <summary>
            Indicates that the node can be reduced to a simpler node. If this 
            returns true, Reduce() can be called to produce the reduced form.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Expression.CanRead">
            <summary>
            Indicates that the node can be read
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Expression.CanWrite">
            <summary>
            Indicates that the node can be written
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.LoopStatement.#ctor(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.LabelTarget,Microsoft.Linq.Expressions.LabelTarget,Microsoft.Linq.Expressions.Annotations)">
            <summary>
            Null test means infinite loop.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Annotations.Add``1(``0)">
            <summary>
            Creates a clone of annotations and adds the value into the clone
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Annotations.Remove``1">
            <summary>
            Returns clone with annotation(s) of type T removed
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.StrongBox`1.Value">
            <summary>
            Gets the strongly typed value associated with the StrongBox.  This is explicitly
            exposed as a field instead of a property to enable loading the address of the field.
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.StrongBox`1.#ctor">
            <summary>
            Creates a new StrongBox which can receive a value when used in a reference call.
            TODO: review this new API
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.CompilerServices.StrongBox`1.#ctor(`0)">
            <summary>
            Creates a new StrongBox with the specified value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CollectionExtensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the provided enumerable into a ReadOnlyCollection{T}
            
            Copies all of the data into a new array, so the data can't be
            changed after creation. The exception is if the enumerable is
            already a ReadOnlyCollection{T}, in which case we just return it.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Compiler.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.VariableBinder">
            <summary>
            Determines if variables are closed over in nested lambdas and need to
            be hoisted.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.VariableBinder.Bind(Microsoft.Linq.Expressions.Compiler.CompilerScope,Microsoft.Linq.Expressions.Expression)">
            <summary>
            VariableBinder entry point. Binds the scope that is passed in.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.StackSpiller">
            <summary>
            Expression rewriting to spill the CLR stack into temporary variables
            in order to guarantee some properties of code generation, for
            example that we always enter try block on empty stack.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.RewriteExpression(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Compiler.StackSpiller.Stack)">
            <summary>
            Rewrite the expression
            </summary>
            
            <param name="node">Expression to rewrite</param>
            <param name="stack">State of the stack before the expression is emitted.</param>
            <returns>Rewritten expression.</returns>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller._tm">
            <summary>
            The source of temporary variables
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.AnalyzeLambda(Microsoft.Linq.Expressions.LambdaExpression)">
            <summary>
            Analyzes a lambda, producing a new one that has correct invariants
            for codegen. In particular, it spills the IL stack to temps in
            places where it's invalid to have a non-empty stack (for example,
            entering a try statement).
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.Clone``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Int32)">
            <summary>
            Will clone an IList into an array of the same size, and copy
            all vaues up to (and NOT including) the max index
            </summary>
            <returns>The cloned array.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.StackSpiller.ToTemp(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression@)">
            <summary>
            Will perform:
                save: temp = expression
                return value: temp
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._temp">
            <summary>
            Current temporary variable
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._freeTemps">
            <summary>
            List of free temporary variables. These can be recycled for new temps.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._usedTemps">
            <summary>
            Stack of currently active temporary variables.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.StackSpiller.TempMaker._temps">
            <summary>
            List of all temps created by stackspiller for this rule/lambda
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.StackSpiller.ChildRewriter">
            <summary>
            Rewrites child expressions, spilling them into temps if needed. The
            stack starts in the inital state, and after the first subexpression
            is added it is change to non-empty. This behavior can be overriden
            by setting the stack manually between adds.
            
            When all children have been added, the caller should rewrite the 
            node if Rewrite is true. Then, it should call crFinish with etiher
            the orignal expression or the rewritten expression. Finish will call
            Expression.Comma if necessary and return a new Result.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.HoistedLocals">
            <summary>
            Stores information about locals and arguments that are hoisted into
            the closure array because they're referenced in an inner lambda.
            
            This class is sometimes emitted as a runtime constant for internal
            use to hoist variables/parameters in quoted expressions
            
            Invariant: this class stores no mutable state
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComEventSinkProxy">
            <summary>
            ComEventSinkProxy class is responsible for handling QIs for sourceIid 
            on instances of ComEventSink.
            
            Background: When a COM even sink advises to a connection point it is 
            supposed to hand over the dispinterface. Now, some hosts will trust
            the COM client to pass the correct pointer, but some will not.
            E.g. Excel's implementation of Connection Points will not cause a
            QI on the pointer that has been passed, however Word will QI the
            pointer to return the required interface.
            
            ComEventSink does not, strongly speaking, implements the interface 
            that it claims to implement - it is just "faking" it by using IReflect.
            Thus, Word's QIs on the pointer passed to ICP::Advise would fail. To
            prevent this we take advangate of RealProxy's ability of
            "dressing up" like other classes and hence successfully respond to QIs 
            for interfaces that it does not really support( it is OK to say 
            "I implement this interface" for event sinks only since the common 
            practice is to use IDistpach.Invoke when calling into event sinks). 
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.AssignmentExpression">
            <summary>
            Represents assignment: Expression = Value. The left had side
            must be a valid lvalue:
              ParameterExpression
              MemberExpression with writable property/field
              IndexExpression
              
            TODO: merge into BinaryExpression
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MatchCaller">
            <summary>
            MatchCaller allows to call match maker delegate with the signature (object, CallSite, object[])
            It is used by the call site cache lookup logic when searching for applicable rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.CreateCustomCaller``1">
            <summary>
            Uses LCG to create method such as this:
            
            object MatchCaller(ActualDelegateType target, CallSite site, object[] args) {
                 return (object)target(site, (T0)args[0], (T1)args[1], (T2)args[2], ...);
            }
            
            inserting appropriate casts and boxings as needed.
            </summary>
            <returns>A MatchCallerTarget delegate.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call1``2(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 1
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call2``3(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 2
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call3``4(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 3
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call4``5(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 4
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call5``6(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 5
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call6``7(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 6
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call7``8(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 7
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call8``9(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7,``8},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 8
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call9``10(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 9
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call10``11(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 10
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call11``12(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 11
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call12``13(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 12
        </member>
        <member name="M:Microsoft.Scripting.Actions.MatchCaller.Call13``14(Microsoft.Func{Microsoft.Scripting.Actions.CallSite,``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},Microsoft.Scripting.Actions.CallSite,System.Object[])">
            Matchcaller - arity 13
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSiteBinder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSiteBinder.Bind``1(System.Object[])">
            <summary>
            The bind call to produce the binding.
            </summary>
            <typeparam name="T">Delegate type</typeparam>
            <param name="args">Array of arguments to the call</param>
            <returns>New rule.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSiteBinder.HashCookie">
            <summary>
            Key used for the DLR caching
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.InvokeBinder.MakeIDispatchInvokeTarget">
            <summary>
            Create a stub for the target of the optimized lopop.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Com.InvokeBinder.MakeArgumentExpressions">
            <summary>
            Gets expressions to access all the arguments. This includes the instance argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.InvokeBinder.GetArgumentNames">
            <summary>
            Gets all of the argument names. The instance argument is not included
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComEventSink">
            <summary>
            This class implements an event sink for a particular RCW.
            Unlike the implementation of events in TlbImp'd assemblies,
            we will create only one event sink per RCW (theoretically RCW might have
            several ComEventSink evenk sinks - but all these implement different source intefaces).
            Each ComEventSink contains a list of ComEventSinkMethod objects - which represent
            a single method on the source interface an a multicast delegate to redirect 
            the calls. Notice that we are chaining multicast delegates so that same 
            ComEventSinkMedhod can invoke multiple event handlers).
            
            ComEventSink implements an IDisposable pattern to Unadvise from the connection point.
            Typically, when RCW is finalized the corresponding Dispose will be triggered by 
            ComEventSinksContainer finalizer. Notice that lifetime of ComEventSinksContainer
            is bound to the lifetime of the RCW. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComEventSink.ComEventSinkMethod">
            <summary>
            Contains a methods DISPID (in a string formatted of "[DISPID=N]"
            and a chained list of delegates to invoke
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.TreeComparer.Compare(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression,System.Collections.Generic.List{Microsoft.Linq.Expressions.ConstantExpression}@,System.Boolean@)">
            <summary>
            Compares two trees.  If the trees differ only by constants then the list of constants which differ
            is provided as a list via an out-param.  The constants collected are the constants in the left
            side of the tree and only include constants which differ in value.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.TreeComparer.FlatTreeWalker">
            <summary>
            Walks all of the nodes of a tree and puts all of the expressions into
            a list.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is
            converted to a null reference. For almost all value types this
            method will box them in the standard way. Int32 and Boolean are
            handled with optimized conversions that reuse the same object for
            small values. For Int32 this is purely a performance optimization.
            For Boolean this is use to ensure that True and False are always
            the same objects.
            
            TODO: do we still need this?
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitArray(System.Type,System.Int32,System.Action{System.Int32})">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DebugILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.StrongBoxArgBuilder">
            <summary>
            An argument that the user wants to explicitly pass by-reference (with copy-in copy-out semantics).
            The user passes a StrongBox[T] object whose value will get updated when the call returns.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ArgBuilder.Unwrap(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ArgBuilder.UnwrapByRef(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            This method is called when result is intended to be used ByRef.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ArgBuilder.UpdateFromReturn(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.  
            May return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ArgBuilder.UpdateFromReturn(Microsoft.Linq.Expressions.Expression,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.
            May return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ArgBuilder.UnwrapForReflection(System.Object)">
            <summary>
            Builds the value of the argument to be passed for a call via reflection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ArgBuilder.UpdateFromReturn(System.Object,System.Object)">
            <summary>
            If the argument produces a return value (e.g. a ref or out value) this
            provides the additional value to be returned.
            This will not be called if the method call throws an exception, and so it should not
            be used for cleanup that is required to be done.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.IDispatchMethodIndices">
            <summary>
            Layout of the IDispatch vtable
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.MemberExpression">
            <summary>
            Member expression (statically typed) which represents 
            property or field access, both static and instance.
            For instance property/field, Expression must be != null.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LabelExpression">
            <summary>
            Represents a label, which can be placed in any Expression context. If
            it is jumped to, it will get the value provided by the corresponding
            GotoExpression. Otherwise, it gets the value in DefaultValue. If the
            Type equals System.Void, no value should be provided
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.LabelExpression.DefaultValue">
            <summary>
            The value of the LabelExpression when the label is reached through
            normal control flow (e.g. is not jumped to)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleCache`1">
            <summary>
            This is a cache of all generated rules (per dynamic site class)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComEventSinksContainer">
            <summary>
            ComEventSinksContainer is just a regular list with a finalizer.
            This list is usually attached as a custom data for RCW object and 
            is finalized whenever RCW is finalized.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LambdaExpression">
            <summary>
            This captures a block of code that should correspond to a .NET method
            body. It takes input through parameters and is expected to be fully
            bound. This code can then be generated in a variety of ways. The
            variables can be kept as .NET locals or hoisted into an object bound to
            the delegate. This is the primary unit used for passing around
            Expression Trees in LINQ and the DLR.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LabelTarget">
            <summary>
            Used to denote the target of a GotoExpression
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.LabelTarget.Type">
            <summary>
            The type of value that is passed when jumping to the label
            (or System.Void if no value should be passed)
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.ILocalVariables">
            <summary>
            Provides read/write access to variables in a scope.
            Created by LocalScopeExpression
            
            TODO: review public API
            TODO: rename !!! (IHoistedVariables?) 
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.DelegateHelpers.MakeCallSiteDelegate(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.Linq.Expressions.Expression},System.Type)">
            <summary>
            Finds a delegate type for a CallSite using the types in the ReadOnlyCollection of Expression. 
            
            We take the ReadOnlyCollection of Expression explicitly to avoid allocating memory (an array of types) on
            lookup of delegate types.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.SynchronizedDictionary`2">
            <summary>
            Dictionary[TKey, TValue] is not thread-safe in the face of concurrent reads and writes. SynchronizedDictionary
            provides a thread-safe implementation. It holds onto a Dictionary[TKey, TValue] instead of inheriting from
            it so that users who need to do manual synchronization can access the underlying Dictionary[TKey, TValue].
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.SynchronizedDictionary`2.UnderlyingDictionary">
            <summary>
            This returns the raw unsynchronized Dictionary[TKey, TValue]. Users are responsible for locking
            on it before accessing it. Also, it should not be arbitrarily handed out to other code since deadlocks
            can be caused if other code incorrectly locks on it.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.LocalScopeExpression">
            <summary>
            An expression that provides runtime read/write access to variables.
            Needed to implement "eval" in dynamic languages.
            Evaluates to an instance of ILocalVariables at run time.
            
            TODO: rename to RuntimeVariablesExpression
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.LocalScopeExpression.Variables">
            <summary>
            The variables or parameters to provide access to
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update1``3(Microsoft.Scripting.Actions.CallSite,``1)">
            <summary>
            Site update code - arity 1
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update2``4(Microsoft.Scripting.Actions.CallSite,``1,``2)">
            <summary>
            Site update code - arity 2
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update3``5(Microsoft.Scripting.Actions.CallSite,``1,``2,``3)">
            <summary>
            Site update code - arity 3
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update4``6(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4)">
            <summary>
            Site update code - arity 4
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update5``7(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5)">
            <summary>
            Site update code - arity 5
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update6``8(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6)">
            <summary>
            Site update code - arity 6
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update7``9(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Site update code - arity 7
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update8``10(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            Site update code - arity 8
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update9``11(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            Site update code - arity 9
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update10``12(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>
            Site update code - arity 10
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update11``13(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>
            Site update code - arity 11
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update12``14(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>
            Site update code - arity 12
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update13``15(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>
            Site update code - arity 13
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update14``16(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>
            Site update code - arity 14
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.Update15``17(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15)">
            <summary>
            Site update code - arity 15
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid1``2(Microsoft.Scripting.Actions.CallSite,``1)">
            <summary>
            Site update code - arity 1
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid2``3(Microsoft.Scripting.Actions.CallSite,``1,``2)">
            <summary>
            Site update code - arity 2
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid3``4(Microsoft.Scripting.Actions.CallSite,``1,``2,``3)">
            <summary>
            Site update code - arity 3
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid4``5(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4)">
            <summary>
            Site update code - arity 4
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid5``6(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5)">
            <summary>
            Site update code - arity 5
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid6``7(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6)">
            <summary>
            Site update code - arity 6
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid7``8(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Site update code - arity 7
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid8``9(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            Site update code - arity 8
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid9``10(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            Site update code - arity 9
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid10``11(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>
            Site update code - arity 10
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid11``12(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>
            Site update code - arity 11
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid12``13(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>
            Site update code - arity 12
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid13``14(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>
            Site update code - arity 13
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid14``15(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>
            Site update code - arity 14
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.UpdateDelegates.UpdateVoid15``16(Microsoft.Scripting.Actions.CallSite,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15)">
            <summary>
            Site update code - arity 15
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ListStack`1">
            <summary>
            A stack implemented as a list. Allows both Push/Pop access and indexing into any member of the list.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.Peek">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.Pop">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ListStack`1.GetEnumerator">
            <summary>
            Enumerates from the top of the stack to the bottom.
            </summary>
            <exception cref="T:System.InvalidOperationException">Stack has been modified during enumeration.</exception>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.IsConstant(Microsoft.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(Microsoft.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            If the result of a TypeBinaryExpression is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(Microsoft.Linq.Expressions.UnaryExpression)">
            <summary>
            If the result of a unary TypeAs expression is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(Microsoft.Linq.Expressions.Expression,System.Type)">
            <summary>
            If the result of an isinst opcode is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.IndexExpression">
            <summary>
            Represents property or array indexing
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.IndexExpression.Indexer">
            <summary>
            If this is an indexed property, returns the property
            If this is an array indexing operation, returns null
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.SplatCallSite.MakeBigCaller(System.Int32)">
            <summary>
            Uses LCG to create method such as this:
            
            object SplatCaller(CallSite{T} site, object[] args) {
                 return site.Target(site, args[0], args[1], args[2], ...);
            }
            
            where the CallSite is bound to the delegate
            </summary>
            <param name="args">the number of arguments</param>
            <returns>a SplatCaller delegate.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Actions.SmallRuleSet`1">
            <summary>
            This holds a set of rules for a particular DynamicSite.  Any given
            SmallRuleSet instance is immutable and therefore they may be cached
            and shared.  At the moment, the only ones that are shared are
            SmallRuleSets with a single rule.
            
            When a new rule is added, then a new SmallRuleSet will be created
            that contains all existing rules that are still considered valid with
            the new rule added to the front of the list.  The target generated for
            this type will simply try each of the rules in order and emit the
            standard DynamicSite.UpdateBindingAndInvoke fallback call at the end.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleSet`1">
            <summary>
            A RuleSet is a collection of rules to apply to the objects at a DynamicSite.  Each Rule also
            includes a target that is to be called if the rules' conditions are met.
            RuleSets are all immutable.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._mySet">
            <summary>
            The rule set that includes only this rule.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._parameters">
            <summary>
            The parameters to the rule
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._binding">
            <summary>
            The binding expression tree
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._returnLabel">
            <summary>
            The return label
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Rule`1._template">
            <summary>
            Template data - null for methods which aren't templated.  Non-null for methods which
            have been templated.  The same template data is shared across all templated rules with
            the same target method.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.RuleSet">
            <summary>
            Each rule holds onto an immutable RuleSet that contains this rule only.
            This should heavily optimize monomorphic call sites.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.Parameters">
            <summary>
            Gets the logical parameters to the dynamic site in the form of Variables.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.Binding">
            <summary>
            The expression representing the bound operation
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.ReturnLabel">
            <summary>
            The label used to return from the rule
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Rule`1.TemplateMethod">
            <summary>
            Gets or sets the method which is used for templating. If the rule is
            not templated then this is a nop (and returns null for the getter).
            
            The method is tracked here independently from the delegate for the
            common case of the method being a DynamicMethod.  In order to re-bind
            the existing DynamicMethod to a new set of templated parameters we need
            to have the original method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TemplateData`1">
            <summary>
            Data used for tracking templating information in a rule.
            
            Currently we just track the method so we can retarget to
            new constant pools.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Matchmaker">
            <summary>
            This class is used to look for matching rules in the caches
            by executing individual rules against the site whose fallback
            code delegates here.
            </summary>
            <summary>
            This class is used to look for matching rules in the caches
            by executing individual rules against the site whose fallback
            code delegates here.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSite">
            <summary>
            A Dynamic Call Site base class. This type is used as a parameter type to the
            dynamic site targets. The first parameter of the delegate (T) below must be
            of this type.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite._binder">
            <summary>
            The Binder responsible for binding operations at this call site.
            This binder is invoked by the UpdateAndExecute below if all Level 0,
            Level 1 and Level 2 caches experience cache miss.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSite.Binder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSite`1">
            <summary>
            Dynamic site type.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1.Update">
            <summary>
            The update delegate. Called when the dynamic site experiences cache miss
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1.Target">
            <summary>
            The Level 0 cache - a delegate specialized based on the site history.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1._rules">
            <summary>
            The Level 1 cache - a history of the dynamic site
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSite`1._cache">
            <summary>
            The Level 2 cache - all rules produced for the same generic instantiation
            of the dynamic site (all dynamic sites with matching delegate type).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSite`1.UpdateAndExecute(System.Object[])">
            <summary>
            Gets a rule, updates the site that called, and then returns the result of executing the rule.
            
            This method is called on a level 0 cache miss.
            </summary>
            <param name="args">The arguments to the rule as provided from the call site at runtime.</param>
            <returns>The result of executing the rule.</returns>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionWriter.Dump(Microsoft.Linq.Expressions.Expression,System.String)">
            <summary>
            Write out the given AST (only if ShowTrees or DumpTrees is enabled)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionWriter.Dump``1(Microsoft.Scripting.Actions.Rule{``0},Microsoft.Scripting.Actions.CallSiteBinder)">
            <summary>
            Write out the given rule's AST (only if ShowRules is enabled)
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.ExpressionWriter.Dump(Microsoft.Linq.Expressions.Expression,System.String,System.IO.TextWriter)">
            <summary>
            Write out the given AST
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.CompilerScope">
            <summary>
            CompilerScope is the data structure which the Compiler keeps information
            related to compiling scopes. It stores the following information:
              1. Parent relationship (for resolving variables)
              2. Information about hoisted variables
              3. Information for resolving closures
            
            Instances are produced by VariableBinder, which does a tree walk
            looking for scope nodes: LambdaExpression and ScopeExpression.
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope.MergedScopes">
            <summary>
            Scopes that were merged into this one, so we remember not to bind them
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope._closureHoistedLocals">
            <summary>
            The closed over hoisted locals
            </summary>
        </member>
        <member name="F:Microsoft.Linq.Expressions.Compiler.CompilerScope._cachedVars">
            <summary>
            Variables that should be cached into locals, if they're hoisted
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.EnterLambda(Microsoft.Linq.Expressions.Compiler.LambdaCompiler)">
            <summary>
            Called when entering a lambda. Performs all variable allocation
            needed, including creating hoisted locals and IL locals for accessing
            parent locals
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.EnterScope(Microsoft.Linq.Expressions.Compiler.LambdaCompiler)">
            <summary>
            Called when entering a scope. Performs all variable allocation
            needed, including creating hoisted locals and IL locals for accessing
            parent locals
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.AddLocal(Microsoft.Linq.Expressions.Compiler.LambdaCompiler,Microsoft.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds a new virtual variable corresponding to an IL local
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Compiler.CompilerScope.ResolveVariable(Microsoft.Linq.Expressions.ParameterExpression,Microsoft.Linq.Expressions.Compiler.HoistedLocals)">
            <summary>
            Resolve a local variable in this scope or a closed over scope
            Throws if the variable is defined
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Compiler.CompilerScope.HasHoistedLocals">
            <summary>
            Indicates that this scope has hoisted variables
            
            These are either closed over from a parent scope, or hoisted so we
            can provide access via the Expression.LocalVariables() intrinsic.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Compiler.CompilerScope.NearestHoistedLocals">
            <summary>
            This scope's hoisted locals, or the closed over locals, if any
            Equivalent to: _hoistedLocals ?? _closureHoistedLocals
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ReturnBuilder.#ctor(System.Type)">
            <summary>
            Creates a ReturnBuilder
            </summary>
            <param name="returnType">the type the ReturnBuilder will leave on the stack</param>
        </member>
        <member name="T:Microsoft.Scripting.Com.NullArgBuilder">
            <summary>
            ArgBuilder which always produces null.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.DispCallable">
            <summary>
            This represents a bound dispmethod on a IDispatch object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComParamDesc">
            <summary>
            The parameter description of a method defined in a type library
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@,System.String)">
            <summary>
            Creates a representation for the paramter of a COM method
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@)">
            <summary>
            Creates a representation for the return value of a COM method
            TODO: Return values should be represented by a different type
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Com.ComParamDesc.DefaultValue">
            <summary>
            DBNull.Value if there is no default value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceSpan">
            <summary>
            Stores the location of a span of text in a source file.
            TODO: move to Microsoft.Linq.Expressions
            TODO: review public APIs !!!
                  Lots of stuff on here that is not used by the compiler
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.#ctor(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Constructs a new span with a specific start and end location.
            </summary>
            <param name="start">The beginning of the span.</param>
            <param name="end">The end of the span.</param>
        </member>
        <member name="F:Microsoft.Scripting.SourceSpan.None">
            <summary>
            A valid span that represents no location.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceSpan.Invalid">
            <summary>
            An invalid span.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.op_Equality(Microsoft.Scripting.SourceSpan,Microsoft.Scripting.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceSpan.op_Inequality(Microsoft.Scripting.SourceSpan,Microsoft.Scripting.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are not equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are not the same, False otherwise.</returns>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.Start">
            <summary>
            The start location of the span.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.End">
            <summary>
            The end location of the span. Location of the first character behind the span.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.Length">
            <summary>
            Length of the span (number of characters inside the span).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceSpan.IsValid">
            <summary>
            Whether the locations in the span are valid.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.SourceFileInformation">
            <summary>
            Stores information needed to emit debugging symbol information for a
            source file, in particular the file name and unique language identifier
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SourceFileInformation.FileName">
            <summary>
            The source file name
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SourceFileInformation.LanguageGuid">
            <summary>
            Returns the language's unique identifier, if any
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.SourceFileInformation.VendorGuid">
            <summary>
            Returns the language vendor's unique identifier, if any
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExpandoClass">
            <summary>
            Represents a dynamically assigned class.  Expando objects which share the same 
            members will share the same class.  Classes are dynamically assigned as the
            expando object gains members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.#ctor">
            <summary>
            Constructs the empty ExpandoClass.  This is the class used when an
            empty Expando object is initially constructed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.#ctor(System.String[],System.Int32)">
            <summary>
            Constructs a new ExpandoClass that can hold onto the specified keys.  The
            keys must be sorted ordinally.  The hash code must be precalculated for 
            the keys.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.FindNewClass(System.String,System.Boolean)">
            <summary>
            Finds or creates a new ExpandoClass given the existing set of keys
            in this ExpandoClass plus the new key to be added.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.GetNewKeys(System.Object[])">
            <summary>
            Gets a new object array for storing the data that matches this
            ExpandoClass given the old ExpandoClass and the instances associated 
            data array.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.GetTransitionList(System.Int32)">
            <summary>
            Gets the lists of transitions that are valid from this ExpandoClass
            to an ExpandoClass whos keys hash to the apporopriate hash code.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.GetValueIndex(System.String,System.Boolean)">
            <summary>
            Gets the index at which the value should be stored for the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoClass.GetIndexName(System.Int32)">
            <summary>
            Gets the name of the specified index.  Used for getting the name to 
            create a new expando class when all we have is the class and old index.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ExpandoClass.Keys">
            <summary>
            Gets the names of the keys that can be stored in the Expando class.  The
            list is sorted ordinally.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.None">
            <summary>
            Gives us a concrete Type object to represent null's to allow for more uniform
            handling of methods that expect a Type or Type[].  This type can also be used by
            languages that support methods on null objects by adding extension methods with a
            Null/None this.
            
            TODO Should be renamed to Null to reflect the standard .NET name rather than Python name
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.None.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CacheDict`2">
            <summary>
            Provides a dictionary-like object used for caches which holds onto a maximum
            number of elements specified at construction time.
            
            This class is not thread safe.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ExcepInfo">
            <summary>
            This is similar to ComTypes.EXCEPINFO, but lets us do our own custom marshaling
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.TryStatement">
            <summary>
            Represents a try/catch/finally/fault block.
            
            The body is protected by the try block.
            The handlers consist of a set of CatchBlocks that can either be catch or filters.
            The fault runs if an exception is thrown.
            The finally runs regardless of how control exits the body.
            Only fault or finally can be supplied
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.RuleTree`1">
            <summary>
            This uses linear search to find a rule.  Clearly that doesn't scale super well.
            We will address this in the future.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.Scripting.Actions.RuleTree`1.FindApplicableRules(System.Type[])">
            <summary>
            Looks through the rule list, prunes invalid rules and returns rules that apply
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.Set`1">
            <summary>
            A simple hashset, built on Dictionary{K, V}
            
            TODO: should remove this in favor of HashSet{T}
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.IDispatchObject">
            <summary>
            The object used to cache information about an IDispatch RCW object. This will be associated with
            every IDispatch RCW that is handled by the DLR.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.IDispatchObject.GetDispatchPointerInCurrentApartment">
            <summary>
            The caller should also call ReleaseDispatchPointer.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.IDispatchComObject">
            <summary>
            An object that implements IDispatch
            
            This currently has the following issues:
            1. If we prefer ComObjectWithTypeInfo over IDispatchObject, then we will often not
               IDispatchObject since implementations of IDispatch often rely on a registered type library. 
               If we prefer IDispatchObject over ComObjectWithTypeInfo, users get a non-ideal experience.
            2. IDispatch cannot distinguish between properties and methods with 0 arguments (and non-0 
               default arguments?). So obj.foo() is ambiguous as it could mean invoking method foo, 
               or it could mean invoking the function pointer returned by property foo.
               We are attempting to find whether we need to call a method or a property by examining
               the ITypeInfo associated with the IDispatch. ITypeInfo tell's use what parameters the method
               expects, is it a method or a property, what is the default property of the object, how to 
               create an enumerator for collections etc.
            3. IronPython processes the signature and converts ref arguments into return values. 
               However, since the signature of a DispMethod is not available beforehand, this conversion 
               is not possible. There could be other signature conversions that may be affected. How does 
               VB6 deal with ref arguments and IDispatch?
               
            We also support events for IDispatch objects:
            Background:
            COM objects support events through a mechanism known as Connect Points.
            Connection Points are separate objects created off the actual COM 
            object (this is to prevent circular references between event sink
            and event source). When clients want to sink events generated  by 
            COM object they would implement callback interfaces (aka source 
            interfaces) and hand it over (advise) to the Connection Point. 
            
            Implementation details:
            When IDispatchObject.TryGetMember request is received we first check
            whether the requested member is a property or a method. If this check
            fails we will try to determine whether an event is requested. To do 
            so we will do the following set of steps:
            1. Verify the COM object implements IConnectionPointContainer
            2. Attempt to find COM object's coclass's description
               a. Query the object for IProvideClassInfo interface. Go to 3, if found
               b. From object's IDispatch retrieve primary interface description
               c. Scan coclasses declared in object's type library.
               d. Find coclass implementing this particular primary interface 
            3. Scan coclass for all its source interfaces.
            4. Check whether to any of the methods on the source interfaces matches 
            the request name
            
            Once we determine that TryGetMember requests an event we will return
            an instance of BoundDispEvent class. This class has InPlaceAdd and
            InPlaceSubtract operators defined. Calling InPlaceAdd operator will:
            1. An instance of ComEventSinksContainer class is created (unless 
            RCW already had one). This instance is hanged off the RCW in attempt
            to bind the lifetime of event sinks to the lifetime of the RCW itself,
            meaning event sink will be collected once the RCW is collected (this
            is the same way event sinks lifetime is controlled by PIAs).
            Notice: ComEventSinksContainer contains a Finalizer which will go and
            unadvise all event sinks.
            Notice: ComEventSinksContainer is a list of ComEventSink objects. 
            2. Unless we have already created a ComEventSink for the required 
            source interface, we will create and advise a new ComEventSink. Each
            ComEventSink implements a single source interface that COM object 
            supports. 
            3. ComEventSink contains a map between method DISPIDs to  the 
            multicast delegate that will be invoked when the event is raised.
            4. ComEventSink implements IReflect interface which is exposed as
            custom IDispatch to COM consumers. This allows us to intercept calls
            to IDispatch.Invoke and apply custom logic - in particular we will
            just find and invoke the multicast delegate corresponding to the invoked
            dispid.
             </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExpandoObject">
            <summary>
            Simple type which implements IDynamicObject to support getting/setting/deleting members
            at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.#ctor">
            <summary>
            Creates a new Expando object with no members.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.GetValue(Microsoft.Scripting.Actions.ExpandoClass,System.Int32,System.Boolean)">
            <summary>
            Gets the data stored for the specified class at the specified index.  If the
            class has changed a full lookup for the slot will be performed and the correct
            value will be retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.SetValue(Microsoft.Scripting.Actions.ExpandoClass,System.Int32,System.Boolean,System.Object)">
            <summary>
            Sets the data for the specified class at the specified index.  If the class has
            changed then a full look for the slot will be performed.  If the new class does
            not have the provided slot then the Expando's class will change.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.DeleteValue(Microsoft.Scripting.Actions.ExpandoClass,System.Int32,System.Boolean)">
            <summary>
            Gets the data stored for the specified class at the specified index.  If the
            class has changed a full lookup for the slot will be performed and the correct
            value will be retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.PromoteClassWorker(Microsoft.Scripting.Actions.ExpandoClass,Microsoft.Scripting.Actions.ExpandoClass)">
            <summary>
            Promotes the class from the old type to the new type and returns the new
            ExpandoData object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.PromoteClass(Microsoft.Scripting.Actions.ExpandoClass,Microsoft.Scripting.Actions.ExpandoClass)">
            <summary>
            Internal helper to promote a class.  Called from our RuntimeOps helper.  This
            version simply doesn't expose the ExpandoData object which is a private
            data structure.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ExpandoObject.Class">
            <summary>
            Exposes the ExpandoClass which we've associated with this 
            Expando object.  Used for type checks in rules.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.MetaExpando.AddDynamicTestAndDefer(Microsoft.Scripting.Actions.MetaAction,Microsoft.Scripting.Actions.MetaObject[],Microsoft.Scripting.Actions.ExpandoClass,Microsoft.Scripting.Actions.ExpandoClass,Microsoft.Linq.Expressions.Expression)">
            <summary>
            Adds a dynamic test which checks if the version has changed.  The test is only necessary for
            performance as the methods will do the correct thing if called with an incorrect version.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.MetaExpando.GetClassEnsureIndex(System.String,System.Boolean,Microsoft.Scripting.Actions.ExpandoClass@,System.Int32@)">
            <summary>
            Gets the class and the index associated with the given name.  Does not update the expando object.  Instead
            this returns both the original and desired new class.  A rule is created which includes the test for the
            original class, the promotion to the new class, and the set/delete based on the class post-promotion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.MetaExpando.GetLimitedSelf">
            <summary>
            Returns our Expression converted to our known LimitType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.MetaExpando.GetRestrictions">
            <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExpandoObject.ExpandoData">
            <summary>
            Stores the class and the data associated with the class as one atomic
            pair.  This enables us to do a class check in a thread safe manner w/o
            requiring locks.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ExpandoObject.ExpandoData.Class">
            <summary>
            the dynamically assigned class associated with the Expando object
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ExpandoObject.ExpandoData.Data">
            <summary>
            data stored in the expando object, key names are stored in the class.
            
            Expando._data must be locked when mutating the value.  Otherwise a copy of it 
            could be made and lose values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.ExpandoData.#ctor">
            <summary>
            Constructs an empty ExpandoData object with the empty class and no data.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ExpandoObject.ExpandoData.#ctor(Microsoft.Scripting.Actions.ExpandoClass,System.Object[])">
            <summary>
            Constructs a new ExpandoData object with the specified class and data.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresListRange(System.Collections.IList,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.LocalVariableAccess">
            <summary>
            Provides a list of local variables, supporing read/write of elements
            Exposed via LocalScopeExpression
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Dynamic">
            <summary>
            Provides a simple class that can be inherited from to create an object with dynamic behavior
            at runtime.  Subclasses can override the various action methods (GetMember, SetMember, Call, etc...)
            to provide custom behavior that will be invoked at runtime.  
            
            If a method is not overridden then the Dynamic object does not directly support that behavior and 
            the call site will determine how the action should be performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.#ctor">
            <summary>
            Enables derived types to create a new instance of Dynamic.  Dynamic instances cannot be
            directly instantiated because they have no implementation of dynamic behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.GetMember(Microsoft.Scripting.Actions.GetMemberAction)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of getting a member.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.SetMember(Microsoft.Scripting.Actions.SetMemberAction,System.Object)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of setting a member.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.DeleteMember(Microsoft.Scripting.Actions.DeleteMemberAction)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of deleting a member.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.Call(Microsoft.Scripting.Actions.CallAction,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of calling a member
            in the expando.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.Convert(Microsoft.Scripting.Actions.ConvertAction)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of converting the
            Dynamic object to another type.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.Create(Microsoft.Scripting.Actions.CreateAction,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of creating an instance
            of the Dynamic object.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.Invoke(Microsoft.Scripting.Actions.InvokeAction,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of invoking the
            Dynamic object.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.Operation(Microsoft.Scripting.Actions.OperationAction,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of performing
            the operation.
            
            When not overridden the call site requesting the action determines the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.GetMetaObject(Microsoft.Linq.Expressions.Expression)">
            <summary>
            Can be overridden in the derived class.  The provided
            MetaObject will dispatch to the Dynamic virtual methods.  The
            object can be encapsulated inside of another MetaObject to
            provide custom behavior for individual actions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.CallMethodUnary(Microsoft.Scripting.Actions.MetaAction,System.String)">
            <summary>
            Helper method for generating a MetaObject which calls a specific method on Dynamic
            w/o any additional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.CallMethodBinary(Microsoft.Scripting.Actions.SetMemberAction,Microsoft.Scripting.Actions.MetaObject,System.String)">
            <summary>
            Helper method for generating a MetaObject which calls a specific method declared on
            Dynamic w/ one additional parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.CallMethodNAry(Microsoft.Scripting.Actions.MetaAction,Microsoft.Scripting.Actions.MetaObject[],System.String)">
            <summary>
            Helper method for generating a MetaObject which calls a specific method on Dynamic w/ the
            meta object array as the params.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.GetActionToArgs(Microsoft.Scripting.Actions.MetaAction,Microsoft.Scripting.Actions.MetaObject[])">
            <summary>
            Returns the parameters for a call to one of our helpers.  It adds the MetaAction
            first and packs the parameters into an object array.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.IsOverridden(System.String)">
            <summary>
            Checks if the derived type has overridden the specified method.  If there is no
            implementation for the method provided then Dynamic falls back to the base class
            behavior which lets the call site determine how the action is performed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.GetRestrictions">
            <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Dynamic.MetaDynamic.GetLimitedSelf">
            <summary>
            Returns our Expression converted to our known LimitType
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.DebugOptions">
            <summary>
            This class holds onto internal debugging options of the compiler and
            dynamic sites. These options can be set via environment variables
            DLR_{option-name}. Boolean options map "true" to true and other values
            to false.
            
            These options are for internal debugging only, and should not be
            exposed through any public APIs.
            
            Note: all of these options are DEBUG only, except for
            PreferComInteropAssembly which only exists in the
            Microsoft.Scripting.Core build. It needs to be removed, or be
            controlled in some way other than an environment variable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.ShowTrees">
            <summary>
            Print generated Abstract Syntax Trees to the console
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.DumpTrees">
            <summary>
            Write out generated Abstract Syntax Trees as files in the current directory
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.ShowRules">
            <summary>
            Print generated action dispatch rules to the console
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.ShowScopes">
            <summary>
            Print the scopes and closures that get generated by the compiler
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.DumpIL">
            <summary>
            Write IL to a text file as it is generated.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.ShowIL">
            <summary>
            Prints the IL to the console as it is generated.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.CachePointersInApartment">
            <summary>
            An RCW object represents a COM object which could potentially be in another apartment. So access
            to the COM interface pointer needs to be done in an apartment-safe way. Marshal.GetIDispatchForObject
            gives out the the appropriate interface pointer (and doing marshalling of the COM object to the current
            aparment if necessary). However, this is expensive and we would like to cache the returned interface pointer.
            This is a prototype of the caching optimization. It is not ready for primte-time use. Currently, it will
            leak COM objects as it does not call Marshal.Release when it should.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.PreferComInteropAssembly">
            <summary>
            Use pure IDispatch-based invocation when calling methods/properties
            on System.__ComObject
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.SnippetsFileName">
            <summary>
            Name of the snippet assembly (w/o extension).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.DebugOptions.SaveSnippets">
            <summary>
            Save snippets to an assembly (see also SnippetsDirectory, SnippetsFileName).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.VariantBuilder">
            <summary>
            VariantBuilder handles packaging of arguments into a Variant for a call to IDispatch.Invoke
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.DynamicExpression">
            <summary>
            A late-bound operation. The precise semantics is determined by the
            Binder. If the Binder is one of the standard dynamic operations
            supported by MetaObject, the run-time behavior can be infered from the
            StandardAction
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.Binder">
            <summary>
            The CallSiteBinder, which determines the runtime behavior of the
            dynamic site
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.DelegateType">
            <summary>
            The type of the CallSite's delegate
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.Arguments">
            <summary>
            Arguments to the dynamic operation
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.DynamicExpression.StandardAction">
            <summary>
            If the CallSiteBinder is a StandardAction, this returns it.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.Helpers.RepeatedArray``1(``0,System.Int32)">
            <summary>
            Creates an array of size count with each element initialized to item
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Strings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            A string like  "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            A string like  "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            A string like  "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            A string like  "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            A string like  "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotAutoInitializeValueTypeElementThroughProperty(System.Object)">
            <summary>
            A string like  "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotAutoInitializeValueTypeMemberThroughProperty(System.Object)">
            <summary>
            A string like  "Cannot auto initialize members of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotCastTypeToType(System.Object,System.Object)">
            <summary>
            A string like  "An expression of type '{0}' cannot be cast to type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            A string like  "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            A string like  "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchConstructorParameter(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ArgumentTypeDoesNotMatchMember(System.Object,System.Object)">
            <summary>
            A string like  " Argument type '{0}' does not match the corresponding member type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ArgumentMemberNotDeclOnType(System.Object,System.Object)">
            <summary>
            A string like  " The member '{0}' is not declared on type '{1}' being created"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchMethodParameter(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchParameter(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchReturn(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for return type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchAssignment(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for assignment to type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchLabel(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for label of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ExpressionTypeNotInvocable(System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be invoked"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            A string like  "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MemberNotFieldOrProperty(System.Object)">
            <summary>
            A string like  "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodContainsGenericParameters(System.Object)">
            <summary>
            A string like  "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodIsGeneric(System.Object)">
            <summary>
            A string like  "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            A string like  "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyDoesNotHaveSetter(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'set' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyDoesNotHaveAccessor(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'get' or 'set' accessors"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            A string like  "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OperatorNotImplementedForType(System.Object,System.Object)">
            <summary>
            A string like  "The operator '{0}' is not implemented for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ParameterExpressionNotValidAsDelegate(System.Object,System.Object)">
            <summary>
            A string like  "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Method '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeContainsGenericParameters(System.Object)">
            <summary>
            A string like  "Type {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeIsGeneric(System.Object)">
            <summary>
            A string like  "Type {0} is a generic type definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeMissingDefaultConstructor(System.Object)">
            <summary>
            A string like  "Type '{0}' does not have a default constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodNoRefOutParam(System.Object,System.Object)">
            <summary>
            A string like  "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeNotIEnumerable(System.Object)">
            <summary>
            A string like  "Type '{0}' is not IEnumerable"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            A string like  "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidCast(System.Object,System.Object)">
            <summary>
            A string like  "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledBinary(System.Object)">
            <summary>
            A string like  "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledBindingType(System.Object)">
            <summary>
            A string like  "Unhandled Binding Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledConvert(System.Object)">
            <summary>
            A string like  "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledExpressionType(System.Object)">
            <summary>
            A string like  "Unhandled Expression Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnhandledUnary(System.Object)">
            <summary>
            A string like  "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LogicalOperatorMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            A string like  "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            A string like  "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            A string like  "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.ArgumentCountMustMatchBinding(System.Object,System.Object)">
            <summary>
            A string like  "Argument count (including instance) '{0}' must match arguments in the binding information '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidOperation(System.Object)">
            <summary>
            A string like  "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.OutOfRange(System.Object,System.Object)">
            <summary>
            A string like  "{0} must be greater than or equal to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.TypeLibDoesNotContainInterface(System.Object,System.Object)">
            <summary>
            A string like  "TypeLib '{0}' does not contain COM interface '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnexpectedVarEnum(System.Object)">
            <summary>
            A string like  "Unexpected VarEnum {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.DispBadParamCount(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.DispMemberNotFound(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.DispNoNamedArgs(System.Object)">
            <summary>
            A string like  "Error while invoking {0}. Named arguments are not supported."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.DispOverflow(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.DispTypeMismatch(System.Object,System.Object)">
            <summary>
            A string like  "Could not convert argument {0} for call to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.DispParamNotOptional(System.Object)">
            <summary>
            A string like  "Error while invoking {0}. A required parameter was omitted."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.GetIDsOfNamesInvalid(System.Object)">
            <summary>
            A string like  "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CouldNotGetDispId(System.Object,System.Object)">
            <summary>
            A string like  "Could not get DispId for {0} (error:{1})."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.AmbiguousConversion(System.Object,System.Object)">
            <summary>
            A string like  "There are valid conversions from {0} to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.VariantToObjectNYI(System.Object)">
            <summary>
            A string like  "Variant.ToObject cannot handle {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.VariantGetAccessorNYI(System.Object)">
            <summary>
            A string like  "Variant.GetAccessor cannot handle {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LabelTargetAlreadyDefined(System.Object)">
            <summary>
            A string like  "Cannot redefine label '{0}' in an inner block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.LabelTargetUndefined(System.Object)">
            <summary>
            A string like  "Cannot jump to to undefined label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.AmbiguousJump(System.Object)">
            <summary>
            A string like  "Cannot jump to ambiguous label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidLvalue(System.Object)">
            <summary>
            A string like  "Invalid lvalue for assignment: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidMemberType(System.Object)">
            <summary>
            A string like  "Invalid member type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnknownLiftType(System.Object)">
            <summary>
            A string like  "unknown lift type: '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            A string like  "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.NoImplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.NoExplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.IllegalNewGenericParams(System.Object)">
            <summary>
            A string like  "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnboundVariable(System.Object,System.Object)">
            <summary>
            A string like  "Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UndefinedVariable(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.InvalidReturnTypeOfLambda(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MissingReturnForLambda(System.Object,System.Object)">
            <summary>
            A string like  "Expression missing for return in lambda '{0}', must have return type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.CannotCloseOverByRef(System.Object,System.Object)">
            <summary>
            A string like  "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnexpectedType(System.Object,System.Object)">
            <summary>
            A string like  "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.UnexpectedVarArgsCall(System.Object)">
            <summary>
            A string like  "Unexpected VarArgs call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.MustRewriteToSameType(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "When called from '{0}', rewriting a node of type '{1}' should return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Strings.RuntimeVariablesNotSupportedInQuote(System.Object)">
            <summary>
            A string like  "A Quote expression cannot be used on RuntimeVariables expression '{0}' because at least one variable is declared outside the Quote"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OwningTeam">
            <summary>
            A string like  "DLinq"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MethodPreconditionViolated">
            <summary>
            A string like  "Method precondition violated"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidArgumentValue">
            <summary>
            A string like  "Invalid argument value"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NonEmptyStringRequired">
            <summary>
            A string like  "Non-empty string required"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NonEmptyCollectionRequired">
            <summary>
            A string like  "Non-empty collection required"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustBePositive">
            <summary>
            A string like  "must be &gt;= 0"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArrayIndexMustBeInt">
            <summary>
            A string like  "Array index must be an int."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArrayArgumentMustBeArray">
            <summary>
            A string like  "Array argument must be array."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectIndicesCount">
            <summary>
            A string like  "Incorrect number of indices."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ValueTypeMustMatchElementType">
            <summary>
            A string like  "Value type must match the array element type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RhsMustBeAssignableToLhs">
            <summary>
            A string like  "right side must be assignable to left side"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ReducibleMustOverrideReduce">
            <summary>
            A string like  "reducible nodes must override Expression.Reduce()"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustReduceToDifferent">
            <summary>
            A string like  "node cannot reduce to itself or null"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ReducedNotCompatible">
            <summary>
            A string like  "cannot assign from the reduced node type to the original node type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NoGetterSetter">
            <summary>
            A string like  "No getter or setter specified"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SetterHasNoParams">
            <summary>
            A string like  "Setter must have parameters."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyCannotHaveRefType">
            <summary>
            A string like  "Property cannot have a managed pointer type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IndexesOfSetGetMustMatch">
            <summary>
            A string like  "Indexing parameters of getter and setter must match."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.AccessorsCannotHaveVarArgs">
            <summary>
            A string like  "Accessor method should not have VarArgs."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.AccessorsCannotHaveByRefArgs">
            <summary>
            A string like  "Accessor indexes cannot be passed ByRef."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectInstanceTypeField">
            <summary>
            A string like  "Incorrect instance type for the field"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectValueTypeField">
            <summary>
            A string like  "Incorrect value type for the field"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectinstanceTypeProperty">
            <summary>
            A string like  "Incorrect instance type for the property"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SetMustHaveParams">
            <summary>
            A string like  "set method must have at least one parameter"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectValueTypeForProperty">
            <summary>
            A string like  "Incorrect value type for the property"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustBeStatic">
            <summary>
            A string like  "Method must be static"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectArgNumber">
            <summary>
            A string like  "Incorrect number of arguments"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentNotProvided">
            <summary>
            A string like  "Argument not provided for a mandatory parameter"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BoundsCannotBeLessThanOne">
            <summary>
            A string like  "Bounds count cannot be less than 1"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ValueMustBeInt">
            <summary>
            A string like  "Value must be int"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyDefaultIsAllowed">
            <summary>
            A string like  "Only one default clause allowed"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CaseValuesMustBeUnique">
            <summary>
            A string like  "Case values must be unique"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeMustNotBeByRef">
            <summary>
            A string like  "type must not be ByRef"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.VariableMustNotBeByRef">
            <summary>
            A string like  "variable must not be ByRef"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OperationKindMustMatchNodeType">
            <summary>
            A string like  "operation kind must match node type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustHaveAtLeastTarget">
            <summary>
            A string like  "Must receive at least one argument, the target to call"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyDoesNotExist">
            <summary>
            A string like  "Property doesn't exist on the provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.FieldDoesNotExist">
            <summary>
            A string like  "Field doesn't exist on provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeDoesNotHaveConstructorForTheSignature">
            <summary>
            A string like  "Type doesn't have constructor with a given signature"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeDoesNotHaveMethodForName">
            <summary>
            A string like  "Type doesn't have a method with a given name."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeDoesNotHaveMethodForNameSignature">
            <summary>
            A string like  "Type doesn't have a method with a given name and signature."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CountCannotBeNegative">
            <summary>
            A string like  "Count must be non-negative."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArrayTypeMustBeArray">
            <summary>
            A string like  "arrayType must be an array type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SetterMustBeVoid">
            <summary>
            A string like  "Setter should have void type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyTyepMustMatchSetter">
            <summary>
            A string like  "Property type must match the value type of setter"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BothAccessorsMustBeStatic">
            <summary>
            A string like  "Both accessors must be static."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyStaticFieldsHaveNullExpr">
            <summary>
            A string like  "Static field requires null expression, non-static field requires non-null expression."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyStaticPropertiesHaveNullExpr">
            <summary>
            A string like  "Static property requires null expression, non-static property requires non-null expression."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.OnlyStaticMethodsHaveNullExpr">
            <summary>
            A string like  "Static methods requires null expression, non-static property requires non-null expression."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyTypeCannotBeVoid">
            <summary>
            A string like  "Property cannot have a void type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyNotReadable">
            <summary>
            A string like  "Property is not readable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.PropertyNotWriteable">
            <summary>
            A string like  "Property is not writeable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidUnboxType">
            <summary>
            A string like  "Can only unbox from an object or interface type to a value type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExpressionMustBeReadable">
            <summary>
            A string like  "Expression must be readable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExpressionMustBeWriteable">
            <summary>
            A string like  "Expression must be writeable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeException">
            <summary>
            A string like  "Argument must be exception"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SubtreesMustBeBound">
            <summary>
            A string like  "subtrees of nodes with non-null type must also have non-null type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustReduceToReadable">
            <summary>
            A string like  "readable Expression must reduce to readable Expression"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustReduceToWriteable">
            <summary>
            A string like  "writeable Expression must reduce to writeable Expression"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustBeReducible">
            <summary>
            A string like  "must be reducible node"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MustBeReadableOrWriteable">
            <summary>
            A string like  "must be readable or writeable"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidTypeBuilder">
            <summary>
            A string like  "TypeBuilder does not have a valid ModuleBuilder"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ConditionMustBeBoolean">
            <summary>
            A string like  "Condition must be boolean."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeMustBeDerivedFromSystemDelegate">
            <summary>
            A string like  "Type must be derived from System.Delegate"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentTypeCannotBeVoid">
            <summary>
            A string like  "Argument type cannot be void"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LabelMustBeVoidOrHaveExpression">
            <summary>
            A string like  "Label type must be System.Void if an expression is not supplied"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LabelTypeMustBeVoid">
            <summary>
            A string like  "Type must be System.Void for this label argument"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TypeOrBindingInfoMustBeNonNull">
            <summary>
            A string like  "type or bindingInfo must be non-null"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.StartEndMustBeOrdered">
            <summary>
            A string like  "Start and End must be well ordered"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.StartEndCanOnlyBothBeInvalid">
            <summary>
            A string like  "Start and End must both be valid or both invalid"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CannotHaveFinallyAndFault">
            <summary>
            A string like  "cannot have finally and fault"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.TryMustHaveCatchFinallyOrFault">
            <summary>
            A string like  "try must have at least one catch, finally, or fault clause"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeArray">
            <summary>
            A string like  "Argument must be array"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeBoolean">
            <summary>
            A string like  "Argument must be boolean"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeFieldInfoOrPropertInfo">
            <summary>
            A string like  "Argument must be either a FieldInfo or PropertyInfo"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeFieldInfoOrPropertInfoOrMethod">
            <summary>
            A string like  "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeInstanceMember">
            <summary>
            A string like  "Argument must be an instance member"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeInteger">
            <summary>
            A string like  "Argument must be of an integer type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeArrayIndexType">
            <summary>
            A string like  "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            A string like  "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentTypesMustMatch">
            <summary>
            A string like  "Argument types do not match"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CoalesceUsedOnNonNullType">
            <summary>
            A string like  "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfIndexes">
            <summary>
            A string like  "Incorrect number of indexes"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfLambdaArguments">
            <summary>
            A string like  "Incorrect number of arguments supplied for lambda invocation"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfLambdaDeclarationParameters">
            <summary>
            A string like  "Incorrect number of parameters supplied for lambda declaration"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfConstructorArguments">
            <summary>
            A string like  "Incorrect number of arguments for constructor"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfMembersForGivenConstructor">
            <summary>
            A string like  " Incorrect number of members for constructor"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfArgumentsForMembers">
            <summary>
            A string like  "Incorrect number of arguments for the given members "
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LambdaTypeMustBeDerivedFromSystemDelegate">
            <summary>
            A string like  "Lambda type parameter must be derived from System.Delegate"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ListInitializerWithZeroMembers">
            <summary>
            A string like  "List initializers must contain at least one initializer"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodNotAdd">
            <summary>
            A string like  "Element initializer method must be named 'Add'"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodWithZeroArgs">
            <summary>
            A string like  "Element initializer method must have at least 1 parameter"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ElementInitializerMethodStatic">
            <summary>
            A string like  "Element initializer method must be an instance method"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnexpectedCoalesceOperator">
            <summary>
            A string like  "Unexpected coalesce operator."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnhandledBinding">
            <summary>
            A string like  "Unhandled binding "
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnknownBindingType">
            <summary>
            A string like  "Unknown binding type"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfTypeArgsForFunc">
            <summary>
            A string like  "An incorrect number of type args were specified for the declaration of a Func type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.IncorrectNumberOfTypeArgsForAction">
            <summary>
            A string like  "An incorrect number of type args were specified for the declaration of an Action type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExpressionMayNotContainByrefParameters">
            <summary>
            A string like  "A lambda expression cannot contain pass by reference parameters."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ArgumentCannotBeOfTypeVoid">
            <summary>
            A string like  "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NoOrInvalidRuleProduced">
            <summary>
            A string like  "No or Invalid rule produced"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.FirstArgumentMustBeCallSite">
            <summary>
            A string like  "First argument of delegate must be CallSite"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.FirstArgumentMustBeStrongBox">
            <summary>
            A string like  "expected StrongBox, but found null."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BindingCannotBeNull">
            <summary>
            A string like  "Bind cannot return null."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.EmptyRuleSetTarget">
            <summary>
            A string like  "Empty rule set does not have target."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.LhsUnassignable">
            <summary>
            A string like  "Left side of assignment is not an assignable node type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.BadDelegateData">
            <summary>
            A string like  "Bad data bound to delegate."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RemovingUnregisteredEvent">
            <summary>
            A string like  "Removing an event handler that is not registered."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.COMObjectDoesNotSupportEvents">
            <summary>
            A string like  "COM object does not support events."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.COMObjectDoesNotSupportSourceInterface">
            <summary>
            A string like  "COM object does not support specified source interface."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RemovingUnregisteredHandler">
            <summary>
            A string like  "Removing not registered handler."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.SetComObjectDataFailed">
            <summary>
            A string like  "Marshal.SetComObjectData failed."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MethodShouldNotBeCalled">
            <summary>
            A string like  "This method exists only to keep the compiler happy."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.DefaultValueCannotBeRead">
            <summary>
            A string like  "Default value of COM parameter cannot be read properly."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CannotRetrieveTypeInformation">
            <summary>
            A string like  "ResolveComReference.CannotRetrieveTypeInformation."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.UnsupportedEnumType">
            <summary>
            A string like  "Attempting to wrap an unsupported enum type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ComObjectExpected">
            <summary>
            A string like  "COM object is expected."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.QueueEmpty">
            <summary>
            A string like  "Queue empty."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.AddressOfVoidBlock">
            <summary>
            A string like  "Cannot emit address of void-typed block."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotLeaveFinally">
            <summary>
            A string like  "Control cannot leave a finally block."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotLeaveFilterTest">
            <summary>
            A string like  "Control cannot leave a filter test."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotEnterTry">
            <summary>
            A string like  "Control cannot enter a try block."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ControlCannotEnterExpression">
            <summary>
            A string like  "Control cannot enter an expression--only statements can be jumped into."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.DynamicNotReduced">
            <summary>
            A string like  "Dynamic expression not reduced."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ActionNotReduced">
            <summary>
            A string like  "Action should have been reduced."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.DeleteNotReduced">
            <summary>
            A string like  "Delete should have been reduced."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.ExtensionNotReduced">
            <summary>
            A string like  "Extension should have been reduced."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RtConstRequiresBundDelegate">
            <summary>
            A string like  "Runtime constants require a bound delegate."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidOutputDir">
            <summary>
            A string like  "Invalid output directory."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.InvalidAsmNameOrExtension">
            <summary>
            A string like  "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.NoDefaultValue">
            <summary>
            A string like  "No default value for a given type."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.StackChangedWhileEnumerationg">
            <summary>
            A string like  "Stack changed while enumerating."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CollectionReadOnly">
            <summary>
            A string like  "Collection is read-only."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CantReadProperty">
            <summary>
            A string like  "can't read from property"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.CantWriteProperty">
            <summary>
            A string like  "can't write to property"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.WrongIteratorReturnType">
            <summary>
            A string like  "Iterator return type must be IEnumerator or IEnumerator&lt;object&gt;."
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.MissingValueNotSupported">
            <summary>
            A string like  "missing parameter value not yet supported"
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.Strings.RethrowRequiresCatch">
            <summary>
            A string like  "Rethrow statement is valid only inside a Catch block."
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeOrBindingInfoMustBeNonNull">
            <summary>
            ArgumentException with message like "type or bindingInfo must be non-null"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.StartEndMustBeOrdered">
            <summary>
            ArgumentException with message like "Start and End must be well ordered"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.StartEndCanOnlyBothBeInvalid">
            <summary>
            ArgumentException with message like "Start and End must both be valid or both invalid"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotHaveFinallyAndFault">
            <summary>
            ArgumentException with message like "cannot have finally and fault"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TryMustHaveCatchFinallyOrFault">
            <summary>
            ArgumentException with message like "try must have at least one catch, finally, or fault clause"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeArray">
            <summary>
            ArgumentException with message like "Argument must be array"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeBoolean">
            <summary>
            ArgumentException with message like "Argument must be boolean"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeFieldInfoOrPropertInfo">
            <summary>
            ArgumentException with message like "Argument must be either a FieldInfo or PropertyInfo"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeFieldInfoOrPropertInfoOrMethod">
            <summary>
            ArgumentException with message like "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeInstanceMember">
            <summary>
            ArgumentException with message like "Argument must be an instance member"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeInteger">
            <summary>
            ArgumentException with message like "Argument must be of an integer type"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeArrayIndexType">
            <summary>
            ArgumentException with message like "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            ArgumentException with message like "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentTypesMustMatch">
            <summary>
            ArgumentException with message like "Argument types do not match"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotAutoInitializeValueTypeElementThroughProperty(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotAutoInitializeValueTypeMemberThroughProperty(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot auto initialize members of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotCastTypeToType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "An expression of type '{0}' cannot be cast to type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            ArgumentException with message like "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CoalesceUsedOnNonNullType">
            <summary>
            InvalidOperationException with message like "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchConstructorParameter(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentTypeDoesNotMatchMember(System.Object,System.Object)">
            <summary>
            ArgumentException with message like " Argument type '{0}' does not match the corresponding member type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentMemberNotDeclOnType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like " The member '{0}' is not declared on type '{1}' being created"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchMethodParameter(System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchParameter(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchReturn(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for return type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchAssignment(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for assignment to type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeDoesNotMatchLabel(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for label of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionTypeNotInvocable(System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be invoked"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfIndexes">
            <summary>
            ArgumentException with message like "Incorrect number of indexes"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfLambdaArguments">
            <summary>
            InvalidOperationException with message like "Incorrect number of arguments supplied for lambda invocation"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfLambdaDeclarationParameters">
            <summary>
            ArgumentException with message like "Incorrect number of parameters supplied for lambda declaration"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            ArgumentException with message like "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfConstructorArguments">
            <summary>
            ArgumentException with message like "Incorrect number of arguments for constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfMembersForGivenConstructor">
            <summary>
            ArgumentException with message like " Incorrect number of members for constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfArgumentsForMembers">
            <summary>
            ArgumentException with message like "Incorrect number of arguments for the given members "
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LambdaTypeMustBeDerivedFromSystemDelegate">
            <summary>
            ArgumentException with message like "Lambda type parameter must be derived from System.Delegate"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MemberNotFieldOrProperty(System.Object)">
            <summary>
            ArgumentException with message like "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyDoesNotHaveSetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'set' accessor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyDoesNotHaveAccessor(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' or 'set' accessors"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OperatorNotImplementedForType(System.Object,System.Object)">
            <summary>
            NotImplementedException with message like "The operator '{0}' is not implemented for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ParameterExpressionNotValidAsDelegate(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Method '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Type {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Type {0} is a generic type definition"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeMissingDefaultConstructor(System.Object)">
            <summary>
            ArgumentException with message like "Type '{0}' does not have a default constructor"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ListInitializerWithZeroMembers">
            <summary>
            ArgumentException with message like "List initializers must contain at least one initializer"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodNotAdd">
            <summary>
            ArgumentException with message like "Element initializer method must be named 'Add'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodNoRefOutParam(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodWithZeroArgs">
            <summary>
            ArgumentException with message like "Element initializer method must have at least 1 parameter"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ElementInitializerMethodStatic">
            <summary>
            ArgumentException with message like "Element initializer method must be an instance method"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeNotIEnumerable(System.Object)">
            <summary>
            ArgumentException with message like "Type '{0}' is not IEnumerable"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnexpectedCoalesceOperator">
            <summary>
            InvalidOperationException with message like "Unexpected coalesce operator."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidCast(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledBinary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledBinding">
            <summary>
            ArgumentException with message like "Unhandled binding "
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledBindingType(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled Binding Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledConvert(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledExpressionType(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled Expression Type: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnhandledUnary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnknownBindingType">
            <summary>
            ArgumentException with message like "Unknown binding type"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LogicalOperatorMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfTypeArgsForFunc">
            <summary>
            ArgumentException with message like "An incorrect number of type args were specified for the declaration of a Func type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IncorrectNumberOfTypeArgsForAction">
            <summary>
            ArgumentException with message like "An incorrect number of type args were specified for the declaration of an Action type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExpressionMayNotContainByrefParameters">
            <summary>
            ArgumentException with message like "A lambda expression cannot contain pass by reference parameters."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentCannotBeOfTypeVoid">
            <summary>
            ArgumentException with message like "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NoOrInvalidRuleProduced">
            <summary>
            InvalidOperationException with message like "No or Invalid rule produced"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FirstArgumentMustBeCallSite">
            <summary>
            ArgumentException with message like "First argument of delegate must be CallSite"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.FirstArgumentMustBeStrongBox">
            <summary>
            ArgumentException with message like "expected StrongBox, but found null."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BindingCannotBeNull">
            <summary>
            InvalidOperationException with message like "Bind cannot return null."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.EmptyRuleSetTarget">
            <summary>
            InvalidOperationException with message like "Empty rule set does not have target."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LhsUnassignable">
            <summary>
            ArgumentException with message like "Left side of assignment is not an assignable node type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.BadDelegateData">
            <summary>
            InvalidOperationException with message like "Bad data bound to delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ArgumentCountMustMatchBinding(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Argument count (including instance) '{0}' must match arguments in the binding information '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidOperation(System.Object)">
            <summary>
            ArgumentException with message like "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.OutOfRange(System.Object,System.Object)">
            <summary>
            ArgumentOutOfRangeException with message like "{0} must be greater than or equal to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RemovingUnregisteredEvent">
            <summary>
            InvalidOperationException with message like "Removing an event handler that is not registered."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.COMObjectDoesNotSupportEvents">
            <summary>
            ArgumentException with message like "COM object does not support events."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.COMObjectDoesNotSupportSourceInterface">
            <summary>
            ArgumentException with message like "COM object does not support specified source interface."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RemovingUnregisteredHandler">
            <summary>
            InvalidOperationException with message like "Removing not registered handler."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.SetComObjectDataFailed">
            <summary>
            System.Runtime.InteropServices.COMException with message like "Marshal.SetComObjectData failed."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.TypeLibDoesNotContainInterface(System.Object,System.Object)">
            <summary>
            System.Runtime.InteropServices.COMException with message like "TypeLib '{0}' does not contain COM interface '{1}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MethodShouldNotBeCalled">
            <summary>
            InvalidOperationException with message like "This method exists only to keep the compiler happy."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DefaultValueCannotBeRead">
            <summary>
            InvalidProgramException with message like "Default value of COM parameter cannot be read properly."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnexpectedVarEnum(System.Object)">
            <summary>
            InvalidOperationException with message like "Unexpected VarEnum {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DispBadParamCount(System.Object)">
            <summary>
            System.Reflection.TargetParameterCountException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DispMemberNotFound(System.Object)">
            <summary>
            MissingMemberException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DispNoNamedArgs(System.Object)">
            <summary>
            ArgumentException with message like "Error while invoking {0}. Named arguments are not supported."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DispOverflow(System.Object)">
            <summary>
            OverflowException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DispTypeMismatch(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Could not convert argument {0} for call to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DispParamNotOptional(System.Object)">
            <summary>
            ArgumentException with message like "Error while invoking {0}. A required parameter was omitted."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotRetrieveTypeInformation">
            <summary>
            System.Runtime.InteropServices.COMException with message like "ResolveComReference.CannotRetrieveTypeInformation."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.GetIDsOfNamesInvalid(System.Object)">
            <summary>
            ArgumentException with message like "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnsupportedEnumType">
            <summary>
            InvalidOperationException with message like "Attempting to wrap an unsupported enum type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ComObjectExpected">
            <summary>
            ArgumentException with message like "COM object is expected."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CouldNotGetDispId(System.Object,System.Object)">
            <summary>
            MissingMemberException with message like "Could not get DispId for {0} (error:{1})."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.AmbiguousConversion(System.Object,System.Object)">
            <summary>
            System.Reflection.AmbiguousMatchException with message like "There are valid conversions from {0} to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.VariantToObjectNYI(System.Object)">
            <summary>
            NotImplementedException with message like "Variant.ToObject cannot handle {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.VariantGetAccessorNYI(System.Object)">
            <summary>
            NotImplementedException with message like "Variant.GetAccessor cannot handle {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.QueueEmpty">
            <summary>
            InvalidOperationException with message like "Queue empty."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.AddressOfVoidBlock">
            <summary>
            NotSupportedException with message like "Cannot emit address of void-typed block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LabelTargetAlreadyDefined(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot redefine label '{0}' in an inner block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.LabelTargetUndefined(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot jump to to undefined label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotLeaveFinally">
            <summary>
            InvalidOperationException with message like "Control cannot leave a finally block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotLeaveFilterTest">
            <summary>
            InvalidOperationException with message like "Control cannot leave a filter test."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.AmbiguousJump(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot jump to ambiguous label '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotEnterTry">
            <summary>
            InvalidOperationException with message like "Control cannot enter a try block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ControlCannotEnterExpression">
            <summary>
            InvalidOperationException with message like "Control cannot enter an expression--only statements can be jumped into."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DynamicNotReduced">
            <summary>
            InvalidOperationException with message like "Dynamic expression not reduced."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ActionNotReduced">
            <summary>
            InvalidOperationException with message like "Action should have been reduced."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.DeleteNotReduced">
            <summary>
            InvalidOperationException with message like "Delete should have been reduced."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.ExtensionNotReduced">
            <summary>
            InvalidOperationException with message like "Extension should have been reduced."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RtConstRequiresBundDelegate">
            <summary>
            InvalidOperationException with message like "Runtime constants require a bound delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidLvalue(System.Object)">
            <summary>
            InvalidOperationException with message like "Invalid lvalue for assignment: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidMemberType(System.Object)">
            <summary>
            InvalidOperationException with message like "Invalid member type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnknownLiftType(System.Object)">
            <summary>
            InvalidOperationException with message like "unknown lift type: '{0}'."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidOutputDir">
            <summary>
            ArgumentException with message like "Invalid output directory."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidAsmNameOrExtension">
            <summary>
            ArgumentException with message like "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NoImplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NoExplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.NoDefaultValue">
            <summary>
            ArgumentException with message like "No default value for a given type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.StackChangedWhileEnumerationg">
            <summary>
            InvalidOperationException with message like "Stack changed while enumerating."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CollectionReadOnly">
            <summary>
            NotSupportedException with message like "Collection is read-only."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CantReadProperty">
            <summary>
            InvalidOperationException with message like "can't read from property"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CantWriteProperty">
            <summary>
            InvalidOperationException with message like "can't write to property"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.IllegalNewGenericParams(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            System.Security.VerificationException with message like "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnboundVariable(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UndefinedVariable(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.WrongIteratorReturnType">
            <summary>
            ArgumentException with message like "Iterator return type must be IEnumerator or IEnumerator&lt;object&gt;."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.InvalidReturnTypeOfLambda(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MissingReturnForLambda(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Expression missing for return in lambda '{0}', must have return type '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.CannotCloseOverByRef(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnexpectedType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.UnexpectedVarArgsCall(System.Object)">
            <summary>
            InvalidOperationException with message like "Unexpected VarArgs call to method '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MissingValueNotSupported">
            <summary>
            NotSupportedException with message like "missing parameter value not yet supported"
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RethrowRequiresCatch">
            <summary>
            InvalidOperationException with message like "Rethrow statement is valid only inside a Catch block."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.MustRewriteToSameType(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "When called from '{0}', rewriting a node of type '{1}' should return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type."
            </summary>
        </member>
        <member name="M:Microsoft.Linq.Expressions.Error.RuntimeVariablesNotSupportedInQuote(System.Object)">
            <summary>
            NotSupportedException with message like "A Quote expression cannot be used on RuntimeVariables expression '{0}' because at least one variable is declared outside the Quote"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComRuntimeHelpers.GetITypeInfoFromIDispatch(Microsoft.Scripting.Com.IDispatch,System.Boolean)">
            <summary>
            Look for typeinfo using IDispatch.GetTypeInfo
            </summary>
            <param name="dispatch"></param>
            <param name="throwIfMissingExpectedTypeInfo">
            Some COM objects just dont expose typeinfo. In these cases, this method will return null.
            Some COM objects do intend to expose typeinfo, but may not be able to do so if the type-library is not properly 
            registered. This will be considered as acceptable or as an error condition depending on throwIfMissingExpectedTypeInfo</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComRuntimeHelpers.CheckIfMissingTypeInfoIsExpected(System.Int32,System.Boolean)">
            <summary>
            This method should be called when typeinfo is not available for an object. The function
            will check if the typeinfo is expected to be missing. This can include error cases where
            the same error is guaranteed to happen all the time, on all machines, under all circumstances.
            In such cases, we just have to operate without the typeinfo.
            
            However, if accessing the typeinfo is failing in a transient way, we might want to throw
            an exception so that we will eagerly predictably indicate the problem.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.UnsafeMethods">
            <summary>
            This class contains methods that either cannot be expressed in C#, or which require writing unsafe code.
            Callers of these methods need to use them extremely carefully as incorrect use could cause GC-holes
            and other problems.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.UnsafeMethods.AssertByrefPointsToStack(System.IntPtr)">
            <summary>
            TODO: Used only in DEBUG build. Remove?
            
            Ensure that "value" is a local variable in some caller's frame. So converting
            the byref to an IntPtr is a safe operation. Alternatively, we could also allow 
            allowed "value"  to be a pinned object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.UnsafeMethods.IUnknownReleaseDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given interface pointer. 
            This approach can take only ~300 instructions on x86 compared with ~900 for Marshal.Release. We are relying on 
            the JIT-compiler to do pinvoke-stub-inlining and calling the pinvoke target directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.UnsafeMethods.IDispatchInvokeDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given IDispatch interface pointer. 
            It is not possible to express this in C#. Using an indirect pinvoke call allows us to do our own marshalling. 
            We can allocate the Variant arguments cheaply on the stack. We are relying on the JIT-compiler to do 
            pinvoke-stub-inlining and calling the pinvoke target directly.
            The alternative of calling via a managed interface declaration of IDispatch would have a performance
            penalty of going through a CLR stub that would have to re-push the arguments on the stack, etc.
            Marshal.GetDelegateForFunctionPointer could be used here, but its too expensive (~2000 instructions on x86).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetBooleanOperator(System.Type,System.String)">
            <summary>
            Searches for an operator method on the type. The method must have
            the specified signature, no generic arguments, and have the
            SpecialName bit set. Also searches inherited operator methods.
            
            NOTE: This was designed to satisfy the needs of op_True and
            op_False, because we have to do runtime lookup for those. It may
            not work right for unary operators in general.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetTypeForBinding(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetTypesForBinding(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Simply returns a Type[] from calling GetTypeForBinding on each element
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.AutoRuleTemplate">
            <summary>
            Handles auto-templating of rules.  There are three important actions this performs:
                1. Detects if templating is possible between two rules
                2. Re-writes a non-templated rule into templated form
                3. Extracts the constants from a non-templated rule which is compatible with a 
                    templated rule so that they can be used by the existing generated code.
                    
            Auto-templating is currently only used for serially monomorphic call sites where we
            can easily avoid code gen.  It is not used for polymorphic call sites although such
            a feature could be enabled in the future.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.AutoRuleTemplate.CopyOrCreateTemplatedRule``1(Microsoft.Scripting.Actions.Rule{``0},Microsoft.Scripting.Actions.Rule{``0})">
            <summary>
            The entry point into auto-rule tempating.  This consumes the monomorphic rule which is currently
            stored in the cache as well as the rule that was just produced by the binder.  
            </summary>
            <param name="from">The original rule that is currently stored in the cache.  This rule may
            or may not be a templated rule.</param>
            <param name="to">The new rule produced by a binder.</param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.AutoRuleTemplate.CloneData(System.Object,System.Object[])">
            <summary>
            Clones the delegate target to create new delegate around it.
            The delegates created by the compiler are closed over the instance of Closure class.
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.GotoExpression.Value">
            <summary>
            The value passed to the target, or null if the target is of type
            System.Void
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.GotoExpression.Target">
            <summary>
            The target label where this node jumps to
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.GotoExpression.Kind">
            <summary>
            The kind of the goto. For information purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Restrictions.AddRestrictions(Microsoft.Scripting.Actions.Restrictions.Restriction[],System.Collections.Generic.List{Microsoft.Scripting.Actions.Restrictions.Restriction})">
            <summary>
            Adds unique restrictions and doesn't add restrictions which are alerady present
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Restrictions.CreateTypeRestriction(Microsoft.Linq.Expressions.Expression,System.Type)">
            <summary>
            Creates one type identity test 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.IsSealedOrValueType(System.Type)">
            <summary>
            A helper routine to check if a type can be treated as sealed - i.e. there
            can never be a subtype of this given type.  This corresponds to a type
            that is either declared "Sealed" or is a ValueType and thus unable to be
            extended.
            
            TODO: this should not be needed. Type.IsSealed does the right thing.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeExtensions.IsMandatoryParameter(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.ComObjectWithTypeInfo">
             <summary>
             A COM object can expose its type information in two ways:
             1. IProvideClassInfo
             2. IDispatch.GetTypeInfo
             If we can determine the COM type, we can cast the object to this COM type to perform operations.
            
             Note that the CLR tries to associate strong type information (metadata) with COM objects if
             possible. ComObjectWithTypeInfo tries to provide similar functionality. However, it can try even
             harder.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComObjectWithTypeInfo.PublishComTypes(System.Reflection.Assembly)">
            <summary>
            When an (interop) assembly is loaded, we scan it to discover the GUIDs of COM interfaces so that we can
            associate the type definition with COM objects with that GUID.
            Since scanning all loaded assemblies can be expensive, in the future, we might consider a more explicit 
            user action to trigger scanning of COM types.
            </summary>
        </member>
        <member name="T:Microsoft.Linq.Expressions.Compiler.KeyedQueue`2">
            <summary>
            A simple dictionary of queues, keyed off a particular type
            This is useful for storing free lists of variables
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.TypeInfoMetaObject.MakeComRestrictions(System.Type,System.Reflection.PropertyInfo,System.Object)">
            <summary>
            The rule test now checks to ensure that the wrapper is of the correct type so that any cast against on the RCW will succeed.
            Note that the test must NOT test the wrapper itself since the wrapper is a surrogate for the RCW instance and would cause a  
            memory leak when a wrapped RCW goes out of scope.  So, the test asks the argument (which is an RCW wrapper) to identify its 
            RCW's type.  On the rule creation side, the type is encoded in the test so that when the rule cache is searched the test will 
            succeed only if the wrapper's returned RCW type matches that expected by the test. 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComTypeLibDesc.CreateFromGuid(System.Guid)">
            <summary>
            Reads the latest registered type library for the corresponding GUID,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicObject that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="typeLibGuid">Type Library Guid</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="M:Microsoft.Scripting.Com.ComTypeLibDesc.CreateFromObject(System.Object)">
            <summary>
            Gets an ITypeLib object from OLE Automation compatible RCW ,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicObject that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="rcw">OLE automation compatible RCW</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="T:Microsoft.Scripting.SourceLocation">
            <summary>
            Represents a location in source code.
            TODO: move to Microsoft.Linq.Expressions
            TODO: review public APIs !!!
                  Lots of stuff on here that is not used by the compiler
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new source location.
            </summary>
            <param name="index">The index in the source stream the location represents (0-based).</param>
            <param name="line">The line in the source stream the location represents (1-based).</param>
            <param name="column">The column in the source stream the location represents (1-based).</param>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_Equality(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_Inequality(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are not equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are not the same, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_LessThan(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_GreaterThan(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_LessThanOrEqual(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.op_GreaterThanOrEqual(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.SourceLocation.Compare(Microsoft.Scripting.SourceLocation,Microsoft.Scripting.SourceLocation)">
            <summary>
            Compares two specified location values.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>0 if the locations are equal, -1 if the left one is less than the right one, 1 otherwise.</returns>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.None">
            <summary>
            A location that is valid but represents no location at all.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.Invalid">
            <summary>
            An invalid location.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.SourceLocation.MinValue">
            <summary>
            A minimal valid location.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Index">
            <summary>
            The index in the source stream the location represents (0-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Line">
            <summary>
            The line in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.Column">
            <summary>
            The column in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceLocation.IsValid">
            <summary>
            Whether the location is a valid location.
            </summary>
            <returns>True if the location is valid, False otherwise.</returns>
        </member>
        <member name="T:Microsoft.Linq.Expressions.ScopeExpression">
            <summary>
            Defines a scope where variables are defined. The compiler will
            automatically close over these variables if they're referenced in a
            nested LambdaExpession
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.ScopeExpression.Body">
            <summary>
            The body of the scope
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.ScopeExpression.Name">
            <summary>
            The friendly name of this scope. Can be null
            </summary>
        </member>
        <member name="P:Microsoft.Linq.Expressions.ScopeExpression.Variables">
            <summary>
            The variables in this scope
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DynamicSiteHelpers.CreateDynamicMethod(System.Boolean,System.String,System.Type,System.Type[])">
            <summary>
            Dynamic code generation required by dynamic sites needs to be able to call the delegate by which the
            call site is parametrized. If the delegate type is visible, we can generate into assembly (if saving
            assemblies). With delegate types that are not visible we must generate LCG in order to skip visibility.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.CompilerServices.Closure">
            <summary>
            If the delegate generated by the Lambda compiler needs to either be a
            closure, or close over constants, the delegate itself will close over
            the instance of this object.
            
            TODO: Prevent this from being exposed as public surface area. See what
            Linq v1 does with System.Runtime.CompilerServices.ExecutionScope
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.Closure.Constants">
            <summary>
            The constant pool
            </summary>
        </member>
        <member name="F:Microsoft.Runtime.CompilerServices.Closure.Locals">
            <summary>
            The environment, which stores closed over variables from the parent
            scope
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.VarEnumSelector">
            <summary>
            If a managed user type (as opposed to a primitive type or a COM object) is passed as an argument to a COM call, we need
            to determine the VarEnum type we will marshal it as. We have the following options:
            1.	Raise an exception. Languages with their own version of primitive types would not be able to call
                COM methods using the language's types (for eg. strings in IronRuby are not System.String). An explicit
                cast would be needed.
            2.	We could marshal it as VT_DISPATCH. Then COM code will be able to access all the APIs in a late-bound manner,
                but old COM components will probably malfunction if they expect a primitive type.
            3.	We could guess which primitive type is the closest match. This will make COM components be as easily 
                accessible as .NET methods.
            4.	We could use the type library to check what the expected type is. However, the type library may not be available.
            
            VarEnumSelector implements option # 3
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.#ctor(System.Type,System.Object[])">
            <summary>
            This constructor infers the COM types to marshal the arguments to based on
            the conversions supported for the given argument type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.BuildArguments(System.Object[],System.Reflection.ParameterModifier@)">
            <summary>
            Gets the arguments ready for marshaling to COM
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.GetManagedMarshalType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Gets the managed type that an object needs to be coverted to in order for it to be able
            to be represented as a Variant.
            
            In general, there is a many-to-many mapping between Type and VarEnum. However, this method
            returns a simple mapping that is needed for the current implementation. The reason for the 
            many-to-many relation is:
            1. Int32 maps to VT_I4 as well as VT_ERROR, and Decimal maps to VT_DECIMAL and VT_CY. However,
               this changes if you throw the wrapper types into the mix.
            2. There is no Type to represent COM types. __ComObject is a private type, and Object is too
               general.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.CreateComPrimitiveTypeFamilies">
            <summary>
            Creates a family of COM types such that within each family, there is a completely non-lossy
            conversion from a type to an earlier type in the family.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.GetConversionsToComPrimitiveTypeFamilies(System.Type)">
            <summary>
            Get the (one representative type for each) primitive type families that the argument can be converted to
            at the given NarrowingLevel.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.CheckForAmbiguousMatch(System.Type,System.Collections.Generic.List{System.Runtime.InteropServices.VarEnum})">
            <summary>
            If there is more than one type family that the argument can be converted to, we will throw a
            AmbiguousMatchException instead of randomly picking a winner.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.TryGetPrimitiveComType(System.Type,System.Runtime.InteropServices.VarEnum@)">
            <summary>
            Is there a unique primitive type that has the best conversion for the argument
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Com.VarEnumSelector.GetVariantBuilder(System.Type)">
            <summary>
            Get the COM Variant type that argument should be marshaled as for a call to COM
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Com.VarEnumSelector.IsSupportedByFastPath">
            <summary>
            Can IDispatchCallBinderHelper generate an optimized DynamicSite, or should we fall back
            to the slow DispCallable.UpoptimizedInvoke
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Com.VarEnumSelector.NarrowingLevel">
            <summary>
            Narrowing conversions are conversions that cannot be proved to always succeed, conversions that are 
            known to possibly lose information, and conversions across domains of types sufficiently different 
            to merit narrowing notation like casts. 
            
            Its upto every language to define the levels for conversions. The narrowling levels can be used by
            for method overload resolution, where the overload is based on the parameter types (and not the number 
            of parameters).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Com.VarEnumSelector.NarrowingLevel.None">
            <summary>
            Conversions at this level do not do any narrowing. Typically, this will include
            implicit numeric conversions, Type.IsAssignableFrom, StringBuilder to string, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Com.VarEnumSelector.NarrowingLevel.One">
            <summary>
            Language defined prefered narrowing conversion.  First level that introduces narrowing
            conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Com.VarEnumSelector.NarrowingLevel.Two">
            <summary>
            Language defined preferred narrowing conversion.  Second level that introduces narrowing
            conversions and should have more conversions than One.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Com.VarEnumSelector.NarrowingLevel.Three">
            <summary>
            Language defined preferred narrowing conversion.  Third level that introduces narrowing
            conversions and should have more conversions that Two.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Com.VarEnumSelector.NarrowingLevel.All">
            <summary>
            A somewhat meaningful conversion is possible, but it will quite likely be lossy.
            For eg. BigInteger to an Int32, Boolean to Int32, one-char string to a char,
            larger number type to a smaller numeric type (where there is no overflow), etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Stitcher">
            <summary>
            Stitcher, a.k.a Rule inliner. Takes list of rules and produces LambdaExpression with the
            rules inlined, adding the "update" call at the very end.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Stitcher._lp">
            <summary>
            LambdaExpression parameters
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Stitcher._lambdaReturn">
            <summary>
            LabelExpression return label
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Stitcher._map">
            <summary>
            Mapping of the ParameterExpression (rule) -> ParameterExpression (lambda)
            </summary>
        </member>
    </members>
</doc>
